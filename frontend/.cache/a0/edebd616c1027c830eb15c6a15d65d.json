{"id":"index.js","dependencies":[{"name":"/home/v0d1ch/code/devnull/frontend/package.json","includedInParent":true,"mtime":1600803213249}],"generated":{"js":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n// Generated by purs bundle 0.13.8\nvar PS = {};\n\n(function (exports) {\n  \"use strict\";\n\n  exports.arrayMap = function (f) {\n    return function (arr) {\n      var l = arr.length;\n      var result = new Array(l);\n\n      for (var i = 0; i < l; i++) {\n        result[i] = f(arr[i]);\n      }\n\n      return result;\n    };\n  };\n})(PS[\"Data.Functor\"] = PS[\"Data.Functor\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.Function\"] = $PS[\"Data.Function\"] || {};\n  var exports = $PS[\"Data.Function\"];\n\n  var flip = function flip(f) {\n    return function (b) {\n      return function (a) {\n        return f(a)(b);\n      };\n    };\n  };\n\n  var $$const = function $$const(a) {\n    return function (v) {\n      return a;\n    };\n  };\n\n  exports[\"flip\"] = flip;\n  exports[\"const\"] = $$const;\n})(PS);\n\n(function (exports) {\n  \"use strict\";\n\n  exports.unit = {};\n})(PS[\"Data.Unit\"] = PS[\"Data.Unit\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.Unit\"] = $PS[\"Data.Unit\"] || {};\n  var exports = $PS[\"Data.Unit\"];\n  var $foreign = $PS[\"Data.Unit\"];\n  exports[\"unit\"] = $foreign.unit;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.Functor\"] = $PS[\"Data.Functor\"] || {};\n  var exports = $PS[\"Data.Functor\"];\n  var $foreign = $PS[\"Data.Functor\"];\n  var Data_Function = $PS[\"Data.Function\"];\n  var Data_Unit = $PS[\"Data.Unit\"];\n\n  var Functor = function Functor(map) {\n    this.map = map;\n  };\n\n  var map = function map(dict) {\n    return dict.map;\n  };\n\n  var $$void = function $$void(dictFunctor) {\n    return map(dictFunctor)(Data_Function[\"const\"](Data_Unit.unit));\n  };\n\n  var voidLeft = function voidLeft(dictFunctor) {\n    return function (f) {\n      return function (x) {\n        return map(dictFunctor)(Data_Function[\"const\"](x))(f);\n      };\n    };\n  };\n\n  var voidRight = function voidRight(dictFunctor) {\n    return function (x) {\n      return map(dictFunctor)(Data_Function[\"const\"](x));\n    };\n  };\n\n  var functorArray = new Functor($foreign.arrayMap);\n  exports[\"Functor\"] = Functor;\n  exports[\"map\"] = map;\n  exports[\"void\"] = $$void;\n  exports[\"voidRight\"] = voidRight;\n  exports[\"voidLeft\"] = voidLeft;\n  exports[\"functorArray\"] = functorArray;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Control.Semigroupoid\"] = $PS[\"Control.Semigroupoid\"] || {};\n  var exports = $PS[\"Control.Semigroupoid\"];\n\n  var Semigroupoid = function Semigroupoid(compose) {\n    this.compose = compose;\n  };\n\n  var semigroupoidFn = new Semigroupoid(function (f) {\n    return function (g) {\n      return function (x) {\n        return f(g(x));\n      };\n    };\n  });\n  exports[\"semigroupoidFn\"] = semigroupoidFn;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Control.Category\"] = $PS[\"Control.Category\"] || {};\n  var exports = $PS[\"Control.Category\"];\n  var Control_Semigroupoid = $PS[\"Control.Semigroupoid\"];\n\n  var Category = function Category(Semigroupoid0, identity) {\n    this.Semigroupoid0 = Semigroupoid0;\n    this.identity = identity;\n  };\n\n  var identity = function identity(dict) {\n    return dict.identity;\n  };\n\n  var categoryFn = new Category(function () {\n    return Control_Semigroupoid.semigroupoidFn;\n  }, function (x) {\n    return x;\n  });\n  exports[\"identity\"] = identity;\n  exports[\"categoryFn\"] = categoryFn;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Control.Apply\"] = $PS[\"Control.Apply\"] || {};\n  var exports = $PS[\"Control.Apply\"];\n  var Control_Category = $PS[\"Control.Category\"];\n  var Data_Function = $PS[\"Data.Function\"];\n  var Data_Functor = $PS[\"Data.Functor\"];\n\n  var Apply = function Apply(Functor0, apply) {\n    this.Functor0 = Functor0;\n    this.apply = apply;\n  };\n\n  var apply = function apply(dict) {\n    return dict.apply;\n  };\n\n  var applySecond = function applySecond(dictApply) {\n    return function (a) {\n      return function (b) {\n        return apply(dictApply)(Data_Functor.map(dictApply.Functor0())(Data_Function[\"const\"](Control_Category.identity(Control_Category.categoryFn)))(a))(b);\n      };\n    };\n  };\n\n  var lift2 = function lift2(dictApply) {\n    return function (f) {\n      return function (a) {\n        return function (b) {\n          return apply(dictApply)(Data_Functor.map(dictApply.Functor0())(f)(a))(b);\n        };\n      };\n    };\n  };\n\n  exports[\"Apply\"] = Apply;\n  exports[\"apply\"] = apply;\n  exports[\"applySecond\"] = applySecond;\n  exports[\"lift2\"] = lift2;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Control.Bind\"] = $PS[\"Control.Bind\"] || {};\n  var exports = $PS[\"Control.Bind\"];\n  var Data_Function = $PS[\"Data.Function\"];\n\n  var Discard = function Discard(discard) {\n    this.discard = discard;\n  };\n\n  var Bind = function Bind(Apply0, bind) {\n    this.Apply0 = Apply0;\n    this.bind = bind;\n  };\n\n  var discard = function discard(dict) {\n    return dict.discard;\n  };\n\n  var bind = function bind(dict) {\n    return dict.bind;\n  };\n\n  var bindFlipped = function bindFlipped(dictBind) {\n    return Data_Function.flip(bind(dictBind));\n  };\n\n  var composeKleisliFlipped = function composeKleisliFlipped(dictBind) {\n    return function (f) {\n      return function (g) {\n        return function (a) {\n          return bindFlipped(dictBind)(f)(g(a));\n        };\n      };\n    };\n  };\n\n  var discardUnit = new Discard(function (dictBind) {\n    return bind(dictBind);\n  });\n  exports[\"Bind\"] = Bind;\n  exports[\"bind\"] = bind;\n  exports[\"bindFlipped\"] = bindFlipped;\n  exports[\"discard\"] = discard;\n  exports[\"composeKleisliFlipped\"] = composeKleisliFlipped;\n  exports[\"discardUnit\"] = discardUnit;\n})(PS);\n\n(function (exports) {\n  \"use strict\";\n\n  var refEq = function refEq(r1) {\n    return function (r2) {\n      return r1 === r2;\n    };\n  };\n\n  exports.eqBooleanImpl = refEq;\n  exports.eqIntImpl = refEq;\n  exports.eqStringImpl = refEq;\n})(PS[\"Data.Eq\"] = PS[\"Data.Eq\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.Eq\"] = $PS[\"Data.Eq\"] || {};\n  var exports = $PS[\"Data.Eq\"];\n  var $foreign = $PS[\"Data.Eq\"];\n\n  var Eq = function Eq(eq) {\n    this.eq = eq;\n  };\n\n  var eqString = new Eq($foreign.eqStringImpl);\n  var eqInt = new Eq($foreign.eqIntImpl);\n  var eqBoolean = new Eq($foreign.eqBooleanImpl);\n\n  var eq = function eq(dict) {\n    return dict.eq;\n  };\n\n  exports[\"Eq\"] = Eq;\n  exports[\"eq\"] = eq;\n  exports[\"eqBoolean\"] = eqBoolean;\n  exports[\"eqInt\"] = eqInt;\n  exports[\"eqString\"] = eqString;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.Maybe\"] = $PS[\"Data.Maybe\"] || {};\n  var exports = $PS[\"Data.Maybe\"];\n  var Control_Apply = $PS[\"Control.Apply\"];\n  var Control_Bind = $PS[\"Control.Bind\"];\n  var Control_Category = $PS[\"Control.Category\"];\n  var Data_Eq = $PS[\"Data.Eq\"];\n  var Data_Function = $PS[\"Data.Function\"];\n  var Data_Functor = $PS[\"Data.Functor\"];\n\n  var Nothing = function () {\n    function Nothing() {}\n\n    ;\n    Nothing.value = new Nothing();\n    return Nothing;\n  }();\n\n  var Just = function () {\n    function Just(value0) {\n      this.value0 = value0;\n    }\n\n    ;\n\n    Just.create = function (value0) {\n      return new Just(value0);\n    };\n\n    return Just;\n  }();\n\n  var maybe = function maybe(v) {\n    return function (v1) {\n      return function (v2) {\n        if (v2 instanceof Nothing) {\n          return v;\n        }\n\n        ;\n\n        if (v2 instanceof Just) {\n          return v1(v2.value0);\n        }\n\n        ;\n        throw new Error(\"Failed pattern match at Data.Maybe (line 217, column 1 - line 217, column 51): \" + [v.constructor.name, v1.constructor.name, v2.constructor.name]);\n      };\n    };\n  };\n\n  var isNothing = maybe(true)(Data_Function[\"const\"](false));\n  var isJust = maybe(false)(Data_Function[\"const\"](true));\n  var functorMaybe = new Data_Functor.Functor(function (v) {\n    return function (v1) {\n      if (v1 instanceof Just) {\n        return new Just(v(v1.value0));\n      }\n\n      ;\n      return Nothing.value;\n    };\n  });\n\n  var fromMaybe = function fromMaybe(a) {\n    return maybe(a)(Control_Category.identity(Control_Category.categoryFn));\n  };\n\n  var fromJust = function fromJust(dictPartial) {\n    return function (v) {\n      if (v instanceof Just) {\n        return v.value0;\n      }\n\n      ;\n      throw new Error(\"Failed pattern match at Data.Maybe (line 268, column 1 - line 268, column 46): \" + [v.constructor.name]);\n    };\n  };\n\n  var eqMaybe = function eqMaybe(dictEq) {\n    return new Data_Eq.Eq(function (x) {\n      return function (y) {\n        if (x instanceof Nothing && y instanceof Nothing) {\n          return true;\n        }\n\n        ;\n\n        if (x instanceof Just && y instanceof Just) {\n          return Data_Eq.eq(dictEq)(x.value0)(y.value0);\n        }\n\n        ;\n        return false;\n      };\n    });\n  };\n\n  var applyMaybe = new Control_Apply.Apply(function () {\n    return functorMaybe;\n  }, function (v) {\n    return function (v1) {\n      if (v instanceof Just) {\n        return Data_Functor.map(functorMaybe)(v.value0)(v1);\n      }\n\n      ;\n\n      if (v instanceof Nothing) {\n        return Nothing.value;\n      }\n\n      ;\n      throw new Error(\"Failed pattern match at Data.Maybe (line 67, column 1 - line 69, column 30): \" + [v.constructor.name, v1.constructor.name]);\n    };\n  });\n  var bindMaybe = new Control_Bind.Bind(function () {\n    return applyMaybe;\n  }, function (v) {\n    return function (v1) {\n      if (v instanceof Just) {\n        return v1(v.value0);\n      }\n\n      ;\n\n      if (v instanceof Nothing) {\n        return Nothing.value;\n      }\n\n      ;\n      throw new Error(\"Failed pattern match at Data.Maybe (line 125, column 1 - line 127, column 28): \" + [v.constructor.name, v1.constructor.name]);\n    };\n  });\n  exports[\"Nothing\"] = Nothing;\n  exports[\"Just\"] = Just;\n  exports[\"maybe\"] = maybe;\n  exports[\"fromMaybe\"] = fromMaybe;\n  exports[\"isJust\"] = isJust;\n  exports[\"isNothing\"] = isNothing;\n  exports[\"fromJust\"] = fromJust;\n  exports[\"functorMaybe\"] = functorMaybe;\n  exports[\"bindMaybe\"] = bindMaybe;\n  exports[\"eqMaybe\"] = eqMaybe;\n})(PS);\n\n(function (exports) {\n  \"use strict\";\n\n  exports.concatString = function (s1) {\n    return function (s2) {\n      return s1 + s2;\n    };\n  };\n})(PS[\"Data.Semigroup\"] = PS[\"Data.Semigroup\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.Semigroup\"] = $PS[\"Data.Semigroup\"] || {};\n  var exports = $PS[\"Data.Semigroup\"];\n  var $foreign = $PS[\"Data.Semigroup\"];\n\n  var Semigroup = function Semigroup(append) {\n    this.append = append;\n  };\n\n  var semigroupString = new Semigroup($foreign.concatString);\n\n  var append = function append(dict) {\n    return dict.append;\n  };\n\n  exports[\"Semigroup\"] = Semigroup;\n  exports[\"append\"] = append;\n  exports[\"semigroupString\"] = semigroupString;\n})(PS);\n\n(function (exports) {\n  \"use strict\";\n\n  exports.replaceAll = function (s1) {\n    return function (s2) {\n      return function (s3) {\n        return s3.replace(new RegExp(s1.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\"), \"g\"), s2); // eslint-disable-line no-useless-escape\n      };\n    };\n  };\n})(PS[\"Data.String.Common\"] = PS[\"Data.String.Common\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.String.Common\"] = $PS[\"Data.String.Common\"] || {};\n  var exports = $PS[\"Data.String.Common\"];\n  var $foreign = $PS[\"Data.String.Common\"];\n  exports[\"replaceAll\"] = $foreign.replaceAll;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.String.NonEmpty.Internal\"] = $PS[\"Data.String.NonEmpty.Internal\"] || {};\n  var exports = $PS[\"Data.String.NonEmpty.Internal\"];\n  var Data_Eq = $PS[\"Data.Eq\"];\n  var Data_Maybe = $PS[\"Data.Maybe\"];\n  var Data_Semigroup = $PS[\"Data.Semigroup\"];\n  var Data_String_Common = $PS[\"Data.String.Common\"];\n\n  var toString = function toString(v) {\n    return v;\n  };\n\n  var semigroupNonEmptyString = Data_Semigroup.semigroupString;\n\n  var replaceAll = function replaceAll(pat) {\n    return function (v) {\n      return function (v1) {\n        return Data_String_Common.replaceAll(pat)(v)(v1);\n      };\n    };\n  };\n\n  var fromString = function fromString(v) {\n    if (v === \"\") {\n      return Data_Maybe.Nothing.value;\n    }\n\n    ;\n    return new Data_Maybe.Just(v);\n  };\n\n  var unsafeFromString = function unsafeFromString(dictPartial) {\n    var $52 = Data_Maybe.fromJust();\n    return function ($53) {\n      return $52(fromString($53));\n    };\n  };\n\n  var eqNonEmptyString = Data_Eq.eqString;\n  exports[\"unsafeFromString\"] = unsafeFromString;\n  exports[\"toString\"] = toString;\n  exports[\"replaceAll\"] = replaceAll;\n  exports[\"eqNonEmptyString\"] = eqNonEmptyString;\n  exports[\"semigroupNonEmptyString\"] = semigroupNonEmptyString;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Control.Applicative\"] = $PS[\"Control.Applicative\"] || {};\n  var exports = $PS[\"Control.Applicative\"];\n  var Control_Apply = $PS[\"Control.Apply\"];\n  var Data_Unit = $PS[\"Data.Unit\"];\n\n  var Applicative = function Applicative(Apply0, pure) {\n    this.Apply0 = Apply0;\n    this.pure = pure;\n  };\n\n  var pure = function pure(dict) {\n    return dict.pure;\n  };\n\n  var unless = function unless(dictApplicative) {\n    return function (v) {\n      return function (v1) {\n        if (!v) {\n          return v1;\n        }\n\n        ;\n\n        if (v) {\n          return pure(dictApplicative)(Data_Unit.unit);\n        }\n\n        ;\n        throw new Error(\"Failed pattern match at Control.Applicative (line 62, column 1 - line 62, column 65): \" + [v.constructor.name, v1.constructor.name]);\n      };\n    };\n  };\n\n  var when = function when(dictApplicative) {\n    return function (v) {\n      return function (v1) {\n        if (v) {\n          return v1;\n        }\n\n        ;\n\n        if (!v) {\n          return pure(dictApplicative)(Data_Unit.unit);\n        }\n\n        ;\n        throw new Error(\"Failed pattern match at Control.Applicative (line 57, column 1 - line 57, column 63): \" + [v.constructor.name, v1.constructor.name]);\n      };\n    };\n  };\n\n  var liftA1 = function liftA1(dictApplicative) {\n    return function (f) {\n      return function (a) {\n        return Control_Apply.apply(dictApplicative.Apply0())(pure(dictApplicative)(f))(a);\n      };\n    };\n  };\n\n  exports[\"Applicative\"] = Applicative;\n  exports[\"pure\"] = pure;\n  exports[\"liftA1\"] = liftA1;\n  exports[\"unless\"] = unless;\n  exports[\"when\"] = when;\n})(PS);\n\n(function (exports) {\n  \"use strict\"; // module Unsafe.Coerce\n\n  exports.unsafeCoerce = function (x) {\n    return x;\n  };\n})(PS[\"Unsafe.Coerce\"] = PS[\"Unsafe.Coerce\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Unsafe.Coerce\"] = $PS[\"Unsafe.Coerce\"] || {};\n  var exports = $PS[\"Unsafe.Coerce\"];\n  var $foreign = $PS[\"Unsafe.Coerce\"];\n  exports[\"unsafeCoerce\"] = $foreign.unsafeCoerce;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.Exists\"] = $PS[\"Data.Exists\"] || {};\n  var exports = $PS[\"Data.Exists\"];\n  var Unsafe_Coerce = $PS[\"Unsafe.Coerce\"];\n  var runExists = Unsafe_Coerce.unsafeCoerce;\n  var mkExists = Unsafe_Coerce.unsafeCoerce;\n  exports[\"mkExists\"] = mkExists;\n  exports[\"runExists\"] = runExists;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.Coyoneda\"] = $PS[\"Data.Coyoneda\"] || {};\n  var exports = $PS[\"Data.Coyoneda\"];\n  var Control_Category = $PS[\"Control.Category\"];\n  var Data_Exists = $PS[\"Data.Exists\"];\n  var Data_Functor = $PS[\"Data.Functor\"];\n\n  var CoyonedaF = function () {\n    function CoyonedaF(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n\n    ;\n\n    CoyonedaF.create = function (value0) {\n      return function (value1) {\n        return new CoyonedaF(value0, value1);\n      };\n    };\n\n    return CoyonedaF;\n  }();\n\n  var Coyoneda = function Coyoneda(x) {\n    return x;\n  };\n\n  var unCoyoneda = function unCoyoneda(f) {\n    return function (v) {\n      return Data_Exists.runExists(function (v1) {\n        return f(v1.value0)(v1.value1);\n      })(v);\n    };\n  };\n\n  var coyoneda = function coyoneda(k) {\n    return function (fi) {\n      return Coyoneda(Data_Exists.mkExists(new CoyonedaF(k, fi)));\n    };\n  };\n\n  var functorCoyoneda = new Data_Functor.Functor(function (f) {\n    return function (v) {\n      return Data_Exists.runExists(function (v1) {\n        return coyoneda(function ($85) {\n          return f(v1.value0($85));\n        })(v1.value1);\n      })(v);\n    };\n  });\n  var liftCoyoneda = coyoneda(Control_Category.identity(Control_Category.categoryFn));\n  exports[\"unCoyoneda\"] = unCoyoneda;\n  exports[\"liftCoyoneda\"] = liftCoyoneda;\n  exports[\"functorCoyoneda\"] = functorCoyoneda;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.Monoid\"] = $PS[\"Data.Monoid\"] || {};\n  var exports = $PS[\"Data.Monoid\"];\n\n  var Monoid = function Monoid(Semigroup0, mempty) {\n    this.Semigroup0 = Semigroup0;\n    this.mempty = mempty;\n  };\n\n  var mempty = function mempty(dict) {\n    return dict.mempty;\n  };\n\n  exports[\"Monoid\"] = Monoid;\n  exports[\"mempty\"] = mempty;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.Foldable\"] = $PS[\"Data.Foldable\"] || {};\n  var exports = $PS[\"Data.Foldable\"];\n  var Control_Applicative = $PS[\"Control.Applicative\"];\n  var Control_Apply = $PS[\"Control.Apply\"];\n  var Control_Category = $PS[\"Control.Category\"];\n  var Data_Function = $PS[\"Data.Function\"];\n  var Data_Maybe = $PS[\"Data.Maybe\"];\n  var Data_Monoid = $PS[\"Data.Monoid\"];\n  var Data_Unit = $PS[\"Data.Unit\"];\n\n  var Foldable = function Foldable(foldMap, foldl, foldr) {\n    this.foldMap = foldMap;\n    this.foldl = foldl;\n    this.foldr = foldr;\n  };\n\n  var foldr = function foldr(dict) {\n    return dict.foldr;\n  };\n\n  var traverse_ = function traverse_(dictApplicative) {\n    return function (dictFoldable) {\n      return function (f) {\n        return foldr(dictFoldable)(function () {\n          var $197 = Control_Apply.applySecond(dictApplicative.Apply0());\n          return function ($198) {\n            return $197(f($198));\n          };\n        }())(Control_Applicative.pure(dictApplicative)(Data_Unit.unit));\n      };\n    };\n  };\n\n  var for_ = function for_(dictApplicative) {\n    return function (dictFoldable) {\n      return Data_Function.flip(traverse_(dictApplicative)(dictFoldable));\n    };\n  };\n\n  var sequence_ = function sequence_(dictApplicative) {\n    return function (dictFoldable) {\n      return traverse_(dictApplicative)(dictFoldable)(Control_Category.identity(Control_Category.categoryFn));\n    };\n  };\n\n  var foldl = function foldl(dict) {\n    return dict.foldl;\n  };\n\n  var foldableMaybe = new Foldable(function (dictMonoid) {\n    return function (f) {\n      return function (v) {\n        if (v instanceof Data_Maybe.Nothing) {\n          return Data_Monoid.mempty(dictMonoid);\n        }\n\n        ;\n\n        if (v instanceof Data_Maybe.Just) {\n          return f(v.value0);\n        }\n\n        ;\n        throw new Error(\"Failed pattern match at Data.Foldable (line 129, column 1 - line 135, column 27): \" + [f.constructor.name, v.constructor.name]);\n      };\n    };\n  }, function (v) {\n    return function (z) {\n      return function (v1) {\n        if (v1 instanceof Data_Maybe.Nothing) {\n          return z;\n        }\n\n        ;\n\n        if (v1 instanceof Data_Maybe.Just) {\n          return v(z)(v1.value0);\n        }\n\n        ;\n        throw new Error(\"Failed pattern match at Data.Foldable (line 129, column 1 - line 135, column 27): \" + [v.constructor.name, z.constructor.name, v1.constructor.name]);\n      };\n    };\n  }, function (v) {\n    return function (z) {\n      return function (v1) {\n        if (v1 instanceof Data_Maybe.Nothing) {\n          return z;\n        }\n\n        ;\n\n        if (v1 instanceof Data_Maybe.Just) {\n          return v(v1.value0)(z);\n        }\n\n        ;\n        throw new Error(\"Failed pattern match at Data.Foldable (line 129, column 1 - line 135, column 27): \" + [v.constructor.name, z.constructor.name, v1.constructor.name]);\n      };\n    };\n  });\n\n  var foldMap = function foldMap(dict) {\n    return dict.foldMap;\n  };\n\n  exports[\"Foldable\"] = Foldable;\n  exports[\"foldr\"] = foldr;\n  exports[\"foldl\"] = foldl;\n  exports[\"foldMap\"] = foldMap;\n  exports[\"traverse_\"] = traverse_;\n  exports[\"for_\"] = for_;\n  exports[\"sequence_\"] = sequence_;\n  exports[\"foldableMaybe\"] = foldableMaybe;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Control.Monad\"] = $PS[\"Control.Monad\"] || {};\n  var exports = $PS[\"Control.Monad\"];\n  var Control_Applicative = $PS[\"Control.Applicative\"];\n  var Control_Bind = $PS[\"Control.Bind\"];\n\n  var Monad = function Monad(Applicative0, Bind1) {\n    this.Applicative0 = Applicative0;\n    this.Bind1 = Bind1;\n  };\n\n  var unlessM = function unlessM(dictMonad) {\n    return function (mb) {\n      return function (m) {\n        return Control_Bind.bind(dictMonad.Bind1())(mb)(function (b) {\n          return Control_Applicative.unless(dictMonad.Applicative0())(b)(m);\n        });\n      };\n    };\n  };\n\n  var ap = function ap(dictMonad) {\n    return function (f) {\n      return function (a) {\n        return Control_Bind.bind(dictMonad.Bind1())(f)(function (f$prime) {\n          return Control_Bind.bind(dictMonad.Bind1())(a)(function (a$prime) {\n            return Control_Applicative.pure(dictMonad.Applicative0())(f$prime(a$prime));\n          });\n        });\n      };\n    };\n  };\n\n  exports[\"Monad\"] = Monad;\n  exports[\"ap\"] = ap;\n  exports[\"unlessM\"] = unlessM;\n})(PS);\n\n(function (exports) {\n  \"use strict\";\n\n  exports.pureE = function (a) {\n    return function () {\n      return a;\n    };\n  };\n\n  exports.bindE = function (a) {\n    return function (f) {\n      return function () {\n        return f(a())();\n      };\n    };\n  };\n})(PS[\"Effect\"] = PS[\"Effect\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Effect\"] = $PS[\"Effect\"] || {};\n  var exports = $PS[\"Effect\"];\n  var $foreign = $PS[\"Effect\"];\n  var Control_Applicative = $PS[\"Control.Applicative\"];\n  var Control_Apply = $PS[\"Control.Apply\"];\n  var Control_Bind = $PS[\"Control.Bind\"];\n  var Control_Monad = $PS[\"Control.Monad\"];\n  var Data_Functor = $PS[\"Data.Functor\"];\n  var monadEffect = new Control_Monad.Monad(function () {\n    return applicativeEffect;\n  }, function () {\n    return bindEffect;\n  });\n  var bindEffect = new Control_Bind.Bind(function () {\n    return applyEffect;\n  }, $foreign.bindE);\n  var applyEffect = new Control_Apply.Apply(function () {\n    return functorEffect;\n  }, Control_Monad.ap(monadEffect));\n  var applicativeEffect = new Control_Applicative.Applicative(function () {\n    return applyEffect;\n  }, $foreign.pureE);\n  var functorEffect = new Data_Functor.Functor(Control_Applicative.liftA1(applicativeEffect));\n  exports[\"functorEffect\"] = functorEffect;\n  exports[\"applicativeEffect\"] = applicativeEffect;\n  exports[\"bindEffect\"] = bindEffect;\n  exports[\"monadEffect\"] = monadEffect;\n})(PS);\n\n(function (exports) {\n  \"use strict\";\n\n  exports.new = function (val) {\n    return function () {\n      return {\n        value: val\n      };\n    };\n  };\n\n  exports.read = function (ref) {\n    return function () {\n      return ref.value;\n    };\n  };\n\n  exports[\"modify'\"] = function (f) {\n    return function (ref) {\n      return function () {\n        var t = f(ref.value);\n        ref.value = t.state;\n        return t.value;\n      };\n    };\n  };\n\n  exports.write = function (val) {\n    return function (ref) {\n      return function () {\n        ref.value = val;\n        return {};\n      };\n    };\n  };\n})(PS[\"Effect.Ref\"] = PS[\"Effect.Ref\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Effect.Ref\"] = $PS[\"Effect.Ref\"] || {};\n  var exports = $PS[\"Effect.Ref\"];\n  var $foreign = $PS[\"Effect.Ref\"];\n  var Data_Functor = $PS[\"Data.Functor\"];\n  var Effect = $PS[\"Effect\"];\n\n  var modify = function modify(f) {\n    return $foreign[\"modify'\"](function (s) {\n      var s$prime = f(s);\n      return {\n        state: s$prime,\n        value: s$prime\n      };\n    });\n  };\n\n  var modify_ = function modify_(f) {\n    return function (s) {\n      return Data_Functor[\"void\"](Effect.functorEffect)(modify(f)(s));\n    };\n  };\n\n  exports[\"modify_\"] = modify_;\n  exports[\"new\"] = $foreign[\"new\"];\n  exports[\"read\"] = $foreign.read;\n  exports[\"modify'\"] = $foreign[\"modify'\"];\n  exports[\"write\"] = $foreign.write;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Control.Monad.Rec.Class\"] = $PS[\"Control.Monad.Rec.Class\"] || {};\n  var exports = $PS[\"Control.Monad.Rec.Class\"];\n  var Control_Bind = $PS[\"Control.Bind\"];\n  var Data_Functor = $PS[\"Data.Functor\"];\n  var Data_Unit = $PS[\"Data.Unit\"];\n  var Effect = $PS[\"Effect\"];\n  var Effect_Ref = $PS[\"Effect.Ref\"];\n\n  var Loop = function () {\n    function Loop(value0) {\n      this.value0 = value0;\n    }\n\n    ;\n\n    Loop.create = function (value0) {\n      return new Loop(value0);\n    };\n\n    return Loop;\n  }();\n\n  var Done = function () {\n    function Done(value0) {\n      this.value0 = value0;\n    }\n\n    ;\n\n    Done.create = function (value0) {\n      return new Done(value0);\n    };\n\n    return Done;\n  }();\n\n  var MonadRec = function MonadRec(Monad0, tailRecM) {\n    this.Monad0 = Monad0;\n    this.tailRecM = tailRecM;\n  };\n\n  var tailRecM = function tailRecM(dict) {\n    return dict.tailRecM;\n  };\n\n  var monadRecEffect = new MonadRec(function () {\n    return Effect.monadEffect;\n  }, function (f) {\n    return function (a) {\n      var fromDone = function fromDone(v) {\n        if (v instanceof Done) {\n          return v.value0;\n        }\n\n        ;\n        throw new Error(\"Failed pattern match at Control.Monad.Rec.Class (line 113, column 30 - line 113, column 44): \" + [v.constructor.name]);\n      };\n\n      return function __do() {\n        var r = Control_Bind.bindFlipped(Effect.bindEffect)(Effect_Ref[\"new\"])(f(a))();\n\n        (function () {\n          while (!function __do() {\n            var v = Effect_Ref.read(r)();\n\n            if (v instanceof Loop) {\n              var e = f(v.value0)();\n              Effect_Ref.write(e)(r)();\n              return false;\n            }\n\n            ;\n\n            if (v instanceof Done) {\n              return true;\n            }\n\n            ;\n            throw new Error(\"Failed pattern match at Control.Monad.Rec.Class (line 104, column 22 - line 109, column 28): \" + [v.constructor.name]);\n          }()) {}\n\n          ;\n          return {};\n        })();\n\n        return Data_Functor.map(Effect.functorEffect)(fromDone)(Effect_Ref.read(r))();\n      };\n    };\n  });\n\n  var forever = function forever(dictMonadRec) {\n    return function (ma) {\n      return tailRecM(dictMonadRec)(function (u) {\n        return Data_Functor.voidRight(dictMonadRec.Monad0().Bind1().Apply0().Functor0())(new Loop(u))(ma);\n      })(Data_Unit.unit);\n    };\n  };\n\n  exports[\"Loop\"] = Loop;\n  exports[\"Done\"] = Done;\n  exports[\"MonadRec\"] = MonadRec;\n  exports[\"tailRecM\"] = tailRecM;\n  exports[\"forever\"] = forever;\n  exports[\"monadRecEffect\"] = monadRecEffect;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Control.Alt\"] = $PS[\"Control.Alt\"] || {};\n  var exports = $PS[\"Control.Alt\"];\n\n  var Alt = function Alt(Functor0, alt) {\n    this.Functor0 = Functor0;\n    this.alt = alt;\n  };\n\n  exports[\"Alt\"] = Alt;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Control.Plus\"] = $PS[\"Control.Plus\"] || {};\n  var exports = $PS[\"Control.Plus\"];\n\n  var Plus = function Plus(Alt0, empty) {\n    this.Alt0 = Alt0;\n    this.empty = empty;\n  };\n\n  var empty = function empty(dict) {\n    return dict.empty;\n  };\n\n  exports[\"Plus\"] = Plus;\n  exports[\"empty\"] = empty;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.List.Types\"] = $PS[\"Data.List.Types\"] || {};\n  var exports = $PS[\"Data.List.Types\"];\n  var Control_Alt = $PS[\"Control.Alt\"];\n  var Control_Applicative = $PS[\"Control.Applicative\"];\n  var Control_Apply = $PS[\"Control.Apply\"];\n  var Control_Plus = $PS[\"Control.Plus\"];\n  var Data_Foldable = $PS[\"Data.Foldable\"];\n  var Data_Function = $PS[\"Data.Function\"];\n  var Data_Functor = $PS[\"Data.Functor\"];\n  var Data_Monoid = $PS[\"Data.Monoid\"];\n  var Data_Semigroup = $PS[\"Data.Semigroup\"];\n\n  var Nil = function () {\n    function Nil() {}\n\n    ;\n    Nil.value = new Nil();\n    return Nil;\n  }();\n\n  var Cons = function () {\n    function Cons(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n\n    ;\n\n    Cons.create = function (value0) {\n      return function (value1) {\n        return new Cons(value0, value1);\n      };\n    };\n\n    return Cons;\n  }();\n\n  var NonEmptyList = function NonEmptyList(x) {\n    return x;\n  };\n\n  var listMap = function listMap(f) {\n    var chunkedRevMap = function chunkedRevMap($copy_chunksAcc) {\n      return function ($copy_v) {\n        var $tco_var_chunksAcc = $copy_chunksAcc;\n        var $tco_done = false;\n        var $tco_result;\n\n        function $tco_loop(chunksAcc, v) {\n          if (v instanceof Cons && v.value1 instanceof Cons && v.value1.value1 instanceof Cons) {\n            $tco_var_chunksAcc = new Cons(v, chunksAcc);\n            $copy_v = v.value1.value1.value1;\n            return;\n          }\n\n          ;\n\n          var unrolledMap = function unrolledMap(v1) {\n            if (v1 instanceof Cons && v1.value1 instanceof Cons && v1.value1.value1 instanceof Nil) {\n              return new Cons(f(v1.value0), new Cons(f(v1.value1.value0), Nil.value));\n            }\n\n            ;\n\n            if (v1 instanceof Cons && v1.value1 instanceof Nil) {\n              return new Cons(f(v1.value0), Nil.value);\n            }\n\n            ;\n            return Nil.value;\n          };\n\n          var reverseUnrolledMap = function reverseUnrolledMap($copy_v1) {\n            return function ($copy_acc) {\n              var $tco_var_v1 = $copy_v1;\n              var $tco_done = false;\n              var $tco_result;\n\n              function $tco_loop(v1, acc) {\n                if (v1 instanceof Cons && v1.value0 instanceof Cons && v1.value0.value1 instanceof Cons && v1.value0.value1.value1 instanceof Cons) {\n                  $tco_var_v1 = v1.value1;\n                  $copy_acc = new Cons(f(v1.value0.value0), new Cons(f(v1.value0.value1.value0), new Cons(f(v1.value0.value1.value1.value0), acc)));\n                  return;\n                }\n\n                ;\n                $tco_done = true;\n                return acc;\n              }\n\n              ;\n\n              while (!$tco_done) {\n                $tco_result = $tco_loop($tco_var_v1, $copy_acc);\n              }\n\n              ;\n              return $tco_result;\n            };\n          };\n\n          $tco_done = true;\n          return reverseUnrolledMap(chunksAcc)(unrolledMap(v));\n        }\n\n        ;\n\n        while (!$tco_done) {\n          $tco_result = $tco_loop($tco_var_chunksAcc, $copy_v);\n        }\n\n        ;\n        return $tco_result;\n      };\n    };\n\n    return chunkedRevMap(Nil.value);\n  };\n\n  var functorList = new Data_Functor.Functor(listMap);\n  var foldableList = new Data_Foldable.Foldable(function (dictMonoid) {\n    return function (f) {\n      return Data_Foldable.foldl(foldableList)(function (acc) {\n        var $202 = Data_Semigroup.append(dictMonoid.Semigroup0())(acc);\n        return function ($203) {\n          return $202(f($203));\n        };\n      })(Data_Monoid.mempty(dictMonoid));\n    };\n  }, function (f) {\n    var go = function go($copy_b) {\n      return function ($copy_v) {\n        var $tco_var_b = $copy_b;\n        var $tco_done = false;\n        var $tco_result;\n\n        function $tco_loop(b, v) {\n          if (v instanceof Nil) {\n            $tco_done = true;\n            return b;\n          }\n\n          ;\n\n          if (v instanceof Cons) {\n            $tco_var_b = f(b)(v.value0);\n            $copy_v = v.value1;\n            return;\n          }\n\n          ;\n          throw new Error(\"Failed pattern match at Data.List.Types (line 109, column 12 - line 111, column 30): \" + [v.constructor.name]);\n        }\n\n        ;\n\n        while (!$tco_done) {\n          $tco_result = $tco_loop($tco_var_b, $copy_v);\n        }\n\n        ;\n        return $tco_result;\n      };\n    };\n\n    return go;\n  }, function (f) {\n    return function (b) {\n      var rev = Data_Foldable.foldl(foldableList)(Data_Function.flip(Cons.create))(Nil.value);\n      var $204 = Data_Foldable.foldl(foldableList)(Data_Function.flip(f))(b);\n      return function ($205) {\n        return $204(rev($205));\n      };\n    };\n  });\n  var semigroupList = new Data_Semigroup.Semigroup(function (xs) {\n    return function (ys) {\n      return Data_Foldable.foldr(foldableList)(Cons.create)(ys)(xs);\n    };\n  });\n  var monoidList = new Data_Monoid.Monoid(function () {\n    return semigroupList;\n  }, Nil.value);\n  var applyList = new Control_Apply.Apply(function () {\n    return functorList;\n  }, function (v) {\n    return function (v1) {\n      if (v instanceof Nil) {\n        return Nil.value;\n      }\n\n      ;\n\n      if (v instanceof Cons) {\n        return Data_Semigroup.append(semigroupList)(Data_Functor.map(functorList)(v.value0)(v1))(Control_Apply.apply(applyList)(v.value1)(v1));\n      }\n\n      ;\n      throw new Error(\"Failed pattern match at Data.List.Types (line 155, column 1 - line 157, column 48): \" + [v.constructor.name, v1.constructor.name]);\n    };\n  });\n  var applicativeList = new Control_Applicative.Applicative(function () {\n    return applyList;\n  }, function (a) {\n    return new Cons(a, Nil.value);\n  });\n  var altList = new Control_Alt.Alt(function () {\n    return functorList;\n  }, Data_Semigroup.append(semigroupList));\n  var plusList = new Control_Plus.Plus(function () {\n    return altList;\n  }, Nil.value);\n  exports[\"Nil\"] = Nil;\n  exports[\"Cons\"] = Cons;\n  exports[\"NonEmptyList\"] = NonEmptyList;\n  exports[\"semigroupList\"] = semigroupList;\n  exports[\"monoidList\"] = monoidList;\n  exports[\"foldableList\"] = foldableList;\n  exports[\"applicativeList\"] = applicativeList;\n  exports[\"plusList\"] = plusList;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.List\"] = $PS[\"Data.List\"] || {};\n  var exports = $PS[\"Data.List\"];\n  var Data_List_Types = $PS[\"Data.List.Types\"];\n\n  var reverse = function () {\n    var go = function go($copy_acc) {\n      return function ($copy_v) {\n        var $tco_var_acc = $copy_acc;\n        var $tco_done = false;\n        var $tco_result;\n\n        function $tco_loop(acc, v) {\n          if (v instanceof Data_List_Types.Nil) {\n            $tco_done = true;\n            return acc;\n          }\n\n          ;\n\n          if (v instanceof Data_List_Types.Cons) {\n            $tco_var_acc = new Data_List_Types.Cons(v.value0, acc);\n            $copy_v = v.value1;\n            return;\n          }\n\n          ;\n          throw new Error(\"Failed pattern match at Data.List (line 368, column 3 - line 368, column 19): \" + [acc.constructor.name, v.constructor.name]);\n        }\n\n        ;\n\n        while (!$tco_done) {\n          $tco_result = $tco_loop($tco_var_acc, $copy_v);\n        }\n\n        ;\n        return $tco_result;\n      };\n    };\n\n    return go(Data_List_Types.Nil.value);\n  }();\n\n  var $$null = function $$null(v) {\n    if (v instanceof Data_List_Types.Nil) {\n      return true;\n    }\n\n    ;\n    return false;\n  };\n\n  exports[\"null\"] = $$null;\n  exports[\"reverse\"] = reverse;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.Tuple\"] = $PS[\"Data.Tuple\"] || {};\n  var exports = $PS[\"Data.Tuple\"];\n  var Data_Functor = $PS[\"Data.Functor\"];\n\n  var Tuple = function () {\n    function Tuple(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n\n    ;\n\n    Tuple.create = function (value0) {\n      return function (value1) {\n        return new Tuple(value0, value1);\n      };\n    };\n\n    return Tuple;\n  }();\n\n  var snd = function snd(v) {\n    return v.value1;\n  };\n\n  var functorTuple = new Data_Functor.Functor(function (f) {\n    return function (m) {\n      return new Tuple(m.value0, f(m.value1));\n    };\n  });\n\n  var fst = function fst(v) {\n    return v.value0;\n  };\n\n  exports[\"Tuple\"] = Tuple;\n  exports[\"fst\"] = fst;\n  exports[\"snd\"] = snd;\n  exports[\"functorTuple\"] = functorTuple;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.CatQueue\"] = $PS[\"Data.CatQueue\"] || {};\n  var exports = $PS[\"Data.CatQueue\"];\n  var Data_List = $PS[\"Data.List\"];\n  var Data_List_Types = $PS[\"Data.List.Types\"];\n  var Data_Maybe = $PS[\"Data.Maybe\"];\n  var Data_Tuple = $PS[\"Data.Tuple\"];\n\n  var CatQueue = function () {\n    function CatQueue(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n\n    ;\n\n    CatQueue.create = function (value0) {\n      return function (value1) {\n        return new CatQueue(value0, value1);\n      };\n    };\n\n    return CatQueue;\n  }();\n\n  var uncons = function uncons($copy_v) {\n    var $tco_done = false;\n    var $tco_result;\n\n    function $tco_loop(v) {\n      if (v.value0 instanceof Data_List_Types.Nil && v.value1 instanceof Data_List_Types.Nil) {\n        $tco_done = true;\n        return Data_Maybe.Nothing.value;\n      }\n\n      ;\n\n      if (v.value0 instanceof Data_List_Types.Nil) {\n        $copy_v = new CatQueue(Data_List.reverse(v.value1), Data_List_Types.Nil.value);\n        return;\n      }\n\n      ;\n\n      if (v.value0 instanceof Data_List_Types.Cons) {\n        $tco_done = true;\n        return new Data_Maybe.Just(new Data_Tuple.Tuple(v.value0.value0, new CatQueue(v.value0.value1, v.value1)));\n      }\n\n      ;\n      throw new Error(\"Failed pattern match at Data.CatQueue (line 83, column 1 - line 83, column 63): \" + [v.constructor.name]);\n    }\n\n    ;\n\n    while (!$tco_done) {\n      $tco_result = $tco_loop($copy_v);\n    }\n\n    ;\n    return $tco_result;\n  };\n\n  var snoc = function snoc(v) {\n    return function (a) {\n      return new CatQueue(v.value0, new Data_List_Types.Cons(a, v.value1));\n    };\n  };\n\n  var $$null = function $$null(v) {\n    if (v.value0 instanceof Data_List_Types.Nil && v.value1 instanceof Data_List_Types.Nil) {\n      return true;\n    }\n\n    ;\n    return false;\n  };\n\n  var empty = new CatQueue(Data_List_Types.Nil.value, Data_List_Types.Nil.value);\n  exports[\"empty\"] = empty;\n  exports[\"null\"] = $$null;\n  exports[\"snoc\"] = snoc;\n  exports[\"uncons\"] = uncons;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.CatList\"] = $PS[\"Data.CatList\"] || {};\n  var exports = $PS[\"Data.CatList\"];\n  var Data_CatQueue = $PS[\"Data.CatQueue\"];\n  var Data_List_Types = $PS[\"Data.List.Types\"];\n  var Data_Maybe = $PS[\"Data.Maybe\"];\n  var Data_Semigroup = $PS[\"Data.Semigroup\"];\n  var Data_Tuple = $PS[\"Data.Tuple\"];\n\n  var CatNil = function () {\n    function CatNil() {}\n\n    ;\n    CatNil.value = new CatNil();\n    return CatNil;\n  }();\n\n  var CatCons = function () {\n    function CatCons(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n\n    ;\n\n    CatCons.create = function (value0) {\n      return function (value1) {\n        return new CatCons(value0, value1);\n      };\n    };\n\n    return CatCons;\n  }();\n\n  var link = function link(v) {\n    return function (v1) {\n      if (v instanceof CatNil) {\n        return v1;\n      }\n\n      ;\n\n      if (v1 instanceof CatNil) {\n        return v;\n      }\n\n      ;\n\n      if (v instanceof CatCons) {\n        return new CatCons(v.value0, Data_CatQueue.snoc(v.value1)(v1));\n      }\n\n      ;\n      throw new Error(\"Failed pattern match at Data.CatList (line 109, column 1 - line 109, column 54): \" + [v.constructor.name, v1.constructor.name]);\n    };\n  };\n\n  var foldr = function foldr(k) {\n    return function (b) {\n      return function (q) {\n        var foldl = function foldl($copy_v) {\n          return function ($copy_c) {\n            return function ($copy_v1) {\n              var $tco_var_v = $copy_v;\n              var $tco_var_c = $copy_c;\n              var $tco_done = false;\n              var $tco_result;\n\n              function $tco_loop(v, c, v1) {\n                if (v1 instanceof Data_List_Types.Nil) {\n                  $tco_done = true;\n                  return c;\n                }\n\n                ;\n\n                if (v1 instanceof Data_List_Types.Cons) {\n                  $tco_var_v = v;\n                  $tco_var_c = v(c)(v1.value0);\n                  $copy_v1 = v1.value1;\n                  return;\n                }\n\n                ;\n                throw new Error(\"Failed pattern match at Data.CatList (line 125, column 3 - line 125, column 59): \" + [v.constructor.name, c.constructor.name, v1.constructor.name]);\n              }\n\n              ;\n\n              while (!$tco_done) {\n                $tco_result = $tco_loop($tco_var_v, $tco_var_c, $copy_v1);\n              }\n\n              ;\n              return $tco_result;\n            };\n          };\n        };\n\n        var go = function go($copy_xs) {\n          return function ($copy_ys) {\n            var $tco_var_xs = $copy_xs;\n            var $tco_done = false;\n            var $tco_result;\n\n            function $tco_loop(xs, ys) {\n              var v = Data_CatQueue.uncons(xs);\n\n              if (v instanceof Data_Maybe.Nothing) {\n                $tco_done = true;\n                return foldl(function (x) {\n                  return function (i) {\n                    return i(x);\n                  };\n                })(b)(ys);\n              }\n\n              ;\n\n              if (v instanceof Data_Maybe.Just) {\n                $tco_var_xs = v.value0.value1;\n                $copy_ys = new Data_List_Types.Cons(k(v.value0.value0), ys);\n                return;\n              }\n\n              ;\n              throw new Error(\"Failed pattern match at Data.CatList (line 121, column 14 - line 123, column 67): \" + [v.constructor.name]);\n            }\n\n            ;\n\n            while (!$tco_done) {\n              $tco_result = $tco_loop($tco_var_xs, $copy_ys);\n            }\n\n            ;\n            return $tco_result;\n          };\n        };\n\n        return go(q)(Data_List_Types.Nil.value);\n      };\n    };\n  };\n\n  var uncons = function uncons(v) {\n    if (v instanceof CatNil) {\n      return Data_Maybe.Nothing.value;\n    }\n\n    ;\n\n    if (v instanceof CatCons) {\n      return new Data_Maybe.Just(new Data_Tuple.Tuple(v.value0, function () {\n        var $44 = Data_CatQueue[\"null\"](v.value1);\n\n        if ($44) {\n          return CatNil.value;\n        }\n\n        ;\n        return foldr(link)(CatNil.value)(v.value1);\n      }()));\n    }\n\n    ;\n    throw new Error(\"Failed pattern match at Data.CatList (line 100, column 1 - line 100, column 61): \" + [v.constructor.name]);\n  };\n\n  var empty = CatNil.value;\n  var append = link;\n  var semigroupCatList = new Data_Semigroup.Semigroup(append);\n\n  var snoc = function snoc(cat) {\n    return function (a) {\n      return append(cat)(new CatCons(a, Data_CatQueue.empty));\n    };\n  };\n\n  exports[\"empty\"] = empty;\n  exports[\"snoc\"] = snoc;\n  exports[\"uncons\"] = uncons;\n  exports[\"semigroupCatList\"] = semigroupCatList;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Control.Monad.Free\"] = $PS[\"Control.Monad.Free\"] || {};\n  var exports = $PS[\"Control.Monad.Free\"];\n  var Control_Applicative = $PS[\"Control.Applicative\"];\n  var Control_Apply = $PS[\"Control.Apply\"];\n  var Control_Bind = $PS[\"Control.Bind\"];\n  var Control_Monad = $PS[\"Control.Monad\"];\n  var Control_Monad_Rec_Class = $PS[\"Control.Monad.Rec.Class\"];\n  var Data_CatList = $PS[\"Data.CatList\"];\n  var Data_Functor = $PS[\"Data.Functor\"];\n  var Data_Maybe = $PS[\"Data.Maybe\"];\n  var Data_Semigroup = $PS[\"Data.Semigroup\"];\n\n  var Free = function () {\n    function Free(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n\n    ;\n\n    Free.create = function (value0) {\n      return function (value1) {\n        return new Free(value0, value1);\n      };\n    };\n\n    return Free;\n  }();\n\n  var Return = function () {\n    function Return(value0) {\n      this.value0 = value0;\n    }\n\n    ;\n\n    Return.create = function (value0) {\n      return new Return(value0);\n    };\n\n    return Return;\n  }();\n\n  var Bind = function () {\n    function Bind(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n\n    ;\n\n    Bind.create = function (value0) {\n      return function (value1) {\n        return new Bind(value0, value1);\n      };\n    };\n\n    return Bind;\n  }();\n\n  var toView = function toView($copy_v) {\n    var $tco_done = false;\n    var $tco_result;\n\n    function $tco_loop(v) {\n      var runExpF = function runExpF(v2) {\n        return v2;\n      };\n\n      var concatF = function concatF(v2) {\n        return function (r) {\n          return new Free(v2.value0, Data_Semigroup.append(Data_CatList.semigroupCatList)(v2.value1)(r));\n        };\n      };\n\n      if (v.value0 instanceof Return) {\n        var v2 = Data_CatList.uncons(v.value1);\n\n        if (v2 instanceof Data_Maybe.Nothing) {\n          $tco_done = true;\n          return new Return(v.value0.value0);\n        }\n\n        ;\n\n        if (v2 instanceof Data_Maybe.Just) {\n          $copy_v = concatF(runExpF(v2.value0.value0)(v.value0.value0))(v2.value0.value1);\n          return;\n        }\n\n        ;\n        throw new Error(\"Failed pattern match at Control.Monad.Free (line 227, column 7 - line 231, column 64): \" + [v2.constructor.name]);\n      }\n\n      ;\n\n      if (v.value0 instanceof Bind) {\n        $tco_done = true;\n        return new Bind(v.value0.value0, function (a) {\n          return concatF(v.value0.value1(a))(v.value1);\n        });\n      }\n\n      ;\n      throw new Error(\"Failed pattern match at Control.Monad.Free (line 225, column 3 - line 233, column 56): \" + [v.value0.constructor.name]);\n    }\n\n    ;\n\n    while (!$tco_done) {\n      $tco_result = $tco_loop($copy_v);\n    }\n\n    ;\n    return $tco_result;\n  };\n\n  var fromView = function fromView(f) {\n    return new Free(f, Data_CatList.empty);\n  };\n\n  var freeMonad = new Control_Monad.Monad(function () {\n    return freeApplicative;\n  }, function () {\n    return freeBind;\n  });\n  var freeFunctor = new Data_Functor.Functor(function (k) {\n    return function (f) {\n      return Control_Bind.bindFlipped(freeBind)(function () {\n        var $120 = Control_Applicative.pure(freeApplicative);\n        return function ($121) {\n          return $120(k($121));\n        };\n      }())(f);\n    };\n  });\n  var freeBind = new Control_Bind.Bind(function () {\n    return freeApply;\n  }, function (v) {\n    return function (k) {\n      return new Free(v.value0, Data_CatList.snoc(v.value1)(k));\n    };\n  });\n  var freeApply = new Control_Apply.Apply(function () {\n    return freeFunctor;\n  }, Control_Monad.ap(freeMonad));\n  var freeApplicative = new Control_Applicative.Applicative(function () {\n    return freeApply;\n  }, function ($122) {\n    return fromView(Return.create($122));\n  });\n\n  var foldFree = function foldFree(dictMonadRec) {\n    return function (k) {\n      var go = function go(f) {\n        var v = toView(f);\n\n        if (v instanceof Return) {\n          return Data_Functor.map(dictMonadRec.Monad0().Bind1().Apply0().Functor0())(Control_Monad_Rec_Class.Done.create)(Control_Applicative.pure(dictMonadRec.Monad0().Applicative0())(v.value0));\n        }\n\n        ;\n\n        if (v instanceof Bind) {\n          return Data_Functor.map(dictMonadRec.Monad0().Bind1().Apply0().Functor0())(function ($136) {\n            return Control_Monad_Rec_Class.Loop.create(v.value1($136));\n          })(k(v.value0));\n        }\n\n        ;\n        throw new Error(\"Failed pattern match at Control.Monad.Free (line 158, column 10 - line 160, column 37): \" + [v.constructor.name]);\n      };\n\n      return Control_Monad_Rec_Class.tailRecM(dictMonadRec)(go);\n    };\n  };\n\n  exports[\"foldFree\"] = foldFree;\n  exports[\"freeFunctor\"] = freeFunctor;\n  exports[\"freeApplicative\"] = freeApplicative;\n})(PS);\n\n(function (exports) {\n  \"use strict\";\n\n  var unsafeCompareImpl = function unsafeCompareImpl(lt) {\n    return function (eq) {\n      return function (gt) {\n        return function (x) {\n          return function (y) {\n            return x < y ? lt : x === y ? eq : gt;\n          };\n        };\n      };\n    };\n  };\n\n  exports.ordIntImpl = unsafeCompareImpl;\n  exports.ordStringImpl = unsafeCompareImpl;\n})(PS[\"Data.Ord\"] = PS[\"Data.Ord\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.Ordering\"] = $PS[\"Data.Ordering\"] || {};\n  var exports = $PS[\"Data.Ordering\"];\n\n  var LT = function () {\n    function LT() {}\n\n    ;\n    LT.value = new LT();\n    return LT;\n  }();\n\n  var GT = function () {\n    function GT() {}\n\n    ;\n    GT.value = new GT();\n    return GT;\n  }();\n\n  var EQ = function () {\n    function EQ() {}\n\n    ;\n    EQ.value = new EQ();\n    return EQ;\n  }();\n\n  exports[\"LT\"] = LT;\n  exports[\"GT\"] = GT;\n  exports[\"EQ\"] = EQ;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.Ord\"] = $PS[\"Data.Ord\"] || {};\n  var exports = $PS[\"Data.Ord\"];\n  var $foreign = $PS[\"Data.Ord\"];\n  var Data_Eq = $PS[\"Data.Eq\"];\n  var Data_Ordering = $PS[\"Data.Ordering\"];\n\n  var Ord = function Ord(Eq0, compare) {\n    this.Eq0 = Eq0;\n    this.compare = compare;\n  };\n\n  var ordString = new Ord(function () {\n    return Data_Eq.eqString;\n  }, $foreign.ordStringImpl(Data_Ordering.LT.value)(Data_Ordering.EQ.value)(Data_Ordering.GT.value));\n  var ordInt = new Ord(function () {\n    return Data_Eq.eqInt;\n  }, $foreign.ordIntImpl(Data_Ordering.LT.value)(Data_Ordering.EQ.value)(Data_Ordering.GT.value));\n\n  var compare = function compare(dict) {\n    return dict.compare;\n  };\n\n  exports[\"compare\"] = compare;\n  exports[\"ordInt\"] = ordInt;\n  exports[\"ordString\"] = ordString;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Halogen.Query.HalogenM\"] = $PS[\"Halogen.Query.HalogenM\"] || {};\n  var exports = $PS[\"Halogen.Query.HalogenM\"];\n  var Control_Monad_Free = $PS[\"Control.Monad.Free\"];\n  var Data_Ord = $PS[\"Data.Ord\"];\n\n  var SubscriptionId = function SubscriptionId(x) {\n    return x;\n  };\n\n  var ForkId = function ForkId(x) {\n    return x;\n  };\n\n  var State = function () {\n    function State(value0) {\n      this.value0 = value0;\n    }\n\n    ;\n\n    State.create = function (value0) {\n      return new State(value0);\n    };\n\n    return State;\n  }();\n\n  var Subscribe = function () {\n    function Subscribe(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n\n    ;\n\n    Subscribe.create = function (value0) {\n      return function (value1) {\n        return new Subscribe(value0, value1);\n      };\n    };\n\n    return Subscribe;\n  }();\n\n  var Unsubscribe = function () {\n    function Unsubscribe(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n\n    ;\n\n    Unsubscribe.create = function (value0) {\n      return function (value1) {\n        return new Unsubscribe(value0, value1);\n      };\n    };\n\n    return Unsubscribe;\n  }();\n\n  var Lift = function () {\n    function Lift(value0) {\n      this.value0 = value0;\n    }\n\n    ;\n\n    Lift.create = function (value0) {\n      return new Lift(value0);\n    };\n\n    return Lift;\n  }();\n\n  var ChildQuery = function () {\n    function ChildQuery(value0) {\n      this.value0 = value0;\n    }\n\n    ;\n\n    ChildQuery.create = function (value0) {\n      return new ChildQuery(value0);\n    };\n\n    return ChildQuery;\n  }();\n\n  var Raise = function () {\n    function Raise(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n\n    ;\n\n    Raise.create = function (value0) {\n      return function (value1) {\n        return new Raise(value0, value1);\n      };\n    };\n\n    return Raise;\n  }();\n\n  var Par = function () {\n    function Par(value0) {\n      this.value0 = value0;\n    }\n\n    ;\n\n    Par.create = function (value0) {\n      return new Par(value0);\n    };\n\n    return Par;\n  }();\n\n  var Fork = function () {\n    function Fork(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n\n    ;\n\n    Fork.create = function (value0) {\n      return function (value1) {\n        return new Fork(value0, value1);\n      };\n    };\n\n    return Fork;\n  }();\n\n  var Kill = function () {\n    function Kill(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n\n    ;\n\n    Kill.create = function (value0) {\n      return function (value1) {\n        return new Kill(value0, value1);\n      };\n    };\n\n    return Kill;\n  }();\n\n  var GetRef = function () {\n    function GetRef(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n\n    ;\n\n    GetRef.create = function (value0) {\n      return function (value1) {\n        return new GetRef(value0, value1);\n      };\n    };\n\n    return GetRef;\n  }();\n\n  var ordSubscriptionId = Data_Ord.ordInt;\n  var ordForkId = Data_Ord.ordInt;\n  var functorHalogenM = Control_Monad_Free.freeFunctor;\n  var applicativeHalogenM = Control_Monad_Free.freeApplicative;\n  exports[\"State\"] = State;\n  exports[\"Subscribe\"] = Subscribe;\n  exports[\"Unsubscribe\"] = Unsubscribe;\n  exports[\"Lift\"] = Lift;\n  exports[\"ChildQuery\"] = ChildQuery;\n  exports[\"Raise\"] = Raise;\n  exports[\"Par\"] = Par;\n  exports[\"Fork\"] = Fork;\n  exports[\"Kill\"] = Kill;\n  exports[\"GetRef\"] = GetRef;\n  exports[\"SubscriptionId\"] = SubscriptionId;\n  exports[\"ForkId\"] = ForkId;\n  exports[\"functorHalogenM\"] = functorHalogenM;\n  exports[\"applicativeHalogenM\"] = applicativeHalogenM;\n  exports[\"ordSubscriptionId\"] = ordSubscriptionId;\n  exports[\"ordForkId\"] = ordForkId;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Halogen.Query.HalogenQ\"] = $PS[\"Halogen.Query.HalogenQ\"] || {};\n  var exports = $PS[\"Halogen.Query.HalogenQ\"];\n\n  var Initialize = function () {\n    function Initialize(value0) {\n      this.value0 = value0;\n    }\n\n    ;\n\n    Initialize.create = function (value0) {\n      return new Initialize(value0);\n    };\n\n    return Initialize;\n  }();\n\n  var Finalize = function () {\n    function Finalize(value0) {\n      this.value0 = value0;\n    }\n\n    ;\n\n    Finalize.create = function (value0) {\n      return new Finalize(value0);\n    };\n\n    return Finalize;\n  }();\n\n  var Receive = function () {\n    function Receive(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n\n    ;\n\n    Receive.create = function (value0) {\n      return function (value1) {\n        return new Receive(value0, value1);\n      };\n    };\n\n    return Receive;\n  }();\n\n  var Action = function () {\n    function Action(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n\n    ;\n\n    Action.create = function (value0) {\n      return function (value1) {\n        return new Action(value0, value1);\n      };\n    };\n\n    return Action;\n  }();\n\n  var Query = function () {\n    function Query(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n\n    ;\n\n    Query.create = function (value0) {\n      return function (value1) {\n        return new Query(value0, value1);\n      };\n    };\n\n    return Query;\n  }();\n\n  exports[\"Initialize\"] = Initialize;\n  exports[\"Finalize\"] = Finalize;\n  exports[\"Receive\"] = Receive;\n  exports[\"Action\"] = Action;\n  exports[\"Query\"] = Query;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Halogen.Component\"] = $PS[\"Halogen.Component\"] || {};\n  var exports = $PS[\"Halogen.Component\"];\n  var Control_Applicative = $PS[\"Control.Applicative\"];\n  var Data_Coyoneda = $PS[\"Data.Coyoneda\"];\n  var Data_Foldable = $PS[\"Data.Foldable\"];\n  var Data_Function = $PS[\"Data.Function\"];\n  var Data_Functor = $PS[\"Data.Functor\"];\n  var Data_Maybe = $PS[\"Data.Maybe\"];\n  var Data_Unit = $PS[\"Data.Unit\"];\n  var Halogen_Query_HalogenM = $PS[\"Halogen.Query.HalogenM\"];\n  var Halogen_Query_HalogenQ = $PS[\"Halogen.Query.HalogenQ\"];\n  var Unsafe_Coerce = $PS[\"Unsafe.Coerce\"];\n\n  var ComponentSlot = function () {\n    function ComponentSlot(value0) {\n      this.value0 = value0;\n    }\n\n    ;\n\n    ComponentSlot.create = function (value0) {\n      return new ComponentSlot(value0);\n    };\n\n    return ComponentSlot;\n  }();\n\n  var ThunkSlot = function () {\n    function ThunkSlot(value0) {\n      this.value0 = value0;\n    }\n\n    ;\n\n    ThunkSlot.create = function (value0) {\n      return new ThunkSlot(value0);\n    };\n\n    return ThunkSlot;\n  }();\n\n  var unComponentSlot = Unsafe_Coerce.unsafeCoerce;\n  var unComponent = Unsafe_Coerce.unsafeCoerce;\n\n  var mkEval = function mkEval(args) {\n    return function (v) {\n      if (v instanceof Halogen_Query_HalogenQ.Initialize) {\n        return Data_Functor.voidLeft(Halogen_Query_HalogenM.functorHalogenM)(Data_Foldable.traverse_(Halogen_Query_HalogenM.applicativeHalogenM)(Data_Foldable.foldableMaybe)(args.handleAction)(args.initialize))(v.value0);\n      }\n\n      ;\n\n      if (v instanceof Halogen_Query_HalogenQ.Finalize) {\n        return Data_Functor.voidLeft(Halogen_Query_HalogenM.functorHalogenM)(Data_Foldable.traverse_(Halogen_Query_HalogenM.applicativeHalogenM)(Data_Foldable.foldableMaybe)(args.handleAction)(args.finalize))(v.value0);\n      }\n\n      ;\n\n      if (v instanceof Halogen_Query_HalogenQ.Receive) {\n        return Data_Functor.voidLeft(Halogen_Query_HalogenM.functorHalogenM)(Data_Foldable.traverse_(Halogen_Query_HalogenM.applicativeHalogenM)(Data_Foldable.foldableMaybe)(args.handleAction)(args.receive(v.value0)))(v.value1);\n      }\n\n      ;\n\n      if (v instanceof Halogen_Query_HalogenQ.Action) {\n        return Data_Functor.voidLeft(Halogen_Query_HalogenM.functorHalogenM)(args.handleAction(v.value0))(v.value1);\n      }\n\n      ;\n\n      if (v instanceof Halogen_Query_HalogenQ.Query) {\n        return Data_Coyoneda.unCoyoneda(function (g) {\n          var $28 = Data_Functor.map(Halogen_Query_HalogenM.functorHalogenM)(Data_Maybe.maybe(v.value1(Data_Unit.unit))(g));\n          return function ($29) {\n            return $28(args.handleQuery($29));\n          };\n        })(v.value0);\n      }\n\n      ;\n      throw new Error(\"Failed pattern match at Halogen.Component (line 187, column 15 - line 197, column 70): \" + [v.constructor.name]);\n    };\n  };\n\n  var mkComponent = Unsafe_Coerce.unsafeCoerce;\n  var defaultEval = {\n    handleAction: Data_Function[\"const\"](Control_Applicative.pure(Halogen_Query_HalogenM.applicativeHalogenM)(Data_Unit.unit)),\n    handleQuery: Data_Function[\"const\"](Control_Applicative.pure(Halogen_Query_HalogenM.applicativeHalogenM)(Data_Maybe.Nothing.value)),\n    receive: Data_Function[\"const\"](Data_Maybe.Nothing.value),\n    initialize: Data_Maybe.Nothing.value,\n    finalize: Data_Maybe.Nothing.value\n  };\n  exports[\"mkComponent\"] = mkComponent;\n  exports[\"unComponent\"] = unComponent;\n  exports[\"mkEval\"] = mkEval;\n  exports[\"defaultEval\"] = defaultEval;\n  exports[\"ComponentSlot\"] = ComponentSlot;\n  exports[\"ThunkSlot\"] = ThunkSlot;\n  exports[\"unComponentSlot\"] = unComponentSlot;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.Newtype\"] = $PS[\"Data.Newtype\"] || {};\n  var exports = $PS[\"Data.Newtype\"];\n\n  var Newtype = function Newtype(unwrap, wrap) {\n    this.unwrap = unwrap;\n    this.wrap = wrap;\n  };\n\n  var unwrap = function unwrap(dict) {\n    return dict.unwrap;\n  };\n\n  var un = function un(dictNewtype) {\n    return function (v) {\n      return unwrap(dictNewtype);\n    };\n  };\n\n  exports[\"unwrap\"] = unwrap;\n  exports[\"Newtype\"] = Newtype;\n  exports[\"un\"] = un;\n})(PS);\n\n(function (exports) {\n  \"use strict\";\n\n  exports[\"null\"] = null;\n\n  exports.nullable = function (a, r, f) {\n    return a == null ? r : f(a);\n  };\n\n  exports.notNull = function (x) {\n    return x;\n  };\n})(PS[\"Data.Nullable\"] = PS[\"Data.Nullable\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.Nullable\"] = $PS[\"Data.Nullable\"] || {};\n  var exports = $PS[\"Data.Nullable\"];\n  var $foreign = $PS[\"Data.Nullable\"];\n  var Data_Maybe = $PS[\"Data.Maybe\"];\n  var toNullable = Data_Maybe.maybe($foreign[\"null\"])($foreign.notNull);\n\n  var toMaybe = function toMaybe(n) {\n    return $foreign.nullable(n, Data_Maybe.Nothing.value, Data_Maybe.Just.create);\n  };\n\n  exports[\"toMaybe\"] = toMaybe;\n  exports[\"toNullable\"] = toNullable;\n  exports[\"null\"] = $foreign[\"null\"];\n})(PS);\n\n(function (exports) {\n  \"use strict\";\n\n  exports.typeOf = function (value) {\n    return _typeof(value);\n  };\n})(PS[\"Foreign\"] = PS[\"Foreign\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Foreign\"] = $PS[\"Foreign\"] || {};\n  var exports = $PS[\"Foreign\"];\n  var $foreign = $PS[\"Foreign\"];\n  exports[\"typeOf\"] = $foreign.typeOf;\n})(PS);\n\n(function (exports) {\n  \"use strict\";\n\n  exports._lookup = function (no, yes, k, m) {\n    return k in m ? yes(m[k]) : no;\n  };\n\n  function toArrayWithKey(f) {\n    return function (m) {\n      var r = [];\n\n      for (var k in m) {\n        if (hasOwnProperty.call(m, k)) {\n          r.push(f(k)(m[k]));\n        }\n      }\n\n      return r;\n    };\n  }\n})(PS[\"Foreign.Object\"] = PS[\"Foreign.Object\"] || {});\n\n(function (exports) {\n  \"use strict\";\n\n  exports.runFn4 = function (fn) {\n    return function (a) {\n      return function (b) {\n        return function (c) {\n          return function (d) {\n            return fn(a, b, c, d);\n          };\n        };\n      };\n    };\n  };\n})(PS[\"Data.Function.Uncurried\"] = PS[\"Data.Function.Uncurried\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.Function.Uncurried\"] = $PS[\"Data.Function.Uncurried\"] || {};\n  var exports = $PS[\"Data.Function.Uncurried\"];\n  var $foreign = $PS[\"Data.Function.Uncurried\"];\n  exports[\"runFn4\"] = $foreign.runFn4;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Foreign.Object\"] = $PS[\"Foreign.Object\"] || {};\n  var exports = $PS[\"Foreign.Object\"];\n  var $foreign = $PS[\"Foreign.Object\"];\n  var Data_Function_Uncurried = $PS[\"Data.Function.Uncurried\"];\n  var Data_Maybe = $PS[\"Data.Maybe\"];\n  var lookup = Data_Function_Uncurried.runFn4($foreign[\"_lookup\"])(Data_Maybe.Nothing.value)(Data_Maybe.Just.create);\n  exports[\"lookup\"] = lookup;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Halogen.VDom.Machine\"] = $PS[\"Halogen.VDom.Machine\"] || {};\n  var exports = $PS[\"Halogen.VDom.Machine\"];\n  var Unsafe_Coerce = $PS[\"Unsafe.Coerce\"];\n\n  var Step = function () {\n    function Step(value0, value1, value2, value3) {\n      this.value0 = value0;\n      this.value1 = value1;\n      this.value2 = value2;\n      this.value3 = value3;\n    }\n\n    ;\n\n    Step.create = function (value0) {\n      return function (value1) {\n        return function (value2) {\n          return function (value3) {\n            return new Step(value0, value1, value2, value3);\n          };\n        };\n      };\n    };\n\n    return Step;\n  }();\n\n  var unStep = Unsafe_Coerce.unsafeCoerce;\n\n  var step = function step(v, a) {\n    return v.value2(v.value1, a);\n  };\n\n  var mkStep = Unsafe_Coerce.unsafeCoerce;\n\n  var halt = function halt(v) {\n    return v.value3(v.value1);\n  };\n\n  var extract = unStep(function (v) {\n    return v.value0;\n  });\n  exports[\"Step\"] = Step;\n  exports[\"mkStep\"] = mkStep;\n  exports[\"unStep\"] = unStep;\n  exports[\"extract\"] = extract;\n  exports[\"step\"] = step;\n  exports[\"halt\"] = halt;\n})(PS);\n\n(function (exports) {\n  \"use strict\";\n\n  exports.unsafeGetAny = function (key, obj) {\n    return obj[key];\n  };\n\n  exports.unsafeHasAny = function (key, obj) {\n    return obj.hasOwnProperty(key);\n  };\n\n  exports.unsafeSetAny = function (key, val, obj) {\n    obj[key] = val;\n  };\n\n  exports.forE = function (a, f) {\n    var b = [];\n\n    for (var i = 0; i < a.length; i++) {\n      b.push(f(i, a[i]));\n    }\n\n    return b;\n  };\n\n  exports.forEachE = function (a, f) {\n    for (var i = 0; i < a.length; i++) {\n      f(a[i]);\n    }\n  };\n\n  exports.forInE = function (o, f) {\n    var ks = Object.keys(o);\n\n    for (var i = 0; i < ks.length; i++) {\n      var k = ks[i];\n      f(k, o[k]);\n    }\n  };\n\n  exports.diffWithIxE = function (a1, a2, f1, f2, f3) {\n    var a3 = [];\n    var l1 = a1.length;\n    var l2 = a2.length;\n    var i = 0;\n\n    while (1) {\n      if (i < l1) {\n        if (i < l2) {\n          a3.push(f1(i, a1[i], a2[i]));\n        } else {\n          f2(i, a1[i]);\n        }\n      } else if (i < l2) {\n        a3.push(f3(i, a2[i]));\n      } else {\n        break;\n      }\n\n      i++;\n    }\n\n    return a3;\n  };\n\n  exports.strMapWithIxE = function (as, fk, f) {\n    var o = {};\n\n    for (var i = 0; i < as.length; i++) {\n      var a = as[i];\n      var k = fk(a);\n      o[k] = f(k, i, a);\n    }\n\n    return o;\n  };\n\n  exports.diffWithKeyAndIxE = function (o1, as, fk, f1, f2, f3) {\n    var o2 = {};\n\n    for (var i = 0; i < as.length; i++) {\n      var a = as[i];\n      var k = fk(a);\n\n      if (o1.hasOwnProperty(k)) {\n        o2[k] = f1(k, i, o1[k], a);\n      } else {\n        o2[k] = f3(k, i, a);\n      }\n    }\n\n    for (var k in o1) {\n      if (k in o2) {\n        continue;\n      }\n\n      f2(k, o1[k]);\n    }\n\n    return o2;\n  };\n\n  exports.refEq = function (a, b) {\n    return a === b;\n  };\n\n  exports.createTextNode = function (s, doc) {\n    return doc.createTextNode(s);\n  };\n\n  exports.setTextContent = function (s, n) {\n    n.textContent = s;\n  };\n\n  exports.createElement = function (ns, name, doc) {\n    if (ns != null) {\n      return doc.createElementNS(ns, name);\n    } else {\n      return doc.createElement(name);\n    }\n  };\n\n  exports.insertChildIx = function (i, a, b) {\n    var n = b.childNodes.item(i) || null;\n\n    if (n !== a) {\n      b.insertBefore(a, n);\n    }\n  };\n\n  exports.removeChild = function (a, b) {\n    if (b && a.parentNode === b) {\n      b.removeChild(a);\n    }\n  };\n\n  exports.parentNode = function (a) {\n    return a.parentNode;\n  };\n\n  exports.setAttribute = function (ns, attr, val, el) {\n    if (ns != null) {\n      el.setAttributeNS(ns, attr, val);\n    } else {\n      el.setAttribute(attr, val);\n    }\n  };\n\n  exports.removeAttribute = function (ns, attr, el) {\n    if (ns != null) {\n      el.removeAttributeNS(ns, attr);\n    } else {\n      el.removeAttribute(attr);\n    }\n  };\n\n  exports.hasAttribute = function (ns, attr, el) {\n    if (ns != null) {\n      return el.hasAttributeNS(ns, attr);\n    } else {\n      return el.hasAttribute(attr);\n    }\n  };\n\n  exports.addEventListener = function (ev, listener, el) {\n    el.addEventListener(ev, listener, false);\n  };\n\n  exports.removeEventListener = function (ev, listener, el) {\n    el.removeEventListener(ev, listener, false);\n  };\n\n  exports.jsUndefined = void 0;\n})(PS[\"Halogen.VDom.Util\"] = PS[\"Halogen.VDom.Util\"] || {});\n\n(function (exports) {\n  \"use strict\";\n\n  exports[\"new\"] = function () {\n    return {};\n  };\n})(PS[\"Foreign.Object.ST\"] = PS[\"Foreign.Object.ST\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Foreign.Object.ST\"] = $PS[\"Foreign.Object.ST\"] || {};\n  var exports = $PS[\"Foreign.Object.ST\"];\n  var $foreign = $PS[\"Foreign.Object.ST\"];\n  exports[\"new\"] = $foreign[\"new\"];\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Halogen.VDom.Util\"] = $PS[\"Halogen.VDom.Util\"] || {};\n  var exports = $PS[\"Halogen.VDom.Util\"];\n  var $foreign = $PS[\"Halogen.VDom.Util\"];\n  var Foreign_Object_ST = $PS[\"Foreign.Object.ST\"];\n  var Unsafe_Coerce = $PS[\"Unsafe.Coerce\"];\n  var unsafeLookup = $foreign.unsafeGetAny;\n  var unsafeFreeze = Unsafe_Coerce.unsafeCoerce;\n  var pokeMutMap = $foreign.unsafeSetAny;\n  var newMutMap = Foreign_Object_ST[\"new\"];\n  exports[\"newMutMap\"] = newMutMap;\n  exports[\"pokeMutMap\"] = pokeMutMap;\n  exports[\"unsafeFreeze\"] = unsafeFreeze;\n  exports[\"unsafeLookup\"] = unsafeLookup;\n  exports[\"unsafeGetAny\"] = $foreign.unsafeGetAny;\n  exports[\"unsafeHasAny\"] = $foreign.unsafeHasAny;\n  exports[\"unsafeSetAny\"] = $foreign.unsafeSetAny;\n  exports[\"forE\"] = $foreign.forE;\n  exports[\"forEachE\"] = $foreign.forEachE;\n  exports[\"forInE\"] = $foreign.forInE;\n  exports[\"diffWithIxE\"] = $foreign.diffWithIxE;\n  exports[\"diffWithKeyAndIxE\"] = $foreign.diffWithKeyAndIxE;\n  exports[\"strMapWithIxE\"] = $foreign.strMapWithIxE;\n  exports[\"refEq\"] = $foreign.refEq;\n  exports[\"createTextNode\"] = $foreign.createTextNode;\n  exports[\"setTextContent\"] = $foreign.setTextContent;\n  exports[\"createElement\"] = $foreign.createElement;\n  exports[\"insertChildIx\"] = $foreign.insertChildIx;\n  exports[\"removeChild\"] = $foreign.removeChild;\n  exports[\"parentNode\"] = $foreign.parentNode;\n  exports[\"setAttribute\"] = $foreign.setAttribute;\n  exports[\"removeAttribute\"] = $foreign.removeAttribute;\n  exports[\"hasAttribute\"] = $foreign.hasAttribute;\n  exports[\"addEventListener\"] = $foreign.addEventListener;\n  exports[\"removeEventListener\"] = $foreign.removeEventListener;\n  exports[\"jsUndefined\"] = $foreign.jsUndefined;\n})(PS);\n\n(function (exports) {\n  \"use strict\";\n\n  exports.eventListener = function (fn) {\n    return function () {\n      return function (event) {\n        return fn(event)();\n      };\n    };\n  };\n\n  exports.addEventListener = function (type) {\n    return function (listener) {\n      return function (useCapture) {\n        return function (target) {\n          return function () {\n            return target.addEventListener(type, listener, useCapture);\n          };\n        };\n      };\n    };\n  };\n\n  exports.removeEventListener = function (type) {\n    return function (listener) {\n      return function (useCapture) {\n        return function (target) {\n          return function () {\n            return target.removeEventListener(type, listener, useCapture);\n          };\n        };\n      };\n    };\n  };\n})(PS[\"Web.Event.EventTarget\"] = PS[\"Web.Event.EventTarget\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Web.Event.EventTarget\"] = $PS[\"Web.Event.EventTarget\"] || {};\n  var exports = $PS[\"Web.Event.EventTarget\"];\n  var $foreign = $PS[\"Web.Event.EventTarget\"];\n  exports[\"eventListener\"] = $foreign.eventListener;\n  exports[\"addEventListener\"] = $foreign.addEventListener;\n  exports[\"removeEventListener\"] = $foreign.removeEventListener;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Halogen.VDom.DOM.Prop\"] = $PS[\"Halogen.VDom.DOM.Prop\"] || {};\n  var exports = $PS[\"Halogen.VDom.DOM.Prop\"];\n  var Data_Maybe = $PS[\"Data.Maybe\"];\n  var Data_Nullable = $PS[\"Data.Nullable\"];\n  var Data_Tuple = $PS[\"Data.Tuple\"];\n  var Data_Unit = $PS[\"Data.Unit\"];\n  var Effect_Ref = $PS[\"Effect.Ref\"];\n  var Foreign = $PS[\"Foreign\"];\n  var Foreign_Object = $PS[\"Foreign.Object\"];\n  var Halogen_VDom_Machine = $PS[\"Halogen.VDom.Machine\"];\n  var Halogen_VDom_Util = $PS[\"Halogen.VDom.Util\"];\n  var Unsafe_Coerce = $PS[\"Unsafe.Coerce\"];\n  var Web_Event_EventTarget = $PS[\"Web.Event.EventTarget\"];\n\n  var Created = function () {\n    function Created(value0) {\n      this.value0 = value0;\n    }\n\n    ;\n\n    Created.create = function (value0) {\n      return new Created(value0);\n    };\n\n    return Created;\n  }();\n\n  var Removed = function () {\n    function Removed(value0) {\n      this.value0 = value0;\n    }\n\n    ;\n\n    Removed.create = function (value0) {\n      return new Removed(value0);\n    };\n\n    return Removed;\n  }();\n\n  var Attribute = function () {\n    function Attribute(value0, value1, value2) {\n      this.value0 = value0;\n      this.value1 = value1;\n      this.value2 = value2;\n    }\n\n    ;\n\n    Attribute.create = function (value0) {\n      return function (value1) {\n        return function (value2) {\n          return new Attribute(value0, value1, value2);\n        };\n      };\n    };\n\n    return Attribute;\n  }();\n\n  var Property = function () {\n    function Property(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n\n    ;\n\n    Property.create = function (value0) {\n      return function (value1) {\n        return new Property(value0, value1);\n      };\n    };\n\n    return Property;\n  }();\n\n  var Handler = function () {\n    function Handler(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n\n    ;\n\n    Handler.create = function (value0) {\n      return function (value1) {\n        return new Handler(value0, value1);\n      };\n    };\n\n    return Handler;\n  }();\n\n  var Ref = function () {\n    function Ref(value0) {\n      this.value0 = value0;\n    }\n\n    ;\n\n    Ref.create = function (value0) {\n      return new Ref(value0);\n    };\n\n    return Ref;\n  }();\n\n  var unsafeGetProperty = Halogen_VDom_Util.unsafeGetAny;\n  var setProperty = Halogen_VDom_Util.unsafeSetAny;\n\n  var removeProperty = function removeProperty(key, el) {\n    var v = Halogen_VDom_Util.hasAttribute(Data_Nullable[\"null\"], key, el);\n\n    if (v) {\n      return Halogen_VDom_Util.removeAttribute(Data_Nullable[\"null\"], key, el);\n    }\n\n    ;\n    var v1 = Foreign.typeOf(Halogen_VDom_Util.unsafeGetAny(key, el));\n\n    if (v1 === \"string\") {\n      return Halogen_VDom_Util.unsafeSetAny(key, \"\", el);\n    }\n\n    ;\n\n    if (key === \"rowSpan\") {\n      return Halogen_VDom_Util.unsafeSetAny(key, 1, el);\n    }\n\n    ;\n\n    if (key === \"colSpan\") {\n      return Halogen_VDom_Util.unsafeSetAny(key, 1, el);\n    }\n\n    ;\n    return Halogen_VDom_Util.unsafeSetAny(key, Halogen_VDom_Util.jsUndefined, el);\n  };\n\n  var propToStrKey = function propToStrKey(v) {\n    if (v instanceof Attribute && v.value0 instanceof Data_Maybe.Just) {\n      return \"attr/\" + (v.value0.value0 + (\":\" + v.value1));\n    }\n\n    ;\n\n    if (v instanceof Attribute) {\n      return \"attr/:\" + v.value1;\n    }\n\n    ;\n\n    if (v instanceof Property) {\n      return \"prop/\" + v.value0;\n    }\n\n    ;\n\n    if (v instanceof Handler) {\n      return \"handler/\" + v.value0;\n    }\n\n    ;\n\n    if (v instanceof Ref) {\n      return \"ref\";\n    }\n\n    ;\n    throw new Error(\"Failed pattern match at Halogen.VDom.DOM.Prop (line 182, column 16 - line 187, column 16): \" + [v.constructor.name]);\n  };\n\n  var propFromString = Unsafe_Coerce.unsafeCoerce;\n\n  var buildProp = function buildProp(emit) {\n    return function (el) {\n      var removeProp = function removeProp(prevEvents) {\n        return function (v, v1) {\n          if (v1 instanceof Attribute) {\n            return Halogen_VDom_Util.removeAttribute(Data_Nullable.toNullable(v1.value0), v1.value1, el);\n          }\n\n          ;\n\n          if (v1 instanceof Property) {\n            return removeProperty(v1.value0, el);\n          }\n\n          ;\n\n          if (v1 instanceof Handler) {\n            var handler = Halogen_VDom_Util.unsafeLookup(v1.value0, prevEvents);\n            return Halogen_VDom_Util.removeEventListener(v1.value0, Data_Tuple.fst(handler), el);\n          }\n\n          ;\n\n          if (v1 instanceof Ref) {\n            return Data_Unit.unit;\n          }\n\n          ;\n          throw new Error(\"Failed pattern match at Halogen.VDom.DOM.Prop (line 169, column 5 - line 179, column 18): \" + [v1.constructor.name]);\n        };\n      };\n\n      var mbEmit = function mbEmit(v) {\n        if (v instanceof Data_Maybe.Just) {\n          return emit(v.value0)();\n        }\n\n        ;\n        return Data_Unit.unit;\n      };\n\n      var haltProp = function haltProp(state) {\n        var v = Foreign_Object.lookup(\"ref\")(state.props);\n\n        if (v instanceof Data_Maybe.Just && v.value0 instanceof Ref) {\n          return mbEmit(v.value0.value0(new Removed(el)));\n        }\n\n        ;\n        return Data_Unit.unit;\n      };\n\n      var diffProp = function diffProp(prevEvents, events) {\n        return function (v, v1, v11, v2) {\n          if (v11 instanceof Attribute && v2 instanceof Attribute) {\n            var $56 = v11.value2 === v2.value2;\n\n            if ($56) {\n              return v2;\n            }\n\n            ;\n            Halogen_VDom_Util.setAttribute(Data_Nullable.toNullable(v2.value0), v2.value1, v2.value2, el);\n            return v2;\n          }\n\n          ;\n\n          if (v11 instanceof Property && v2 instanceof Property) {\n            var v4 = Halogen_VDom_Util.refEq(v11.value1, v2.value1);\n\n            if (v4) {\n              return v2;\n            }\n\n            ;\n\n            if (v2.value0 === \"value\") {\n              var elVal = unsafeGetProperty(\"value\", el);\n              var $65 = Halogen_VDom_Util.refEq(elVal, v2.value1);\n\n              if ($65) {\n                return v2;\n              }\n\n              ;\n              setProperty(v2.value0, v2.value1, el);\n              return v2;\n            }\n\n            ;\n            setProperty(v2.value0, v2.value1, el);\n            return v2;\n          }\n\n          ;\n\n          if (v11 instanceof Handler && v2 instanceof Handler) {\n            var handler = Halogen_VDom_Util.unsafeLookup(v2.value0, prevEvents);\n            Effect_Ref.write(v2.value1)(Data_Tuple.snd(handler))();\n            Halogen_VDom_Util.pokeMutMap(v2.value0, handler, events);\n            return v2;\n          }\n\n          ;\n          return v2;\n        };\n      };\n\n      var applyProp = function applyProp(events) {\n        return function (v, v1, v2) {\n          if (v2 instanceof Attribute) {\n            Halogen_VDom_Util.setAttribute(Data_Nullable.toNullable(v2.value0), v2.value1, v2.value2, el);\n            return v2;\n          }\n\n          ;\n\n          if (v2 instanceof Property) {\n            setProperty(v2.value0, v2.value1, el);\n            return v2;\n          }\n\n          ;\n\n          if (v2 instanceof Handler) {\n            var v3 = Halogen_VDom_Util.unsafeGetAny(v2.value0, events);\n\n            if (Halogen_VDom_Util.unsafeHasAny(v2.value0, events)) {\n              Effect_Ref.write(v2.value1)(Data_Tuple.snd(v3))();\n              return v2;\n            }\n\n            ;\n            var ref = Effect_Ref[\"new\"](v2.value1)();\n            var listener = Web_Event_EventTarget.eventListener(function (ev) {\n              return function __do() {\n                var f$prime = Effect_Ref.read(ref)();\n                return mbEmit(f$prime(ev));\n              };\n            })();\n            Halogen_VDom_Util.pokeMutMap(v2.value0, new Data_Tuple.Tuple(listener, ref), events);\n            Halogen_VDom_Util.addEventListener(v2.value0, listener, el);\n            return v2;\n          }\n\n          ;\n\n          if (v2 instanceof Ref) {\n            mbEmit(v2.value0(new Created(el)));\n            return v2;\n          }\n\n          ;\n          throw new Error(\"Failed pattern match at Halogen.VDom.DOM.Prop (line 113, column 5 - line 135, column 15): \" + [v2.constructor.name]);\n        };\n      };\n\n      var patchProp = function patchProp(state, ps2) {\n        var events = Halogen_VDom_Util.newMutMap();\n        var onThis = removeProp(state.events);\n        var onThese = diffProp(state.events, events);\n        var onThat = applyProp(events);\n        var props = Halogen_VDom_Util.diffWithKeyAndIxE(state.props, ps2, propToStrKey, onThese, onThis, onThat);\n        var nextState = {\n          events: Halogen_VDom_Util.unsafeFreeze(events),\n          props: props\n        };\n        return Halogen_VDom_Machine.mkStep(new Halogen_VDom_Machine.Step(Data_Unit.unit, nextState, patchProp, haltProp));\n      };\n\n      var renderProp = function renderProp(ps1) {\n        var events = Halogen_VDom_Util.newMutMap();\n        var ps1$prime = Halogen_VDom_Util.strMapWithIxE(ps1, propToStrKey, applyProp(events));\n        var state = {\n          events: Halogen_VDom_Util.unsafeFreeze(events),\n          props: ps1$prime\n        };\n        return Halogen_VDom_Machine.mkStep(new Halogen_VDom_Machine.Step(Data_Unit.unit, state, patchProp, haltProp));\n      };\n\n      return renderProp;\n    };\n  };\n\n  exports[\"Property\"] = Property;\n  exports[\"propFromString\"] = propFromString;\n  exports[\"buildProp\"] = buildProp;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.Bifunctor\"] = $PS[\"Data.Bifunctor\"] || {};\n  var exports = $PS[\"Data.Bifunctor\"];\n  var Control_Category = $PS[\"Control.Category\"];\n\n  var Bifunctor = function Bifunctor(bimap) {\n    this.bimap = bimap;\n  };\n\n  var bimap = function bimap(dict) {\n    return dict.bimap;\n  };\n\n  var rmap = function rmap(dictBifunctor) {\n    return bimap(dictBifunctor)(Control_Category.identity(Control_Category.categoryFn));\n  };\n\n  exports[\"bimap\"] = bimap;\n  exports[\"Bifunctor\"] = Bifunctor;\n  exports[\"rmap\"] = rmap;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Halogen.VDom.Types\"] = $PS[\"Halogen.VDom.Types\"] || {};\n  var exports = $PS[\"Halogen.VDom.Types\"];\n  var Data_Bifunctor = $PS[\"Data.Bifunctor\"];\n  var Data_Functor = $PS[\"Data.Functor\"];\n  var Data_Tuple = $PS[\"Data.Tuple\"];\n  var Unsafe_Coerce = $PS[\"Unsafe.Coerce\"];\n\n  var Text = function () {\n    function Text(value0) {\n      this.value0 = value0;\n    }\n\n    ;\n\n    Text.create = function (value0) {\n      return new Text(value0);\n    };\n\n    return Text;\n  }();\n\n  var Elem = function () {\n    function Elem(value0, value1, value2, value3) {\n      this.value0 = value0;\n      this.value1 = value1;\n      this.value2 = value2;\n      this.value3 = value3;\n    }\n\n    ;\n\n    Elem.create = function (value0) {\n      return function (value1) {\n        return function (value2) {\n          return function (value3) {\n            return new Elem(value0, value1, value2, value3);\n          };\n        };\n      };\n    };\n\n    return Elem;\n  }();\n\n  var Keyed = function () {\n    function Keyed(value0, value1, value2, value3) {\n      this.value0 = value0;\n      this.value1 = value1;\n      this.value2 = value2;\n      this.value3 = value3;\n    }\n\n    ;\n\n    Keyed.create = function (value0) {\n      return function (value1) {\n        return function (value2) {\n          return function (value3) {\n            return new Keyed(value0, value1, value2, value3);\n          };\n        };\n      };\n    };\n\n    return Keyed;\n  }();\n\n  var Widget = function () {\n    function Widget(value0) {\n      this.value0 = value0;\n    }\n\n    ;\n\n    Widget.create = function (value0) {\n      return new Widget(value0);\n    };\n\n    return Widget;\n  }();\n\n  var Grafted = function () {\n    function Grafted(value0) {\n      this.value0 = value0;\n    }\n\n    ;\n\n    Grafted.create = function (value0) {\n      return new Grafted(value0);\n    };\n\n    return Grafted;\n  }();\n\n  var Graft = function () {\n    function Graft(value0, value1, value2) {\n      this.value0 = value0;\n      this.value1 = value1;\n      this.value2 = value2;\n    }\n\n    ;\n\n    Graft.create = function (value0) {\n      return function (value1) {\n        return function (value2) {\n          return new Graft(value0, value1, value2);\n        };\n      };\n    };\n\n    return Graft;\n  }();\n\n  var unGraft = function unGraft(f) {\n    return function ($58) {\n      return f($58);\n    };\n  };\n\n  var graft = Unsafe_Coerce.unsafeCoerce;\n  var bifunctorGraft = new Data_Bifunctor.Bifunctor(function (f) {\n    return function (g) {\n      return unGraft(function (v) {\n        return graft(new Graft(function ($60) {\n          return f(v.value0($60));\n        }, function ($61) {\n          return g(v.value1($61));\n        }, v.value2));\n      });\n    };\n  });\n  var runGraft = unGraft(function (v) {\n    var go = function go(v2) {\n      if (v2 instanceof Text) {\n        return new Text(v2.value0);\n      }\n\n      ;\n\n      if (v2 instanceof Elem) {\n        return new Elem(v2.value0, v2.value1, v.value0(v2.value2), Data_Functor.map(Data_Functor.functorArray)(go)(v2.value3));\n      }\n\n      ;\n\n      if (v2 instanceof Keyed) {\n        return new Keyed(v2.value0, v2.value1, v.value0(v2.value2), Data_Functor.map(Data_Functor.functorArray)(Data_Functor.map(Data_Tuple.functorTuple)(go))(v2.value3));\n      }\n\n      ;\n\n      if (v2 instanceof Widget) {\n        return new Widget(v.value1(v2.value0));\n      }\n\n      ;\n\n      if (v2 instanceof Grafted) {\n        return new Grafted(Data_Bifunctor.bimap(bifunctorGraft)(v.value0)(v.value1)(v2.value0));\n      }\n\n      ;\n      throw new Error(\"Failed pattern match at Halogen.VDom.Types (line 86, column 7 - line 86, column 27): \" + [v2.constructor.name]);\n    };\n\n    return go(v.value2);\n  });\n  exports[\"Text\"] = Text;\n  exports[\"Elem\"] = Elem;\n  exports[\"Keyed\"] = Keyed;\n  exports[\"Widget\"] = Widget;\n  exports[\"Grafted\"] = Grafted;\n  exports[\"runGraft\"] = runGraft;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Halogen.HTML.Core\"] = $PS[\"Halogen.HTML.Core\"] || {};\n  var exports = $PS[\"Halogen.HTML.Core\"];\n  var Data_Newtype = $PS[\"Data.Newtype\"];\n  var Halogen_VDom_DOM_Prop = $PS[\"Halogen.VDom.DOM.Prop\"];\n  var Halogen_VDom_Types = $PS[\"Halogen.VDom.Types\"];\n\n  var HTML = function HTML(x) {\n    return x;\n  };\n\n  var ClassName = function ClassName(x) {\n    return x;\n  };\n\n  var IsProp = function IsProp(toPropValue) {\n    this.toPropValue = toPropValue;\n  };\n\n  var toPropValue = function toPropValue(dict) {\n    return dict.toPropValue;\n  };\n\n  var text = function text($31) {\n    return HTML(Halogen_VDom_Types.Text.create($31));\n  };\n\n  var prop = function prop(dictIsProp) {\n    return function (v) {\n      var $33 = Halogen_VDom_DOM_Prop.Property.create(v);\n      var $34 = toPropValue(dictIsProp);\n      return function ($35) {\n        return $33($34($35));\n      };\n    };\n  };\n\n  var newtypeHTML = new Data_Newtype.Newtype(function (n) {\n    return n;\n  }, HTML);\n  var newtypeClassName = new Data_Newtype.Newtype(function (n) {\n    return n;\n  }, ClassName);\n  var isPropString = new IsProp(Halogen_VDom_DOM_Prop.propFromString);\n\n  var element = function element(ns) {\n    return function (name) {\n      return function (props) {\n        return function (children) {\n          return new Halogen_VDom_Types.Elem(ns, name, props, children);\n        };\n      };\n    };\n  };\n\n  exports[\"text\"] = text;\n  exports[\"element\"] = element;\n  exports[\"prop\"] = prop;\n  exports[\"newtypeHTML\"] = newtypeHTML;\n  exports[\"isPropString\"] = isPropString;\n  exports[\"newtypeClassName\"] = newtypeClassName;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Halogen.HTML.Elements\"] = $PS[\"Halogen.HTML.Elements\"] || {};\n  var exports = $PS[\"Halogen.HTML.Elements\"];\n  var Data_Maybe = $PS[\"Data.Maybe\"];\n  var Halogen_HTML_Core = $PS[\"Halogen.HTML.Core\"];\n  var element = Halogen_HTML_Core.element(Data_Maybe.Nothing.value);\n  var h1 = element(\"h1\");\n  var h1_ = h1([]);\n\n  var img = function img(props) {\n    return element(\"img\")(props)([]);\n  };\n\n  var li = element(\"li\");\n  var p = element(\"p\");\n  var p_ = p([]);\n  var ul = element(\"ul\");\n  var div = element(\"div\");\n  exports[\"div\"] = div;\n  exports[\"h1_\"] = h1_;\n  exports[\"img\"] = img;\n  exports[\"li\"] = li;\n  exports[\"p\"] = p;\n  exports[\"p_\"] = p_;\n  exports[\"ul\"] = ul;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Halogen.HTML.Properties\"] = $PS[\"Halogen.HTML.Properties\"] || {};\n  var exports = $PS[\"Halogen.HTML.Properties\"];\n  var Data_Newtype = $PS[\"Data.Newtype\"];\n  var Halogen_HTML_Core = $PS[\"Halogen.HTML.Core\"];\n\n  var prop = function prop(dictIsProp) {\n    return Halogen_HTML_Core.prop(dictIsProp);\n  };\n\n  var src = prop(Halogen_HTML_Core.isPropString)(\"src\");\n\n  var class_ = function () {\n    var $18 = prop(Halogen_HTML_Core.isPropString)(\"className\");\n    var $19 = Data_Newtype.unwrap(Halogen_HTML_Core.newtypeClassName);\n    return function ($20) {\n      return $18($19($20));\n    };\n  }();\n\n  exports[\"class_\"] = class_;\n  exports[\"src\"] = src;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.Boolean\"] = $PS[\"Data.Boolean\"] || {};\n  var exports = $PS[\"Data.Boolean\"];\n  var otherwise = true;\n  exports[\"otherwise\"] = otherwise;\n})(PS);\n\n(function (exports) {\n  \"use strict\"; // module Partial.Unsafe\n\n  exports.unsafePartial = function (f) {\n    return f();\n  };\n})(PS[\"Partial.Unsafe\"] = PS[\"Partial.Unsafe\"] || {});\n\n(function (exports) {\n  \"use strict\"; // module Partial\n\n  exports.crashWith = function () {\n    return function (msg) {\n      throw new Error(msg);\n    };\n  };\n})(PS[\"Partial\"] = PS[\"Partial\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Partial\"] = $PS[\"Partial\"] || {};\n  var exports = $PS[\"Partial\"];\n  var $foreign = $PS[\"Partial\"];\n  exports[\"crashWith\"] = $foreign.crashWith;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Partial.Unsafe\"] = $PS[\"Partial.Unsafe\"] || {};\n  var exports = $PS[\"Partial.Unsafe\"];\n  var $foreign = $PS[\"Partial.Unsafe\"];\n  var Partial = $PS[\"Partial\"];\n\n  var unsafeCrashWith = function unsafeCrashWith(msg) {\n    return $foreign.unsafePartial(function (dictPartial) {\n      return Partial.crashWith()(msg);\n    });\n  };\n\n  exports[\"unsafeCrashWith\"] = unsafeCrashWith;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Pathy.Name\"] = $PS[\"Pathy.Name\"] || {};\n  var exports = $PS[\"Pathy.Name\"];\n  var Data_Newtype = $PS[\"Data.Newtype\"];\n  var Data_String_NonEmpty_Internal = $PS[\"Data.String.NonEmpty.Internal\"];\n\n  var Name = function Name(x) {\n    return x;\n  };\n\n  var newtypeName = new Data_Newtype.Newtype(function (n) {\n    return n;\n  }, Name);\n  var eqName = Data_String_NonEmpty_Internal.eqNonEmptyString;\n  exports[\"newtypeName\"] = newtypeName;\n  exports[\"eqName\"] = eqName;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Pathy.Phantom\"] = $PS[\"Pathy.Phantom\"] || {};\n  var exports = $PS[\"Pathy.Phantom\"];\n  var Control_Category = $PS[\"Control.Category\"];\n  var Data_Function = $PS[\"Data.Function\"];\n\n  var IsRelOrAbs = function IsRelOrAbs(onRelOrAbs) {\n    this.onRelOrAbs = onRelOrAbs;\n  };\n\n  var IsDirOrFile = function IsDirOrFile(onDirOrFile) {\n    this.onDirOrFile = onDirOrFile;\n  };\n\n  var relIsRelOrAbs = new IsRelOrAbs(function (f) {\n    return function (v) {\n      return f(Control_Category.identity(Control_Category.categoryFn));\n    };\n  });\n\n  var onRelOrAbs = function onRelOrAbs(dict) {\n    return dict.onRelOrAbs;\n  };\n\n  var onDirOrFile = function onDirOrFile(dict) {\n    return dict.onDirOrFile;\n  };\n\n  var isDirOrFileFile = new IsDirOrFile(function (v) {\n    return function (f) {\n      return f(Control_Category.identity(Control_Category.categoryFn));\n    };\n  });\n  var isDirOrFileDir = new IsDirOrFile(function (f) {\n    return function (v) {\n      return f(Control_Category.identity(Control_Category.categoryFn));\n    };\n  });\n\n  var foldRelOrAbs = function foldRelOrAbs(dictIsRelOrAbs) {\n    return function (f) {\n      return function (g) {\n        return onRelOrAbs(dictIsRelOrAbs)(Data_Function[\"const\"](f))(Data_Function[\"const\"](g));\n      };\n    };\n  };\n\n  var foldDirOrFile = function foldDirOrFile(dictIsDirOrFile) {\n    return function (f) {\n      return function (g) {\n        return onDirOrFile(dictIsDirOrFile)(Data_Function[\"const\"](f))(Data_Function[\"const\"](g));\n      };\n    };\n  };\n\n  var absIsRelOrAbs = new IsRelOrAbs(function (v) {\n    return function (f) {\n      return f(Control_Category.identity(Control_Category.categoryFn));\n    };\n  });\n  exports[\"onRelOrAbs\"] = onRelOrAbs;\n  exports[\"foldRelOrAbs\"] = foldRelOrAbs;\n  exports[\"foldDirOrFile\"] = foldDirOrFile;\n  exports[\"relIsRelOrAbs\"] = relIsRelOrAbs;\n  exports[\"absIsRelOrAbs\"] = absIsRelOrAbs;\n  exports[\"isDirOrFileDir\"] = isDirOrFileDir;\n  exports[\"isDirOrFileFile\"] = isDirOrFileFile;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Pathy.Path\"] = $PS[\"Pathy.Path\"] || {};\n  var exports = $PS[\"Pathy.Path\"];\n  var Data_Boolean = $PS[\"Data.Boolean\"];\n  var Data_Eq = $PS[\"Data.Eq\"];\n  var Data_Function = $PS[\"Data.Function\"];\n  var Data_Maybe = $PS[\"Data.Maybe\"];\n  var Data_Tuple = $PS[\"Data.Tuple\"];\n  var Partial_Unsafe = $PS[\"Partial.Unsafe\"];\n  var Pathy_Name = $PS[\"Pathy.Name\"];\n  var Pathy_Phantom = $PS[\"Pathy.Phantom\"];\n\n  var Init = function () {\n    function Init() {}\n\n    ;\n    Init.value = new Init();\n    return Init;\n  }();\n\n  var ParentOf = function () {\n    function ParentOf(value0) {\n      this.value0 = value0;\n    }\n\n    ;\n\n    ParentOf.create = function (value0) {\n      return new ParentOf(value0);\n    };\n\n    return ParentOf;\n  }();\n\n  var In = function () {\n    function In(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n\n    ;\n\n    In.create = function (value0) {\n      return function (value1) {\n        return new In(value0, value1);\n      };\n    };\n\n    return In;\n  }();\n\n  var rootDir = Init.value;\n\n  var foldPath = function foldPath(r) {\n    return function (f) {\n      return function (g) {\n        return function (v) {\n          if (v instanceof Init) {\n            return r;\n          }\n\n          ;\n\n          if (v instanceof ParentOf) {\n            return f(v.value0);\n          }\n\n          ;\n\n          if (v instanceof In) {\n            return g(v.value0)(v.value1);\n          }\n\n          ;\n          throw new Error(\"Failed pattern match at Pathy.Path (line 199, column 18 - line 202, column 18): \" + [v.constructor.name]);\n        };\n      };\n    };\n  };\n\n  var name = function name(dictIsRelOrAbs) {\n    return function (dictIsDirOrFile) {\n      return foldPath(Data_Maybe.Nothing.value)(Data_Function[\"const\"](Data_Maybe.Nothing.value))(Data_Function[\"const\"](Data_Maybe.Just.create));\n    };\n  };\n\n  var peel = foldPath(Data_Maybe.Nothing.value)(Data_Function[\"const\"](Data_Maybe.Nothing.value))(function (p) {\n    return function (n) {\n      return new Data_Maybe.Just(new Data_Tuple.Tuple(p, n));\n    };\n  });\n\n  var parentOf = function parentOf(dictIsRelOrAbs) {\n    return Pathy_Phantom.onRelOrAbs(dictIsRelOrAbs)(function (coe) {\n      return function (p) {\n        return Data_Maybe.maybe(new ParentOf(p))(function ($108) {\n          return coe(Data_Tuple.fst($108));\n        })(peel(p));\n      };\n    })(function (coe) {\n      var $109 = Data_Maybe.maybe(Init.value)(Data_Tuple.fst);\n      return function ($110) {\n        return coe($109(peel($110)));\n      };\n    });\n  };\n\n  var eqPath = new Data_Eq.Eq(function (x) {\n    return function (y) {\n      if (x instanceof Init && y instanceof Init) {\n        return true;\n      }\n\n      ;\n\n      if (x instanceof ParentOf && y instanceof ParentOf) {\n        return Data_Eq.eq(eqPath)(x.value0)(y.value0);\n      }\n\n      ;\n\n      if (x instanceof In && y instanceof In) {\n        return Data_Eq.eq(eqPath)(x.value0)(y.value0) && Data_Eq.eq(Pathy_Name.eqName)(x.value1)(y.value1);\n      }\n\n      ;\n      return false;\n    };\n  });\n\n  var relativeTo = function relativeTo(p) {\n    var step = function step(acc) {\n      return function (v) {\n        return function (v1) {\n          if (Data_Eq.eq(eqPath)(v)(v1)) {\n            return acc;\n          }\n\n          ;\n\n          if (v instanceof Init && v1 instanceof In) {\n            return step(new ParentOf(acc))(Init.value)(v1.value0);\n          }\n\n          ;\n\n          if (v instanceof In && v1 instanceof Init) {\n            return new In(step(acc)(v.value0)(Init.value), v.value1);\n          }\n\n          ;\n\n          if (v instanceof In) {\n            if (Data_Eq.eq(eqPath)(v.value0)(v1)) {\n              return new In(acc, v.value1);\n            }\n\n            ;\n\n            if (Data_Boolean.otherwise) {\n              return new In(step(acc)(v.value0)(v1), v.value1);\n            }\n\n            ;\n          }\n\n          ;\n          return Partial_Unsafe.unsafeCrashWith(\"`ParentOf` in Pathy.relativeTo (this should be impossible)\");\n        };\n      };\n    };\n\n    var $112 = step(Init.value)(p);\n    return function ($113) {\n      return $112($113);\n    };\n  };\n\n  var currentDir = Init.value;\n  var in$prime = In.create(currentDir);\n  var dir$prime = in$prime;\n  var file$prime = in$prime;\n\n  var appendPath = function appendPath(dictIsRelOrAbs) {\n    return function (v) {\n      return function (v1) {\n        if (v instanceof Init && v1 instanceof Init) {\n          return Init.value;\n        }\n\n        ;\n\n        if (v instanceof ParentOf && v1 instanceof Init) {\n          return new ParentOf(appendPath(Pathy_Phantom.relIsRelOrAbs)(v.value0)(Init.value));\n        }\n\n        ;\n\n        if (v instanceof In && v1 instanceof Init) {\n          return new In(appendPath(dictIsRelOrAbs)(v.value0)(Init.value), v.value1);\n        }\n\n        ;\n\n        if (v1 instanceof ParentOf) {\n          return parentOf(dictIsRelOrAbs)(appendPath(dictIsRelOrAbs)(v)(v1.value0));\n        }\n\n        ;\n\n        if (v1 instanceof In) {\n          return new In(appendPath(dictIsRelOrAbs)(v)(v1.value0), v1.value1);\n        }\n\n        ;\n        throw new Error(\"Failed pattern match at Pathy.Path (line 162, column 14 - line 167, column 34): \" + [v.constructor.name, v1.constructor.name]);\n      };\n    };\n  };\n\n  exports[\"rootDir\"] = rootDir;\n  exports[\"dir'\"] = dir$prime;\n  exports[\"file'\"] = file$prime;\n  exports[\"appendPath\"] = appendPath;\n  exports[\"foldPath\"] = foldPath;\n  exports[\"relativeTo\"] = relativeTo;\n})(PS);\n\n(function (exports) {\n  \"use strict\";\n\n  exports.singleton = function (c) {\n    return c;\n  };\n})(PS[\"Data.String.CodeUnits\"] = PS[\"Data.String.CodeUnits\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.String.CodeUnits\"] = $PS[\"Data.String.CodeUnits\"] || {};\n  var exports = $PS[\"Data.String.CodeUnits\"];\n  var $foreign = $PS[\"Data.String.CodeUnits\"];\n  exports[\"singleton\"] = $foreign.singleton;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.String.NonEmpty.CodeUnits\"] = $PS[\"Data.String.NonEmpty.CodeUnits\"] || {};\n  var exports = $PS[\"Data.String.NonEmpty.CodeUnits\"];\n  var Data_String_CodeUnits = $PS[\"Data.String.CodeUnits\"];\n  var Unsafe_Coerce = $PS[\"Unsafe.Coerce\"];\n  var toNonEmptyString = Unsafe_Coerce.unsafeCoerce;\n\n  var singleton = function singleton($13) {\n    return toNonEmptyString(Data_String_CodeUnits.singleton($13));\n  };\n\n  exports[\"singleton\"] = singleton;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Pathy.Sandboxed\"] = $PS[\"Pathy.Sandboxed\"] || {};\n  var exports = $PS[\"Pathy.Sandboxed\"];\n  var Control_Category = $PS[\"Control.Category\"];\n  var Data_Function = $PS[\"Data.Function\"];\n  var Data_Functor = $PS[\"Data.Functor\"];\n  var Data_Maybe = $PS[\"Data.Maybe\"];\n  var Pathy_Path = $PS[\"Pathy.Path\"];\n  var Pathy_Phantom = $PS[\"Pathy.Phantom\"];\n\n  var SandboxedPath = function () {\n    function SandboxedPath(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n\n    ;\n\n    SandboxedPath.create = function (value0) {\n      return function (value1) {\n        return new SandboxedPath(value0, value1);\n      };\n    };\n\n    return SandboxedPath;\n  }();\n\n  var unsandbox = function unsandbox(v) {\n    return v.value1;\n  };\n\n  var sandboxRoot = function sandboxRoot(v) {\n    return v.value0;\n  };\n\n  var sandbox = function sandbox(dictIsRelOrAbs) {\n    return function (root) {\n      var goesUp = Pathy_Path.foldPath(false)(Data_Function[\"const\"](true))(function (p) {\n        return function (v) {\n          return goesUp(p);\n        };\n      });\n\n      var go = function go(f) {\n        return function (coe) {\n          return function (p) {\n            var $35 = goesUp(Pathy_Path.relativeTo(f(p))(root));\n\n            if ($35) {\n              return Data_Maybe.Nothing.value;\n            }\n\n            ;\n            return new Data_Maybe.Just(coe(p));\n          };\n        };\n      };\n\n      var $49 = Data_Functor.map(Data_Maybe.functorMaybe)(SandboxedPath.create(root));\n      var $50 = Pathy_Phantom.onRelOrAbs(dictIsRelOrAbs)(go(function (v) {\n        return Pathy_Path.appendPath(Pathy_Phantom.absIsRelOrAbs)(root)(v);\n      }))(go(Control_Category.identity(Control_Category.categoryFn)));\n      return function ($51) {\n        return $49($50($51));\n      };\n    };\n  };\n\n  exports[\"sandbox\"] = sandbox;\n  exports[\"sandboxRoot\"] = sandboxRoot;\n  exports[\"unsandbox\"] = unsandbox;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Pathy.Printer\"] = $PS[\"Pathy.Printer\"] || {};\n  var exports = $PS[\"Pathy.Printer\"];\n  var Control_Category = $PS[\"Control.Category\"];\n  var Data_Function = $PS[\"Data.Function\"];\n  var Data_Maybe = $PS[\"Data.Maybe\"];\n  var Data_Newtype = $PS[\"Data.Newtype\"];\n  var Data_Semigroup = $PS[\"Data.Semigroup\"];\n  var Data_String_NonEmpty_CodeUnits = $PS[\"Data.String.NonEmpty.CodeUnits\"];\n  var Data_String_NonEmpty_Internal = $PS[\"Data.String.NonEmpty.Internal\"];\n  var Pathy_Name = $PS[\"Pathy.Name\"];\n  var Pathy_Path = $PS[\"Pathy.Path\"];\n  var Pathy_Phantom = $PS[\"Pathy.Phantom\"];\n  var Pathy_Sandboxed = $PS[\"Pathy.Sandboxed\"];\n\n  var Escaper = function Escaper(x) {\n    return x;\n  };\n\n  var slashEscaper = function () {\n    var dash = Data_String_NonEmpty_CodeUnits.singleton(\"-\");\n    return Data_String_NonEmpty_Internal.replaceAll(\"/\")(dash);\n  }();\n\n  var semigroupEscaper = new Data_Semigroup.Semigroup(function (v) {\n    return function (v1) {\n      return function ($29) {\n        return v(v1($29));\n      };\n    };\n  });\n  var newtypeEscaper = new Data_Newtype.Newtype(function (n) {\n    return n;\n  }, Escaper);\n\n  var printSegment = function printSegment(dictNewtype) {\n    return function (printer) {\n      var $30 = Data_Newtype.un(newtypeEscaper)(Escaper)(printer.escaper);\n      var $31 = Data_Newtype.unwrap(dictNewtype);\n      return function ($32) {\n        return Data_String_NonEmpty_Internal.toString($30($31($32)));\n      };\n    };\n  };\n\n  var printPathRep = function printPathRep(dictIsRelOrAbs) {\n    return function (dictIsDirOrFile) {\n      return function (printer) {\n        return function (inputPath) {\n          var isAbs = Pathy_Phantom.foldRelOrAbs(dictIsRelOrAbs)(Data_Function[\"const\"](false))(Data_Function[\"const\"](true))(inputPath);\n\n          var caseCurrent = function () {\n            if (isAbs) {\n              return printer.root(Data_Maybe.Nothing.value);\n            }\n\n            ;\n            return Data_String_NonEmpty_Internal.toString(Data_Semigroup.append(Data_String_NonEmpty_Internal.semigroupNonEmptyString)(printer.current)(printer.sep));\n          }();\n\n          var go = function go(dictIsRelOrAbs1) {\n            return function (dictIsDirOrFile1) {\n              return Pathy_Path.foldPath(caseCurrent)(caseParentOf)(caseIn(dictIsRelOrAbs1)(dictIsDirOrFile1));\n            };\n          };\n\n          var caseParentOf = function caseParentOf(p) {\n            return go(Pathy_Phantom.relIsRelOrAbs)(Pathy_Phantom.isDirOrFileDir)(p) + Data_String_NonEmpty_Internal.toString(Data_Semigroup.append(Data_String_NonEmpty_Internal.semigroupNonEmptyString)(printer.up)(printer.sep));\n          };\n\n          var caseIn = function caseIn(dictIsRelOrAbs1) {\n            return function (dictIsDirOrFile1) {\n              return function (p) {\n                return function (name) {\n                  return Pathy_Phantom.foldDirOrFile(dictIsDirOrFile1)(function (dirName) {\n                    return Pathy_Path.foldPath(function () {\n                      if (isAbs) {\n                        return printer.root(Data_Maybe.Just.create(Data_Newtype.unwrap(Pathy_Name.newtypeName)(dirName))) + Data_String_NonEmpty_Internal.toString(printer.sep);\n                      }\n\n                      ;\n                      return caseCurrent + (printSegment(Pathy_Name.newtypeName)(printer)(dirName) + Data_String_NonEmpty_Internal.toString(printer.sep));\n                    }())(function (p$prime) {\n                      return caseParentOf(p$prime) + (printSegment(Pathy_Name.newtypeName)(printer)(dirName) + Data_String_NonEmpty_Internal.toString(printer.sep));\n                    })(function (p$prime) {\n                      return function (n$prime) {\n                        return caseIn(dictIsRelOrAbs1)(Pathy_Phantom.isDirOrFileDir)(p$prime)(n$prime) + (printSegment(Pathy_Name.newtypeName)(printer)(dirName) + Data_String_NonEmpty_Internal.toString(printer.sep));\n                      };\n                    })(p);\n                  })(function (fileName) {\n                    return go(dictIsRelOrAbs1)(Pathy_Phantom.isDirOrFileDir)(p) + printSegment(Pathy_Name.newtypeName)(printer)(fileName);\n                  })(name);\n                };\n              };\n            };\n          };\n\n          return go(dictIsRelOrAbs)(dictIsDirOrFile)(inputPath);\n        };\n      };\n    };\n  };\n\n  var printPath = function printPath(dictIsRelOrAbs) {\n    return function (dictIsDirOrFile) {\n      return function (r) {\n        return function (sp) {\n          var root = Pathy_Sandboxed.sandboxRoot(sp);\n          var p = Pathy_Sandboxed.unsandbox(sp);\n          return printPathRep(Pathy_Phantom.absIsRelOrAbs)(dictIsDirOrFile)(r)(Pathy_Phantom.foldRelOrAbs(dictIsRelOrAbs)(function (v) {\n            return Pathy_Path.appendPath(Pathy_Phantom.absIsRelOrAbs)(root)(v);\n          })(Control_Category.identity(Control_Category.categoryFn))(p));\n        };\n      };\n    };\n  };\n\n  var dotEscaper = function dotEscaper(s) {\n    var v = Data_String_NonEmpty_Internal.toString(s);\n\n    if (v === \"..\") {\n      return Data_String_NonEmpty_Internal.unsafeFromString()(\"$dot$dot\");\n    }\n\n    ;\n\n    if (v === \".\") {\n      return Data_String_NonEmpty_Internal.unsafeFromString()(\"$dot\");\n    }\n\n    ;\n    return s;\n  };\n\n  var posixEscaper = Data_Semigroup.append(semigroupEscaper)(slashEscaper)(dotEscaper);\n  var posixPrinter = {\n    root: Data_Maybe.maybe(\"/\")(function (name) {\n      return \"/\" + Data_String_NonEmpty_Internal.toString(Data_Newtype.un(newtypeEscaper)(Escaper)(posixEscaper)(name));\n    }),\n    current: Data_String_NonEmpty_CodeUnits.singleton(\".\"),\n    up: Data_Semigroup.append(Data_String_NonEmpty_Internal.semigroupNonEmptyString)(Data_String_NonEmpty_CodeUnits.singleton(\".\"))(Data_String_NonEmpty_CodeUnits.singleton(\".\")),\n    sep: Data_String_NonEmpty_CodeUnits.singleton(\"/\"),\n    escaper: posixEscaper\n  };\n  exports[\"posixPrinter\"] = posixPrinter;\n  exports[\"printPath\"] = printPath;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Components.Home\"] = $PS[\"Components.Home\"] || {};\n  var exports = $PS[\"Components.Home\"];\n  var Data_Functor = $PS[\"Data.Functor\"];\n  var Data_Maybe = $PS[\"Data.Maybe\"];\n  var Data_String_NonEmpty_Internal = $PS[\"Data.String.NonEmpty.Internal\"];\n  var Halogen_Component = $PS[\"Halogen.Component\"];\n  var Halogen_HTML_Core = $PS[\"Halogen.HTML.Core\"];\n  var Halogen_HTML_Elements = $PS[\"Halogen.HTML.Elements\"];\n  var Halogen_HTML_Properties = $PS[\"Halogen.HTML.Properties\"];\n  var Pathy_Path = $PS[\"Pathy.Path\"];\n  var Pathy_Phantom = $PS[\"Pathy.Phantom\"];\n  var Pathy_Printer = $PS[\"Pathy.Printer\"];\n  var Pathy_Sandboxed = $PS[\"Pathy.Sandboxed\"];\n\n  var ui = function ui(_state) {\n    var imageFile = Pathy_Path[\"file'\"](Data_String_NonEmpty_Internal.unsafeFromString()(\"devnull_logo.png\"));\n    var imageDir = Pathy_Path.appendPath(Pathy_Phantom.absIsRelOrAbs)(Pathy_Path.appendPath(Pathy_Phantom.absIsRelOrAbs)(Pathy_Path.rootDir)(Pathy_Path[\"dir'\"](Data_String_NonEmpty_Internal.unsafeFromString()(\"static\"))))(Pathy_Path[\"dir'\"](Data_String_NonEmpty_Internal.unsafeFromString()(\"images\")));\n    var sandboxedPath = Pathy_Sandboxed.sandbox(Pathy_Phantom.relIsRelOrAbs)(imageDir)(imageFile);\n    var stringPath = Data_Maybe.fromMaybe(\"path-not-found\")(Data_Functor.map(Data_Maybe.functorMaybe)(Pathy_Printer.printPath(Pathy_Phantom.relIsRelOrAbs)(Pathy_Phantom.isDirOrFileFile)(Pathy_Printer.posixPrinter))(sandboxedPath));\n    return Halogen_HTML_Elements.div([Halogen_HTML_Properties.class_(\"container\")])([Halogen_HTML_Elements.div([Halogen_HTML_Properties.class_(\"jumbothron text-center\")])([Halogen_HTML_Elements.img([Halogen_HTML_Properties.src(stringPath)])]), Halogen_HTML_Elements.div([Halogen_HTML_Properties.class_(\"container bg-white p-5\")])([Halogen_HTML_Elements.h1_([Halogen_HTML_Core.text(\"Devnull org\")]), Halogen_HTML_Elements.p([Halogen_HTML_Properties.class_(\"row bg-white p-4 border\")])([Halogen_HTML_Core.text(\"Devnull org is a software consultancy company specialized in  working with Haskell programming language.  We work with Haskell because it provides us with a way of building  composable code quickly and with high degree of certainty of correctness.  \")]), Halogen_HTML_Elements.p_([Halogen_HTML_Core.text(\"Services we provide:\")]), Halogen_HTML_Elements.ul([Halogen_HTML_Properties.class_(\"list-group\")])([Halogen_HTML_Elements.li([Halogen_HTML_Properties.class_(\"list-group-item\")])([Halogen_HTML_Core.text(\"writing production level code\")]), Halogen_HTML_Elements.li([Halogen_HTML_Properties.class_(\"list-group-item\")])([Halogen_HTML_Core.text(\"code optimization\")]), Halogen_HTML_Elements.li([Halogen_HTML_Properties.class_(\"list-group-item\")])([Halogen_HTML_Core.text(\"debugging and fixing problems with execution speed and/or large memory consumption\")])]), Halogen_HTML_Elements.p([Halogen_HTML_Properties.class_(\"bg-white p-4\")])([Halogen_HTML_Core.text(\"Additionally we work on tools that should solve some of the pain points various companies experience in their daily operations.  Products  We continuously work on set of tools that could be of interest to either working developers or companies working mainly with web tech. You can learn more on the products page.\")])])]);\n  };\n\n  var initialState = function initialState(v) {\n    return {\n      enabled: false\n    };\n  };\n\n  var homeComponent = Halogen_Component.mkComponent({\n    initialState: initialState,\n    render: ui,\n    \"eval\": Halogen_Component.mkEval(Halogen_Component.defaultEval)\n  });\n  exports[\"homeComponent\"] = homeComponent;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.Either\"] = $PS[\"Data.Either\"] || {};\n  var exports = $PS[\"Data.Either\"];\n  var Control_Apply = $PS[\"Control.Apply\"];\n  var Data_Bifunctor = $PS[\"Data.Bifunctor\"];\n  var Data_Functor = $PS[\"Data.Functor\"];\n\n  var Left = function () {\n    function Left(value0) {\n      this.value0 = value0;\n    }\n\n    ;\n\n    Left.create = function (value0) {\n      return new Left(value0);\n    };\n\n    return Left;\n  }();\n\n  var Right = function () {\n    function Right(value0) {\n      this.value0 = value0;\n    }\n\n    ;\n\n    Right.create = function (value0) {\n      return new Right(value0);\n    };\n\n    return Right;\n  }();\n\n  var functorEither = new Data_Functor.Functor(function (f) {\n    return function (m) {\n      if (m instanceof Left) {\n        return new Left(m.value0);\n      }\n\n      ;\n\n      if (m instanceof Right) {\n        return new Right(f(m.value0));\n      }\n\n      ;\n      throw new Error(\"Failed pattern match at Data.Either (line 38, column 1 - line 38, column 52): \" + [m.constructor.name]);\n    };\n  });\n\n  var either = function either(v) {\n    return function (v1) {\n      return function (v2) {\n        if (v2 instanceof Left) {\n          return v(v2.value0);\n        }\n\n        ;\n\n        if (v2 instanceof Right) {\n          return v1(v2.value0);\n        }\n\n        ;\n        throw new Error(\"Failed pattern match at Data.Either (line 238, column 1 - line 238, column 64): \" + [v.constructor.name, v1.constructor.name, v2.constructor.name]);\n      };\n    };\n  };\n\n  var bifunctorEither = new Data_Bifunctor.Bifunctor(function (v) {\n    return function (v1) {\n      return function (v2) {\n        if (v2 instanceof Left) {\n          return new Left(v(v2.value0));\n        }\n\n        ;\n\n        if (v2 instanceof Right) {\n          return new Right(v1(v2.value0));\n        }\n\n        ;\n        throw new Error(\"Failed pattern match at Data.Either (line 46, column 1 - line 48, column 36): \" + [v.constructor.name, v1.constructor.name, v2.constructor.name]);\n      };\n    };\n  });\n  var applyEither = new Control_Apply.Apply(function () {\n    return functorEither;\n  }, function (v) {\n    return function (v1) {\n      if (v instanceof Left) {\n        return new Left(v.value0);\n      }\n\n      ;\n\n      if (v instanceof Right) {\n        return Data_Functor.map(functorEither)(v.value0)(v1);\n      }\n\n      ;\n      throw new Error(\"Failed pattern match at Data.Either (line 82, column 1 - line 84, column 30): \" + [v.constructor.name, v1.constructor.name]);\n    };\n  });\n  exports[\"Left\"] = Left;\n  exports[\"Right\"] = Right;\n  exports[\"either\"] = either;\n  exports[\"functorEither\"] = functorEither;\n  exports[\"bifunctorEither\"] = bifunctorEither;\n  exports[\"applyEither\"] = applyEither;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.NonEmpty\"] = $PS[\"Data.NonEmpty\"] || {};\n  var exports = $PS[\"Data.NonEmpty\"];\n  var Control_Plus = $PS[\"Control.Plus\"];\n\n  var NonEmpty = function () {\n    function NonEmpty(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n\n    ;\n\n    NonEmpty.create = function (value0) {\n      return function (value1) {\n        return new NonEmpty(value0, value1);\n      };\n    };\n\n    return NonEmpty;\n  }();\n\n  var singleton = function singleton(dictPlus) {\n    return function (a) {\n      return new NonEmpty(a, Control_Plus.empty(dictPlus));\n    };\n  };\n\n  exports[\"NonEmpty\"] = NonEmpty;\n  exports[\"singleton\"] = singleton;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.List.NonEmpty\"] = $PS[\"Data.List.NonEmpty\"] || {};\n  var exports = $PS[\"Data.List.NonEmpty\"];\n  var Data_List_Types = $PS[\"Data.List.Types\"];\n  var Data_NonEmpty = $PS[\"Data.NonEmpty\"];\n\n  var singleton = function () {\n    var $168 = Data_NonEmpty.singleton(Data_List_Types.plusList);\n    return function ($169) {\n      return Data_List_Types.NonEmptyList($168($169));\n    };\n  }();\n\n  var cons = function cons(y) {\n    return function (v) {\n      return new Data_NonEmpty.NonEmpty(y, new Data_List_Types.Cons(v.value0, v.value1));\n    };\n  };\n\n  exports[\"singleton\"] = singleton;\n  exports[\"cons\"] = cons;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Control.Applicative.Free\"] = $PS[\"Control.Applicative.Free\"] || {};\n  var exports = $PS[\"Control.Applicative.Free\"];\n  var Control_Applicative = $PS[\"Control.Applicative\"];\n  var Control_Apply = $PS[\"Control.Apply\"];\n  var Control_Category = $PS[\"Control.Category\"];\n  var Data_Either = $PS[\"Data.Either\"];\n  var Data_Functor = $PS[\"Data.Functor\"];\n  var Data_List_NonEmpty = $PS[\"Data.List.NonEmpty\"];\n  var Data_List_Types = $PS[\"Data.List.Types\"];\n  var Data_NonEmpty = $PS[\"Data.NonEmpty\"];\n  var Data_Tuple = $PS[\"Data.Tuple\"];\n\n  var Pure = function () {\n    function Pure(value0) {\n      this.value0 = value0;\n    }\n\n    ;\n\n    Pure.create = function (value0) {\n      return new Pure(value0);\n    };\n\n    return Pure;\n  }();\n\n  var Lift = function () {\n    function Lift(value0) {\n      this.value0 = value0;\n    }\n\n    ;\n\n    Lift.create = function (value0) {\n      return new Lift(value0);\n    };\n\n    return Lift;\n  }();\n\n  var Ap = function () {\n    function Ap(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n\n    ;\n\n    Ap.create = function (value0) {\n      return function (value1) {\n        return new Ap(value0, value1);\n      };\n    };\n\n    return Ap;\n  }();\n\n  var mkAp = function mkAp(fba) {\n    return function (fb) {\n      return new Ap(fba, fb);\n    };\n  };\n\n  var liftFreeAp = Lift.create;\n\n  var goLeft = function goLeft($copy_dictApplicative) {\n    return function ($copy_fStack) {\n      return function ($copy_valStack) {\n        return function ($copy_nat) {\n          return function ($copy_func) {\n            return function ($copy_count) {\n              var $tco_var_dictApplicative = $copy_dictApplicative;\n              var $tco_var_fStack = $copy_fStack;\n              var $tco_var_valStack = $copy_valStack;\n              var $tco_var_nat = $copy_nat;\n              var $tco_var_func = $copy_func;\n              var $tco_done = false;\n              var $tco_result;\n\n              function $tco_loop(dictApplicative, fStack, valStack, nat, func, count) {\n                if (func instanceof Pure) {\n                  $tco_done = true;\n                  return new Data_Tuple.Tuple(new Data_List_Types.Cons({\n                    func: Control_Applicative.pure(dictApplicative)(func.value0),\n                    count: count\n                  }, fStack), valStack);\n                }\n\n                ;\n\n                if (func instanceof Lift) {\n                  $tco_done = true;\n                  return new Data_Tuple.Tuple(new Data_List_Types.Cons({\n                    func: nat(func.value0),\n                    count: count\n                  }, fStack), valStack);\n                }\n\n                ;\n\n                if (func instanceof Ap) {\n                  $tco_var_dictApplicative = dictApplicative;\n                  $tco_var_fStack = fStack;\n                  $tco_var_valStack = Data_List_NonEmpty.cons(func.value1)(valStack);\n                  $tco_var_nat = nat;\n                  $tco_var_func = func.value0;\n                  $copy_count = count + 1 | 0;\n                  return;\n                }\n\n                ;\n                throw new Error(\"Failed pattern match at Control.Applicative.Free (line 102, column 41 - line 105, column 81): \" + [func.constructor.name]);\n              }\n\n              ;\n\n              while (!$tco_done) {\n                $tco_result = $tco_loop($tco_var_dictApplicative, $tco_var_fStack, $tco_var_valStack, $tco_var_nat, $tco_var_func, $copy_count);\n              }\n\n              ;\n              return $tco_result;\n            };\n          };\n        };\n      };\n    };\n  };\n\n  var goApply = function goApply($copy_dictApplicative) {\n    return function ($copy_fStack) {\n      return function ($copy_vals) {\n        return function ($copy_gVal) {\n          var $tco_var_dictApplicative = $copy_dictApplicative;\n          var $tco_var_fStack = $copy_fStack;\n          var $tco_var_vals = $copy_vals;\n          var $tco_done = false;\n          var $tco_result;\n\n          function $tco_loop(dictApplicative, fStack, vals, gVal) {\n            if (fStack instanceof Data_List_Types.Nil) {\n              $tco_done = true;\n              return new Data_Either.Left(gVal);\n            }\n\n            ;\n\n            if (fStack instanceof Data_List_Types.Cons) {\n              var gRes = Control_Apply.apply(dictApplicative.Apply0())(fStack.value0.func)(gVal);\n              var $14 = fStack.value0.count === 1;\n\n              if ($14) {\n                if (fStack.value1 instanceof Data_List_Types.Nil) {\n                  $tco_done = true;\n                  return new Data_Either.Left(gRes);\n                }\n\n                ;\n                $tco_var_dictApplicative = dictApplicative;\n                $tco_var_fStack = fStack.value1;\n                $tco_var_vals = vals;\n                $copy_gVal = gRes;\n                return;\n              }\n\n              ;\n\n              if (vals instanceof Data_List_Types.Nil) {\n                $tco_done = true;\n                return new Data_Either.Left(gRes);\n              }\n\n              ;\n\n              if (vals instanceof Data_List_Types.Cons) {\n                $tco_done = true;\n                return Data_Either.Right.create(new Data_Tuple.Tuple(new Data_List_Types.Cons({\n                  func: gRes,\n                  count: fStack.value0.count - 1 | 0\n                }, fStack.value1), new Data_NonEmpty.NonEmpty(vals.value0, vals.value1)));\n              }\n\n              ;\n              throw new Error(\"Failed pattern match at Control.Applicative.Free (line 83, column 11 - line 88, column 50): \" + [vals.constructor.name]);\n            }\n\n            ;\n            throw new Error(\"Failed pattern match at Control.Applicative.Free (line 72, column 3 - line 88, column 50): \" + [fStack.constructor.name]);\n          }\n\n          ;\n\n          while (!$tco_done) {\n            $tco_result = $tco_loop($tco_var_dictApplicative, $tco_var_fStack, $tco_var_vals, $copy_gVal);\n          }\n\n          ;\n          return $tco_result;\n        };\n      };\n    };\n  };\n\n  var functorFreeAp = new Data_Functor.Functor(function (f) {\n    return function (x) {\n      return mkAp(new Pure(f))(x);\n    };\n  });\n\n  var foldFreeAp = function foldFreeAp(dictApplicative) {\n    return function (nat) {\n      return function (z) {\n        var go = function go($copy_v) {\n          var $tco_done = false;\n          var $tco_result;\n\n          function $tco_loop(v) {\n            if (v.value1.value0 instanceof Pure) {\n              var v1 = goApply(dictApplicative)(v.value0)(v.value1.value1)(Control_Applicative.pure(dictApplicative)(v.value1.value0.value0));\n\n              if (v1 instanceof Data_Either.Left) {\n                $tco_done = true;\n                return v1.value0;\n              }\n\n              ;\n\n              if (v1 instanceof Data_Either.Right) {\n                $copy_v = v1.value0;\n                return;\n              }\n\n              ;\n              throw new Error(\"Failed pattern match at Control.Applicative.Free (line 54, column 17 - line 56, column 24): \" + [v1.constructor.name]);\n            }\n\n            ;\n\n            if (v.value1.value0 instanceof Lift) {\n              var v1 = goApply(dictApplicative)(v.value0)(v.value1.value1)(nat(v.value1.value0.value0));\n\n              if (v1 instanceof Data_Either.Left) {\n                $tco_done = true;\n                return v1.value0;\n              }\n\n              ;\n\n              if (v1 instanceof Data_Either.Right) {\n                $copy_v = v1.value0;\n                return;\n              }\n\n              ;\n              throw new Error(\"Failed pattern match at Control.Applicative.Free (line 57, column 17 - line 59, column 24): \" + [v1.constructor.name]);\n            }\n\n            ;\n\n            if (v.value1.value0 instanceof Ap) {\n              var nextVals = new Data_NonEmpty.NonEmpty(v.value1.value0.value1, v.value1.value1);\n              $copy_v = goLeft(dictApplicative)(v.value0)(nextVals)(nat)(v.value1.value0.value0)(1);\n              return;\n            }\n\n            ;\n            throw new Error(\"Failed pattern match at Control.Applicative.Free (line 53, column 5 - line 62, column 47): \" + [v.value1.value0.constructor.name]);\n          }\n\n          ;\n\n          while (!$tco_done) {\n            $tco_result = $tco_loop($copy_v);\n          }\n\n          ;\n          return $tco_result;\n        };\n\n        return go(new Data_Tuple.Tuple(Data_List_Types.Nil.value, Data_List_NonEmpty.singleton(z)));\n      };\n    };\n  };\n\n  var retractFreeAp = function retractFreeAp(dictApplicative) {\n    return foldFreeAp(dictApplicative)(Control_Category.identity(Control_Category.categoryFn));\n  };\n\n  var applyFreeAp = new Control_Apply.Apply(function () {\n    return functorFreeAp;\n  }, function (fba) {\n    return function (fb) {\n      return mkAp(fba)(fb);\n    };\n  });\n  var applicativeFreeAp = new Control_Applicative.Applicative(function () {\n    return applyFreeAp;\n  }, Pure.create);\n\n  var hoistFreeAp = function hoistFreeAp(f) {\n    return foldFreeAp(applicativeFreeAp)(function ($37) {\n      return liftFreeAp(f($37));\n    });\n  };\n\n  exports[\"retractFreeAp\"] = retractFreeAp;\n  exports[\"hoistFreeAp\"] = hoistFreeAp;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Control.Monad.Except.Trans\"] = $PS[\"Control.Monad.Except.Trans\"] || {};\n  var exports = $PS[\"Control.Monad.Except.Trans\"];\n  var Control_Applicative = $PS[\"Control.Applicative\"];\n  var Control_Apply = $PS[\"Control.Apply\"];\n  var Control_Bind = $PS[\"Control.Bind\"];\n  var Control_Monad = $PS[\"Control.Monad\"];\n  var Data_Either = $PS[\"Data.Either\"];\n  var Data_Functor = $PS[\"Data.Functor\"];\n\n  var ExceptT = function ExceptT(x) {\n    return x;\n  };\n\n  var runExceptT = function runExceptT(v) {\n    return v;\n  };\n\n  var mapExceptT = function mapExceptT(f) {\n    return function (v) {\n      return f(v);\n    };\n  };\n\n  var functorExceptT = function functorExceptT(dictFunctor) {\n    return new Data_Functor.Functor(function (f) {\n      return mapExceptT(Data_Functor.map(dictFunctor)(Data_Functor.map(Data_Either.functorEither)(f)));\n    });\n  };\n\n  var monadExceptT = function monadExceptT(dictMonad) {\n    return new Control_Monad.Monad(function () {\n      return applicativeExceptT(dictMonad);\n    }, function () {\n      return bindExceptT(dictMonad);\n    });\n  };\n\n  var bindExceptT = function bindExceptT(dictMonad) {\n    return new Control_Bind.Bind(function () {\n      return applyExceptT(dictMonad);\n    }, function (v) {\n      return function (k) {\n        return Control_Bind.bind(dictMonad.Bind1())(v)(Data_Either.either(function () {\n          var $90 = Control_Applicative.pure(dictMonad.Applicative0());\n          return function ($91) {\n            return $90(Data_Either.Left.create($91));\n          };\n        }())(function (a) {\n          var v1 = k(a);\n          return v1;\n        }));\n      };\n    });\n  };\n\n  var applyExceptT = function applyExceptT(dictMonad) {\n    return new Control_Apply.Apply(function () {\n      return functorExceptT(dictMonad.Bind1().Apply0().Functor0());\n    }, Control_Monad.ap(monadExceptT(dictMonad)));\n  };\n\n  var applicativeExceptT = function applicativeExceptT(dictMonad) {\n    return new Control_Applicative.Applicative(function () {\n      return applyExceptT(dictMonad);\n    }, function () {\n      var $92 = Control_Applicative.pure(dictMonad.Applicative0());\n      return function ($93) {\n        return ExceptT($92(Data_Either.Right.create($93)));\n      };\n    }());\n  };\n\n  exports[\"ExceptT\"] = ExceptT;\n  exports[\"runExceptT\"] = runExceptT;\n  exports[\"applicativeExceptT\"] = applicativeExceptT;\n  exports[\"bindExceptT\"] = bindExceptT;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Control.Monad.Trans.Class\"] = $PS[\"Control.Monad.Trans.Class\"] || {};\n  var exports = $PS[\"Control.Monad.Trans.Class\"];\n\n  var MonadTrans = function MonadTrans(lift) {\n    this.lift = lift;\n  };\n\n  var lift = function lift(dict) {\n    return dict.lift;\n  };\n\n  exports[\"lift\"] = lift;\n  exports[\"MonadTrans\"] = MonadTrans;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Control.Monad.Free.Trans\"] = $PS[\"Control.Monad.Free.Trans\"] || {};\n  var exports = $PS[\"Control.Monad.Free.Trans\"];\n  var Control_Applicative = $PS[\"Control.Applicative\"];\n  var Control_Apply = $PS[\"Control.Apply\"];\n  var Control_Bind = $PS[\"Control.Bind\"];\n  var Control_Monad = $PS[\"Control.Monad\"];\n  var Control_Monad_Rec_Class = $PS[\"Control.Monad.Rec.Class\"];\n  var Control_Monad_Trans_Class = $PS[\"Control.Monad.Trans.Class\"];\n  var Data_Bifunctor = $PS[\"Data.Bifunctor\"];\n  var Data_Either = $PS[\"Data.Either\"];\n  var Data_Exists = $PS[\"Data.Exists\"];\n  var Data_Functor = $PS[\"Data.Functor\"];\n  var Data_Unit = $PS[\"Data.Unit\"];\n\n  var Bound = function () {\n    function Bound(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n\n    ;\n\n    Bound.create = function (value0) {\n      return function (value1) {\n        return new Bound(value0, value1);\n      };\n    };\n\n    return Bound;\n  }();\n\n  var FreeT = function () {\n    function FreeT(value0) {\n      this.value0 = value0;\n    }\n\n    ;\n\n    FreeT.create = function (value0) {\n      return new FreeT(value0);\n    };\n\n    return FreeT;\n  }();\n\n  var Bind = function () {\n    function Bind(value0) {\n      this.value0 = value0;\n    }\n\n    ;\n\n    Bind.create = function (value0) {\n      return new Bind(value0);\n    };\n\n    return Bind;\n  }();\n\n  var monadTransFreeT = function monadTransFreeT(dictFunctor) {\n    return new Control_Monad_Trans_Class.MonadTrans(function (dictMonad) {\n      return function (ma) {\n        return new FreeT(function (v) {\n          return Data_Functor.map(dictMonad.Bind1().Apply0().Functor0())(Data_Either.Left.create)(ma);\n        });\n      };\n    });\n  };\n\n  var freeT = FreeT.create;\n\n  var bound = function bound(m) {\n    return function (f) {\n      return new Bind(Data_Exists.mkExists(new Bound(m, f)));\n    };\n  };\n\n  var functorFreeT = function functorFreeT(dictFunctor) {\n    return function (dictFunctor1) {\n      return new Data_Functor.Functor(function (f) {\n        return function (v) {\n          if (v instanceof FreeT) {\n            return new FreeT(function (v1) {\n              return Data_Functor.map(dictFunctor1)(Data_Bifunctor.bimap(Data_Either.bifunctorEither)(f)(Data_Functor.map(dictFunctor)(Data_Functor.map(functorFreeT(dictFunctor)(dictFunctor1))(f))))(v.value0(Data_Unit.unit));\n            });\n          }\n\n          ;\n\n          if (v instanceof Bind) {\n            return Data_Exists.runExists(function (v1) {\n              return bound(v1.value0)(function () {\n                var $123 = Data_Functor.map(functorFreeT(dictFunctor)(dictFunctor1))(f);\n                return function ($124) {\n                  return $123(v1.value1($124));\n                };\n              }());\n            })(v.value0);\n          }\n\n          ;\n          throw new Error(\"Failed pattern match at Control.Monad.Free.Trans (line 59, column 1 - line 61, column 71): \" + [f.constructor.name, v.constructor.name]);\n        };\n      });\n    };\n  };\n\n  var monadFreeT = function monadFreeT(dictFunctor) {\n    return function (dictMonad) {\n      return new Control_Monad.Monad(function () {\n        return applicativeFreeT(dictFunctor)(dictMonad);\n      }, function () {\n        return bindFreeT(dictFunctor)(dictMonad);\n      });\n    };\n  };\n\n  var bindFreeT = function bindFreeT(dictFunctor) {\n    return function (dictMonad) {\n      return new Control_Bind.Bind(function () {\n        return applyFreeT(dictFunctor)(dictMonad);\n      }, function (v) {\n        return function (f) {\n          if (v instanceof Bind) {\n            return Data_Exists.runExists(function (v1) {\n              return bound(v1.value0)(function (x) {\n                return bound(function (v2) {\n                  return v1.value1(x);\n                })(f);\n              });\n            })(v.value0);\n          }\n\n          ;\n          return bound(function (v1) {\n            return v;\n          })(f);\n        };\n      });\n    };\n  };\n\n  var applyFreeT = function applyFreeT(dictFunctor) {\n    return function (dictMonad) {\n      return new Control_Apply.Apply(function () {\n        return functorFreeT(dictFunctor)(dictMonad.Bind1().Apply0().Functor0());\n      }, Control_Monad.ap(monadFreeT(dictFunctor)(dictMonad)));\n    };\n  };\n\n  var applicativeFreeT = function applicativeFreeT(dictFunctor) {\n    return function (dictMonad) {\n      return new Control_Applicative.Applicative(function () {\n        return applyFreeT(dictFunctor)(dictMonad);\n      }, function (a) {\n        return new FreeT(function (v) {\n          return Control_Applicative.pure(dictMonad.Applicative0())(new Data_Either.Left(a));\n        });\n      });\n    };\n  };\n\n  var liftFreeT = function liftFreeT(dictFunctor) {\n    return function (dictMonad) {\n      return function (fa) {\n        return new FreeT(function (v) {\n          return Control_Applicative.pure(dictMonad.Applicative0())(new Data_Either.Right(Data_Functor.map(dictFunctor)(Control_Applicative.pure(applicativeFreeT(dictFunctor)(dictMonad)))(fa)));\n        });\n      };\n    };\n  };\n\n  var resume = function resume(dictFunctor) {\n    return function (dictMonadRec) {\n      var go = function go(v) {\n        if (v instanceof FreeT) {\n          return Data_Functor.map(dictMonadRec.Monad0().Bind1().Apply0().Functor0())(Control_Monad_Rec_Class.Done.create)(v.value0(Data_Unit.unit));\n        }\n\n        ;\n\n        if (v instanceof Bind) {\n          return Data_Exists.runExists(function (v1) {\n            var v2 = v1.value0(Data_Unit.unit);\n\n            if (v2 instanceof FreeT) {\n              return Control_Bind.bind(dictMonadRec.Monad0().Bind1())(v2.value0(Data_Unit.unit))(function (v3) {\n                if (v3 instanceof Data_Either.Left) {\n                  return Control_Applicative.pure(dictMonadRec.Monad0().Applicative0())(new Control_Monad_Rec_Class.Loop(v1.value1(v3.value0)));\n                }\n\n                ;\n\n                if (v3 instanceof Data_Either.Right) {\n                  return Control_Applicative.pure(dictMonadRec.Monad0().Applicative0())(new Control_Monad_Rec_Class.Done(new Data_Either.Right(Data_Functor.map(dictFunctor)(function (h) {\n                    return Control_Bind.bind(bindFreeT(dictFunctor)(dictMonadRec.Monad0()))(h)(v1.value1);\n                  })(v3.value0))));\n                }\n\n                ;\n                throw new Error(\"Failed pattern match at Control.Monad.Free.Trans (line 54, column 20 - line 56, column 67): \" + [v3.constructor.name]);\n              });\n            }\n\n            ;\n\n            if (v2 instanceof Bind) {\n              return Data_Exists.runExists(function (v3) {\n                return Control_Applicative.pure(dictMonadRec.Monad0().Applicative0())(new Control_Monad_Rec_Class.Loop(Control_Bind.bind(bindFreeT(dictFunctor)(dictMonadRec.Monad0()))(v3.value0(Data_Unit.unit))(function (z) {\n                  return Control_Bind.bind(bindFreeT(dictFunctor)(dictMonadRec.Monad0()))(v3.value1(z))(v1.value1);\n                })));\n              })(v2.value0);\n            }\n\n            ;\n            throw new Error(\"Failed pattern match at Control.Monad.Free.Trans (line 52, column 5 - line 57, column 98): \" + [v2.constructor.name]);\n          })(v.value0);\n        }\n\n        ;\n        throw new Error(\"Failed pattern match at Control.Monad.Free.Trans (line 49, column 3 - line 49, column 75): \" + [v.constructor.name]);\n      };\n\n      return Control_Monad_Rec_Class.tailRecM(dictMonadRec)(go);\n    };\n  };\n\n  var runFreeT = function runFreeT(dictFunctor) {\n    return function (dictMonadRec) {\n      return function (interp) {\n        var go = function go(v) {\n          if (v instanceof Data_Either.Left) {\n            return Control_Applicative.pure(dictMonadRec.Monad0().Applicative0())(new Control_Monad_Rec_Class.Done(v.value0));\n          }\n\n          ;\n\n          if (v instanceof Data_Either.Right) {\n            return Data_Functor.map(dictMonadRec.Monad0().Bind1().Apply0().Functor0())(Control_Monad_Rec_Class.Loop.create)(interp(v.value0));\n          }\n\n          ;\n          throw new Error(\"Failed pattern match at Control.Monad.Free.Trans (line 141, column 3 - line 141, column 63): \" + [v.constructor.name]);\n        };\n\n        return Control_Monad_Rec_Class.tailRecM(dictMonadRec)(Control_Bind.composeKleisliFlipped(dictMonadRec.Monad0().Bind1())(go)(resume(dictFunctor)(dictMonadRec)));\n      };\n    };\n  };\n\n  var monadRecFreeT = function monadRecFreeT(dictFunctor) {\n    return function (dictMonad) {\n      return new Control_Monad_Rec_Class.MonadRec(function () {\n        return monadFreeT(dictFunctor)(dictMonad);\n      }, function (f) {\n        var go = function go(s) {\n          return Control_Bind.bind(bindFreeT(dictFunctor)(dictMonad))(f(s))(function (v) {\n            if (v instanceof Control_Monad_Rec_Class.Loop) {\n              return go(v.value0);\n            }\n\n            ;\n\n            if (v instanceof Control_Monad_Rec_Class.Done) {\n              return Control_Applicative.pure(applicativeFreeT(dictFunctor)(dictMonad))(v.value0);\n            }\n\n            ;\n            throw new Error(\"Failed pattern match at Control.Monad.Free.Trans (line 82, column 15 - line 84, column 25): \" + [v.constructor.name]);\n          });\n        };\n\n        return go;\n      });\n    };\n  };\n\n  exports[\"freeT\"] = freeT;\n  exports[\"liftFreeT\"] = liftFreeT;\n  exports[\"resume\"] = resume;\n  exports[\"runFreeT\"] = runFreeT;\n  exports[\"functorFreeT\"] = functorFreeT;\n  exports[\"applicativeFreeT\"] = applicativeFreeT;\n  exports[\"bindFreeT\"] = bindFreeT;\n  exports[\"monadTransFreeT\"] = monadTransFreeT;\n  exports[\"monadRecFreeT\"] = monadRecFreeT;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Control.Parallel.Class\"] = $PS[\"Control.Parallel.Class\"] || {};\n  var exports = $PS[\"Control.Parallel.Class\"];\n\n  var Parallel = function Parallel(Applicative1, Monad0, parallel, sequential) {\n    this.Applicative1 = Applicative1;\n    this.Monad0 = Monad0;\n    this.parallel = parallel;\n    this.sequential = sequential;\n  };\n\n  var sequential = function sequential(dict) {\n    return dict.sequential;\n  };\n\n  var parallel = function parallel(dict) {\n    return dict.parallel;\n  };\n\n  exports[\"parallel\"] = parallel;\n  exports[\"sequential\"] = sequential;\n  exports[\"Parallel\"] = Parallel;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.Identity\"] = $PS[\"Data.Identity\"] || {};\n  var exports = $PS[\"Data.Identity\"];\n  var Control_Applicative = $PS[\"Control.Applicative\"];\n  var Control_Apply = $PS[\"Control.Apply\"];\n  var Data_Functor = $PS[\"Data.Functor\"];\n  var Data_Newtype = $PS[\"Data.Newtype\"];\n\n  var Identity = function Identity(x) {\n    return x;\n  };\n\n  var newtypeIdentity = new Data_Newtype.Newtype(function (n) {\n    return n;\n  }, Identity);\n  var functorIdentity = new Data_Functor.Functor(function (f) {\n    return function (m) {\n      return f(m);\n    };\n  });\n  var applyIdentity = new Control_Apply.Apply(function () {\n    return functorIdentity;\n  }, function (v) {\n    return function (v1) {\n      return v(v1);\n    };\n  });\n  var applicativeIdentity = new Control_Applicative.Applicative(function () {\n    return applyIdentity;\n  }, Identity);\n  exports[\"newtypeIdentity\"] = newtypeIdentity;\n  exports[\"functorIdentity\"] = functorIdentity;\n  exports[\"applicativeIdentity\"] = applicativeIdentity;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.Profunctor\"] = $PS[\"Data.Profunctor\"] || {};\n  var exports = $PS[\"Data.Profunctor\"];\n  var Control_Category = $PS[\"Control.Category\"];\n\n  var Profunctor = function Profunctor(dimap) {\n    this.dimap = dimap;\n  };\n\n  var profunctorFn = new Profunctor(function (a2b) {\n    return function (c2d) {\n      return function (b2c) {\n        return function ($9) {\n          return c2d(b2c(a2b($9)));\n        };\n      };\n    };\n  });\n\n  var dimap = function dimap(dict) {\n    return dict.dimap;\n  };\n\n  var rmap = function rmap(dictProfunctor) {\n    return function (b2c) {\n      return dimap(dictProfunctor)(Control_Category.identity(Control_Category.categoryFn))(b2c);\n    };\n  };\n\n  exports[\"dimap\"] = dimap;\n  exports[\"Profunctor\"] = Profunctor;\n  exports[\"rmap\"] = rmap;\n  exports[\"profunctorFn\"] = profunctorFn;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Control.Coroutine\"] = $PS[\"Control.Coroutine\"] || {};\n  var exports = $PS[\"Control.Coroutine\"];\n  var Control_Applicative = $PS[\"Control.Applicative\"];\n  var Control_Apply = $PS[\"Control.Apply\"];\n  var Control_Bind = $PS[\"Control.Bind\"];\n  var Control_Category = $PS[\"Control.Category\"];\n  var Control_Monad_Except_Trans = $PS[\"Control.Monad.Except.Trans\"];\n  var Control_Monad_Free_Trans = $PS[\"Control.Monad.Free.Trans\"];\n  var Control_Monad_Rec_Class = $PS[\"Control.Monad.Rec.Class\"];\n  var Control_Monad_Trans_Class = $PS[\"Control.Monad.Trans.Class\"];\n  var Control_Parallel_Class = $PS[\"Control.Parallel.Class\"];\n  var Data_Bifunctor = $PS[\"Data.Bifunctor\"];\n  var Data_Either = $PS[\"Data.Either\"];\n  var Data_Functor = $PS[\"Data.Functor\"];\n  var Data_Identity = $PS[\"Data.Identity\"];\n  var Data_Maybe = $PS[\"Data.Maybe\"];\n  var Data_Newtype = $PS[\"Data.Newtype\"];\n  var Data_Profunctor = $PS[\"Data.Profunctor\"];\n  var Data_Tuple = $PS[\"Data.Tuple\"];\n  var Data_Unit = $PS[\"Data.Unit\"];\n\n  var Emit = function () {\n    function Emit(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n\n    ;\n\n    Emit.create = function (value0) {\n      return function (value1) {\n        return new Emit(value0, value1);\n      };\n    };\n\n    return Emit;\n  }();\n\n  var runProcess = function runProcess(dictMonadRec) {\n    return Control_Monad_Free_Trans.runFreeT(Data_Identity.functorIdentity)(dictMonadRec)(function () {\n      var $176 = Control_Applicative.pure(dictMonadRec.Monad0().Applicative0());\n      var $177 = Data_Newtype.unwrap(Data_Identity.newtypeIdentity);\n      return function ($178) {\n        return $176($177($178));\n      };\n    }());\n  };\n\n  var profunctorAwait = new Data_Profunctor.Profunctor(function (f) {\n    return function (g) {\n      return function (v) {\n        return Data_Profunctor.dimap(Data_Profunctor.profunctorFn)(f)(g)(v);\n      };\n    };\n  });\n\n  var loop = function loop(dictFunctor) {\n    return function (dictMonad) {\n      return function (me) {\n        return Control_Monad_Rec_Class.tailRecM(Control_Monad_Free_Trans.monadRecFreeT(dictFunctor)(dictMonad))(function (v) {\n          return Data_Functor.map(Control_Monad_Free_Trans.functorFreeT(dictFunctor)(dictMonad.Bind1().Apply0().Functor0()))(Data_Maybe.maybe(new Control_Monad_Rec_Class.Loop(Data_Unit.unit))(Control_Monad_Rec_Class.Done.create))(me);\n        })(Data_Unit.unit);\n      };\n    };\n  };\n\n  var fuseWithL = function fuseWithL(dictFunctor) {\n    return function (dictFunctor1) {\n      return function (dictFunctor2) {\n        return function (dictMonadRec) {\n          return function (zap) {\n            return function (fs) {\n              return function (gs) {\n                var go = function go(v) {\n                  return Control_Monad_Except_Trans.runExceptT(Control_Bind.bind(Control_Monad_Except_Trans.bindExceptT(dictMonadRec.Monad0()))(Control_Monad_Except_Trans.ExceptT(Control_Monad_Free_Trans.resume(dictFunctor)(dictMonadRec)(v.value0)))(function (l) {\n                    return Control_Bind.bind(Control_Monad_Except_Trans.bindExceptT(dictMonadRec.Monad0()))(Control_Monad_Except_Trans.ExceptT(Control_Monad_Free_Trans.resume(dictFunctor1)(dictMonadRec)(v.value1)))(function (r) {\n                      return Control_Applicative.pure(Control_Monad_Except_Trans.applicativeExceptT(dictMonadRec.Monad0()))(Data_Functor.map(dictFunctor2)(function (t) {\n                        return Control_Monad_Free_Trans.freeT(function (v1) {\n                          return go(t);\n                        });\n                      })(zap(Data_Tuple.Tuple.create)(l)(r)));\n                    });\n                  }));\n                };\n\n                return Control_Monad_Free_Trans.freeT(function (v) {\n                  return go(new Data_Tuple.Tuple(fs, gs));\n                });\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n\n  var fuseWith = function fuseWith(dictFunctor) {\n    return function (dictFunctor1) {\n      return function (dictFunctor2) {\n        return function (dictMonadRec) {\n          return function (dictParallel) {\n            return function (zap) {\n              return function (fs) {\n                return function (gs) {\n                  var go = function go(v) {\n                    return Control_Bind.bind(dictMonadRec.Monad0().Bind1())(Control_Parallel_Class.sequential(dictParallel)(Control_Apply.apply(dictParallel.Applicative1().Apply0())(Data_Functor.map(dictParallel.Applicative1().Apply0().Functor0())(Control_Apply.lift2(Data_Either.applyEither)(zap(Data_Tuple.Tuple.create)))(Control_Parallel_Class.parallel(dictParallel)(Control_Monad_Free_Trans.resume(dictFunctor)(dictMonadRec)(v.value0))))(Control_Parallel_Class.parallel(dictParallel)(Control_Monad_Free_Trans.resume(dictFunctor1)(dictMonadRec)(v.value1)))))(function (next) {\n                      if (next instanceof Data_Either.Left) {\n                        return Control_Applicative.pure(dictMonadRec.Monad0().Applicative0())(new Data_Either.Left(next.value0));\n                      }\n\n                      ;\n\n                      if (next instanceof Data_Either.Right) {\n                        return Control_Applicative.pure(dictMonadRec.Monad0().Applicative0())(new Data_Either.Right(Data_Functor.map(dictFunctor2)(function (t) {\n                          return Control_Monad_Free_Trans.freeT(function (v1) {\n                            return go(t);\n                          });\n                        })(next.value0)));\n                      }\n\n                      ;\n                      throw new Error(\"Failed pattern match at Control.Coroutine (line 79, column 5 - line 81, column 63): \" + [next.constructor.name]);\n                    });\n                  };\n\n                  return Control_Monad_Free_Trans.freeT(function (v) {\n                    return go(new Data_Tuple.Tuple(fs, gs));\n                  });\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n\n  var functorAwait = new Data_Functor.Functor(Data_Profunctor.rmap(profunctorAwait));\n  var bifunctorEmit = new Data_Bifunctor.Bifunctor(function (f) {\n    return function (g) {\n      return function (v) {\n        return new Emit(f(v.value0), g(v.value1));\n      };\n    };\n  });\n  var functorEmit = new Data_Functor.Functor(Data_Bifunctor.rmap(bifunctorEmit));\n\n  var connect = function connect(dictMonadRec) {\n    return function (dictParallel) {\n      return fuseWith(functorEmit)(functorAwait)(Data_Identity.functorIdentity)(dictMonadRec)(dictParallel)(function (f) {\n        return function (v) {\n          return function (v1) {\n            return f(v.value1)(v1(v.value0));\n          };\n        };\n      });\n    };\n  };\n\n  var emit = function emit(dictMonad) {\n    return function (o) {\n      return Control_Monad_Free_Trans.liftFreeT(functorEmit)(dictMonad)(new Emit(o, Data_Unit.unit));\n    };\n  };\n\n  var producer = function producer(dictMonad) {\n    return function (recv) {\n      return loop(functorEmit)(dictMonad)(Control_Bind.bind(Control_Monad_Free_Trans.bindFreeT(functorEmit)(dictMonad))(Control_Monad_Trans_Class.lift(Control_Monad_Free_Trans.monadTransFreeT(functorEmit))(dictMonad)(recv))(function (e) {\n        if (e instanceof Data_Either.Left) {\n          return Data_Functor.voidLeft(Control_Monad_Free_Trans.functorFreeT(functorEmit)(dictMonad.Bind1().Apply0().Functor0()))(emit(dictMonad)(e.value0))(Data_Maybe.Nothing.value);\n        }\n\n        ;\n\n        if (e instanceof Data_Either.Right) {\n          return Control_Applicative.pure(Control_Monad_Free_Trans.applicativeFreeT(functorEmit)(dictMonad))(new Data_Maybe.Just(e.value0));\n        }\n\n        ;\n        throw new Error(\"Failed pattern match at Control.Coroutine (line 125, column 3 - line 127, column 29): \" + [e.constructor.name]);\n      }));\n    };\n  };\n\n  var pullFrom = function pullFrom(dictMonadRec) {\n    return fuseWithL(functorAwait)(functorEmit)(Data_Identity.functorIdentity)(dictMonadRec)(function (f) {\n      return function (v) {\n        return function (v1) {\n          return Control_Applicative.pure(Data_Identity.applicativeIdentity)(f(v(v1.value0))(v1.value1));\n        };\n      };\n    });\n  };\n\n  var $$await = function $$await(dictMonad) {\n    return Control_Monad_Free_Trans.liftFreeT(functorAwait)(dictMonad)(Control_Category.identity(Control_Category.categoryFn));\n  };\n\n  exports[\"runProcess\"] = runProcess;\n  exports[\"producer\"] = producer;\n  exports[\"await\"] = $$await;\n  exports[\"connect\"] = connect;\n  exports[\"pullFrom\"] = pullFrom;\n  exports[\"functorAwait\"] = functorAwait;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Control.Monad.Error.Class\"] = $PS[\"Control.Monad.Error.Class\"] || {};\n  var exports = $PS[\"Control.Monad.Error.Class\"];\n  var Control_Applicative = $PS[\"Control.Applicative\"];\n  var Data_Either = $PS[\"Data.Either\"];\n  var Data_Functor = $PS[\"Data.Functor\"];\n\n  var MonadThrow = function MonadThrow(Monad0, throwError) {\n    this.Monad0 = Monad0;\n    this.throwError = throwError;\n  };\n\n  var MonadError = function MonadError(MonadThrow0, catchError) {\n    this.MonadThrow0 = MonadThrow0;\n    this.catchError = catchError;\n  };\n\n  var throwError = function throwError(dict) {\n    return dict.throwError;\n  };\n\n  var catchError = function catchError(dict) {\n    return dict.catchError;\n  };\n\n  var $$try = function $$try(dictMonadError) {\n    return function (a) {\n      return catchError(dictMonadError)(Data_Functor.map(dictMonadError.MonadThrow0().Monad0().Bind1().Apply0().Functor0())(Data_Either.Right.create)(a))(function () {\n        var $17 = Control_Applicative.pure(dictMonadError.MonadThrow0().Monad0().Applicative0());\n        return function ($18) {\n          return $17(Data_Either.Left.create($18));\n        };\n      }());\n    };\n  };\n\n  exports[\"throwError\"] = throwError;\n  exports[\"MonadThrow\"] = MonadThrow;\n  exports[\"MonadError\"] = MonadError;\n  exports[\"try\"] = $$try;\n})(PS);\n\n(function (exports) {\n  /* globals setImmediate, clearImmediate, setTimeout, clearTimeout */\n\n  /* jshint -W083, -W098, -W003 */\n  \"use strict\";\n\n  var Aff = function () {\n    // A unique value for empty.\n    var EMPTY = {};\n    /*\n    An awkward approximation. We elide evidence we would otherwise need in PS for\n    efficiency sake.\n    data Aff eff a\n    = Pure a\n    | Throw Error\n    | Catch (Aff eff a) (Error -> Aff eff a)\n    | Sync (Eff eff a)\n    | Async ((Either Error a -> Eff eff Unit) -> Eff eff (Canceler eff))\n    | forall b. Bind (Aff eff b) (b -> Aff eff a)\n    | forall b. Bracket (Aff eff b) (BracketConditions eff b) (b -> Aff eff a)\n    | forall b. Fork Boolean (Aff eff b) ?(Fiber eff b -> a)\n    | Sequential (ParAff aff a)\n    */\n\n    var PURE = \"Pure\";\n    var THROW = \"Throw\";\n    var CATCH = \"Catch\";\n    var SYNC = \"Sync\";\n    var ASYNC = \"Async\";\n    var BIND = \"Bind\";\n    var BRACKET = \"Bracket\";\n    var FORK = \"Fork\";\n    var SEQ = \"Sequential\";\n    /*\n    data ParAff eff a\n    = forall b. Map (b -> a) (ParAff eff b)\n    | forall b. Apply (ParAff eff (b -> a)) (ParAff eff b)\n    | Alt (ParAff eff a) (ParAff eff a)\n    | ?Par (Aff eff a)\n    */\n\n    var MAP = \"Map\";\n    var APPLY = \"Apply\";\n    var ALT = \"Alt\"; // Various constructors used in interpretation\n\n    var CONS = \"Cons\"; // Cons-list, for stacks\n\n    var RESUME = \"Resume\"; // Continue indiscriminately\n\n    var RELEASE = \"Release\"; // Continue with bracket finalizers\n\n    var FINALIZER = \"Finalizer\"; // A non-interruptible effect\n\n    var FINALIZED = \"Finalized\"; // Marker for finalization\n\n    var FORKED = \"Forked\"; // Reference to a forked fiber, with resumption stack\n\n    var FIBER = \"Fiber\"; // Actual fiber reference\n\n    var THUNK = \"Thunk\"; // Primed effect, ready to invoke\n\n    function Aff(tag, _1, _2, _3) {\n      this.tag = tag;\n      this._1 = _1;\n      this._2 = _2;\n      this._3 = _3;\n    }\n\n    function AffCtr(tag) {\n      var fn = function fn(_1, _2, _3) {\n        return new Aff(tag, _1, _2, _3);\n      };\n\n      fn.tag = tag;\n      return fn;\n    }\n\n    function nonCanceler(error) {\n      return new Aff(PURE, void 0);\n    }\n\n    function runEff(eff) {\n      try {\n        eff();\n      } catch (error) {\n        setTimeout(function () {\n          throw error;\n        }, 0);\n      }\n    }\n\n    function runSync(left, right, eff) {\n      try {\n        return right(eff());\n      } catch (error) {\n        return left(error);\n      }\n    }\n\n    function runAsync(left, eff, k) {\n      try {\n        return eff(k)();\n      } catch (error) {\n        k(left(error))();\n        return nonCanceler;\n      }\n    }\n\n    var Scheduler = function () {\n      var limit = 1024;\n      var size = 0;\n      var ix = 0;\n      var queue = new Array(limit);\n      var draining = false;\n\n      function drain() {\n        var thunk;\n        draining = true;\n\n        while (size !== 0) {\n          size--;\n          thunk = queue[ix];\n          queue[ix] = void 0;\n          ix = (ix + 1) % limit;\n          thunk();\n        }\n\n        draining = false;\n      }\n\n      return {\n        isDraining: function isDraining() {\n          return draining;\n        },\n        enqueue: function enqueue(cb) {\n          var i, tmp;\n\n          if (size === limit) {\n            tmp = draining;\n            drain();\n            draining = tmp;\n          }\n\n          queue[(ix + size) % limit] = cb;\n          size++;\n\n          if (!draining) {\n            drain();\n          }\n        }\n      };\n    }();\n\n    function Supervisor(util) {\n      var fibers = {};\n      var fiberId = 0;\n      var count = 0;\n      return {\n        register: function register(fiber) {\n          var fid = fiberId++;\n          fiber.onComplete({\n            rethrow: true,\n            handler: function handler(result) {\n              return function () {\n                count--;\n                delete fibers[fid];\n              };\n            }\n          })();\n          fibers[fid] = fiber;\n          count++;\n        },\n        isEmpty: function isEmpty() {\n          return count === 0;\n        },\n        killAll: function killAll(killError, cb) {\n          return function () {\n            if (count === 0) {\n              return cb();\n            }\n\n            var killCount = 0;\n            var kills = {};\n\n            function kill(fid) {\n              kills[fid] = fibers[fid].kill(killError, function (result) {\n                return function () {\n                  delete kills[fid];\n                  killCount--;\n\n                  if (util.isLeft(result) && util.fromLeft(result)) {\n                    setTimeout(function () {\n                      throw util.fromLeft(result);\n                    }, 0);\n                  }\n\n                  if (killCount === 0) {\n                    cb();\n                  }\n                };\n              })();\n            }\n\n            for (var k in fibers) {\n              if (fibers.hasOwnProperty(k)) {\n                killCount++;\n                kill(k);\n              }\n            }\n\n            fibers = {};\n            fiberId = 0;\n            count = 0;\n            return function (error) {\n              return new Aff(SYNC, function () {\n                for (var k in kills) {\n                  if (kills.hasOwnProperty(k)) {\n                    kills[k]();\n                  }\n                }\n              });\n            };\n          };\n        }\n      };\n    } // Fiber state machine\n\n\n    var SUSPENDED = 0; // Suspended, pending a join.\n\n    var CONTINUE = 1; // Interpret the next instruction.\n\n    var STEP_BIND = 2; // Apply the next bind.\n\n    var STEP_RESULT = 3; // Handle potential failure from a result.\n\n    var PENDING = 4; // An async effect is running.\n\n    var RETURN = 5; // The current stack has returned.\n\n    var COMPLETED = 6; // The entire fiber has completed.\n\n    function Fiber(util, supervisor, aff) {\n      // Monotonically increasing tick, increased on each asynchronous turn.\n      var runTick = 0; // The current branch of the state machine.\n\n      var status = SUSPENDED; // The current point of interest for the state machine branch.\n\n      var step = aff; // Successful step\n\n      var fail = null; // Failure step\n\n      var interrupt = null; // Asynchronous interrupt\n      // Stack of continuations for the current fiber.\n\n      var bhead = null;\n      var btail = null; // Stack of attempts and finalizers for error recovery. Every `Cons` is also\n      // tagged with current `interrupt` state. We use this to track which items\n      // should be ignored or evaluated as a result of a kill.\n\n      var attempts = null; // A special state is needed for Bracket, because it cannot be killed. When\n      // we enter a bracket acquisition or finalizer, we increment the counter,\n      // and then decrement once complete.\n\n      var bracketCount = 0; // Each join gets a new id so they can be revoked.\n\n      var joinId = 0;\n      var joins = null;\n      var rethrow = true; // Each invocation of `run` requires a tick. When an asynchronous effect is\n      // resolved, we must check that the local tick coincides with the fiber\n      // tick before resuming. This prevents multiple async continuations from\n      // accidentally resuming the same fiber. A common example may be invoking\n      // the provided callback in `makeAff` more than once, but it may also be an\n      // async effect resuming after the fiber was already cancelled.\n\n      function _run(localRunTick) {\n        var tmp, result, attempt;\n\n        while (true) {\n          tmp = null;\n          result = null;\n          attempt = null;\n\n          switch (status) {\n            case STEP_BIND:\n              status = CONTINUE;\n\n              try {\n                step = bhead(step);\n\n                if (btail === null) {\n                  bhead = null;\n                } else {\n                  bhead = btail._1;\n                  btail = btail._2;\n                }\n              } catch (e) {\n                status = RETURN;\n                fail = util.left(e);\n                step = null;\n              }\n\n              break;\n\n            case STEP_RESULT:\n              if (util.isLeft(step)) {\n                status = RETURN;\n                fail = step;\n                step = null;\n              } else if (bhead === null) {\n                status = RETURN;\n              } else {\n                status = STEP_BIND;\n                step = util.fromRight(step);\n              }\n\n              break;\n\n            case CONTINUE:\n              switch (step.tag) {\n                case BIND:\n                  if (bhead) {\n                    btail = new Aff(CONS, bhead, btail);\n                  }\n\n                  bhead = step._2;\n                  status = CONTINUE;\n                  step = step._1;\n                  break;\n\n                case PURE:\n                  if (bhead === null) {\n                    status = RETURN;\n                    step = util.right(step._1);\n                  } else {\n                    status = STEP_BIND;\n                    step = step._1;\n                  }\n\n                  break;\n\n                case SYNC:\n                  status = STEP_RESULT;\n                  step = runSync(util.left, util.right, step._1);\n                  break;\n\n                case ASYNC:\n                  status = PENDING;\n                  step = runAsync(util.left, step._1, function (result) {\n                    return function () {\n                      if (runTick !== localRunTick) {\n                        return;\n                      }\n\n                      runTick++;\n                      Scheduler.enqueue(function () {\n                        // It's possible to interrupt the fiber between enqueuing and\n                        // resuming, so we need to check that the runTick is still\n                        // valid.\n                        if (runTick !== localRunTick + 1) {\n                          return;\n                        }\n\n                        status = STEP_RESULT;\n                        step = result;\n\n                        _run(runTick);\n                      });\n                    };\n                  });\n                  return;\n\n                case THROW:\n                  status = RETURN;\n                  fail = util.left(step._1);\n                  step = null;\n                  break;\n                // Enqueue the Catch so that we can call the error handler later on\n                // in case of an exception.\n\n                case CATCH:\n                  if (bhead === null) {\n                    attempts = new Aff(CONS, step, attempts, interrupt);\n                  } else {\n                    attempts = new Aff(CONS, step, new Aff(CONS, new Aff(RESUME, bhead, btail), attempts, interrupt), interrupt);\n                  }\n\n                  bhead = null;\n                  btail = null;\n                  status = CONTINUE;\n                  step = step._1;\n                  break;\n                // Enqueue the Bracket so that we can call the appropriate handlers\n                // after resource acquisition.\n\n                case BRACKET:\n                  bracketCount++;\n\n                  if (bhead === null) {\n                    attempts = new Aff(CONS, step, attempts, interrupt);\n                  } else {\n                    attempts = new Aff(CONS, step, new Aff(CONS, new Aff(RESUME, bhead, btail), attempts, interrupt), interrupt);\n                  }\n\n                  bhead = null;\n                  btail = null;\n                  status = CONTINUE;\n                  step = step._1;\n                  break;\n\n                case FORK:\n                  status = STEP_RESULT;\n                  tmp = Fiber(util, supervisor, step._2);\n\n                  if (supervisor) {\n                    supervisor.register(tmp);\n                  }\n\n                  if (step._1) {\n                    tmp.run();\n                  }\n\n                  step = util.right(tmp);\n                  break;\n\n                case SEQ:\n                  status = CONTINUE;\n                  step = sequential(util, supervisor, step._1);\n                  break;\n              }\n\n              break;\n\n            case RETURN:\n              bhead = null;\n              btail = null; // If the current stack has returned, and we have no other stacks to\n              // resume or finalizers to run, the fiber has halted and we can\n              // invoke all join callbacks. Otherwise we need to resume.\n\n              if (attempts === null) {\n                status = COMPLETED;\n                step = interrupt || fail || step;\n              } else {\n                // The interrupt status for the enqueued item.\n                tmp = attempts._3;\n                attempt = attempts._1;\n                attempts = attempts._2;\n\n                switch (attempt.tag) {\n                  // We cannot recover from an unmasked interrupt. Otherwise we should\n                  // continue stepping, or run the exception handler if an exception\n                  // was raised.\n                  case CATCH:\n                    // We should compare the interrupt status as well because we\n                    // only want it to apply if there has been an interrupt since\n                    // enqueuing the catch.\n                    if (interrupt && interrupt !== tmp && bracketCount === 0) {\n                      status = RETURN;\n                    } else if (fail) {\n                      status = CONTINUE;\n                      step = attempt._2(util.fromLeft(fail));\n                      fail = null;\n                    }\n\n                    break;\n                  // We cannot resume from an unmasked interrupt or exception.\n\n                  case RESUME:\n                    // As with Catch, we only want to ignore in the case of an\n                    // interrupt since enqueing the item.\n                    if (interrupt && interrupt !== tmp && bracketCount === 0 || fail) {\n                      status = RETURN;\n                    } else {\n                      bhead = attempt._1;\n                      btail = attempt._2;\n                      status = STEP_BIND;\n                      step = util.fromRight(step);\n                    }\n\n                    break;\n                  // If we have a bracket, we should enqueue the handlers,\n                  // and continue with the success branch only if the fiber has\n                  // not been interrupted. If the bracket acquisition failed, we\n                  // should not run either.\n\n                  case BRACKET:\n                    bracketCount--;\n\n                    if (fail === null) {\n                      result = util.fromRight(step); // We need to enqueue the Release with the same interrupt\n                      // status as the Bracket that is initiating it.\n\n                      attempts = new Aff(CONS, new Aff(RELEASE, attempt._2, result), attempts, tmp); // We should only coninue as long as the interrupt status has not changed or\n                      // we are currently within a non-interruptable finalizer.\n\n                      if (interrupt === tmp || bracketCount > 0) {\n                        status = CONTINUE;\n                        step = attempt._3(result);\n                      }\n                    }\n\n                    break;\n                  // Enqueue the appropriate handler. We increase the bracket count\n                  // because it should not be cancelled.\n\n                  case RELEASE:\n                    attempts = new Aff(CONS, new Aff(FINALIZED, step, fail), attempts, interrupt);\n                    status = CONTINUE; // It has only been killed if the interrupt status has changed\n                    // since we enqueued the item, and the bracket count is 0. If the\n                    // bracket count is non-zero then we are in a masked state so it's\n                    // impossible to be killed.\n\n                    if (interrupt && interrupt !== tmp && bracketCount === 0) {\n                      step = attempt._1.killed(util.fromLeft(interrupt))(attempt._2);\n                    } else if (fail) {\n                      step = attempt._1.failed(util.fromLeft(fail))(attempt._2);\n                    } else {\n                      step = attempt._1.completed(util.fromRight(step))(attempt._2);\n                    }\n\n                    fail = null;\n                    bracketCount++;\n                    break;\n\n                  case FINALIZER:\n                    bracketCount++;\n                    attempts = new Aff(CONS, new Aff(FINALIZED, step, fail), attempts, interrupt);\n                    status = CONTINUE;\n                    step = attempt._1;\n                    break;\n\n                  case FINALIZED:\n                    bracketCount--;\n                    status = RETURN;\n                    step = attempt._1;\n                    fail = attempt._2;\n                    break;\n                }\n              }\n\n              break;\n\n            case COMPLETED:\n              for (var k in joins) {\n                if (joins.hasOwnProperty(k)) {\n                  rethrow = rethrow && joins[k].rethrow;\n                  runEff(joins[k].handler(step));\n                }\n              }\n\n              joins = null; // If we have an interrupt and a fail, then the thread threw while\n              // running finalizers. This should always rethrow in a fresh stack.\n\n              if (interrupt && fail) {\n                setTimeout(function () {\n                  throw util.fromLeft(fail);\n                }, 0); // If we have an unhandled exception, and no other fiber has joined\n                // then we need to throw the exception in a fresh stack.\n              } else if (util.isLeft(step) && rethrow) {\n                setTimeout(function () {\n                  // Guard on reathrow because a completely synchronous fiber can\n                  // still have an observer which was added after-the-fact.\n                  if (rethrow) {\n                    throw util.fromLeft(step);\n                  }\n                }, 0);\n              }\n\n              return;\n\n            case SUSPENDED:\n              status = CONTINUE;\n              break;\n\n            case PENDING:\n              return;\n          }\n        }\n      }\n\n      function onComplete(join) {\n        return function () {\n          if (status === COMPLETED) {\n            rethrow = rethrow && join.rethrow;\n            join.handler(step)();\n            return function () {};\n          }\n\n          var jid = joinId++;\n          joins = joins || {};\n          joins[jid] = join;\n          return function () {\n            if (joins !== null) {\n              delete joins[jid];\n            }\n          };\n        };\n      }\n\n      function kill(error, cb) {\n        return function () {\n          if (status === COMPLETED) {\n            cb(util.right(void 0))();\n            return function () {};\n          }\n\n          var canceler = onComplete({\n            rethrow: false,\n            handler: function handler()\n            /* unused */\n            {\n              return cb(util.right(void 0));\n            }\n          })();\n\n          switch (status) {\n            case SUSPENDED:\n              interrupt = util.left(error);\n              status = COMPLETED;\n              step = interrupt;\n\n              _run(runTick);\n\n              break;\n\n            case PENDING:\n              if (interrupt === null) {\n                interrupt = util.left(error);\n              }\n\n              if (bracketCount === 0) {\n                if (status === PENDING) {\n                  attempts = new Aff(CONS, new Aff(FINALIZER, step(error)), attempts, interrupt);\n                }\n\n                status = RETURN;\n                step = null;\n                fail = null;\n\n                _run(++runTick);\n              }\n\n              break;\n\n            default:\n              if (interrupt === null) {\n                interrupt = util.left(error);\n              }\n\n              if (bracketCount === 0) {\n                status = RETURN;\n                step = null;\n                fail = null;\n              }\n\n          }\n\n          return canceler;\n        };\n      }\n\n      function join(cb) {\n        return function () {\n          var canceler = onComplete({\n            rethrow: false,\n            handler: cb\n          })();\n\n          if (status === SUSPENDED) {\n            _run(runTick);\n          }\n\n          return canceler;\n        };\n      }\n\n      return {\n        kill: kill,\n        join: join,\n        onComplete: onComplete,\n        isSuspended: function isSuspended() {\n          return status === SUSPENDED;\n        },\n        run: function run() {\n          if (status === SUSPENDED) {\n            if (!Scheduler.isDraining()) {\n              Scheduler.enqueue(function () {\n                _run(runTick);\n              });\n            } else {\n              _run(runTick);\n            }\n          }\n        }\n      };\n    }\n\n    function runPar(util, supervisor, par, cb) {\n      // Table of all forked fibers.\n      var fiberId = 0;\n      var fibers = {}; // Table of currently running cancelers, as a product of `Alt` behavior.\n\n      var killId = 0;\n      var kills = {}; // Error used for early cancelation on Alt branches.\n\n      var early = new Error(\"[ParAff] Early exit\"); // Error used to kill the entire tree.\n\n      var interrupt = null; // The root pointer of the tree.\n\n      var root = EMPTY; // Walks a tree, invoking all the cancelers. Returns the table of pending\n      // cancellation fibers.\n\n      function kill(error, par, cb) {\n        var step = par;\n        var head = null;\n        var tail = null;\n        var count = 0;\n        var kills = {};\n        var tmp, kid;\n\n        loop: while (true) {\n          tmp = null;\n\n          switch (step.tag) {\n            case FORKED:\n              if (step._3 === EMPTY) {\n                tmp = fibers[step._1];\n                kills[count++] = tmp.kill(error, function (result) {\n                  return function () {\n                    count--;\n\n                    if (count === 0) {\n                      cb(result)();\n                    }\n                  };\n                });\n              } // Terminal case.\n\n\n              if (head === null) {\n                break loop;\n              } // Go down the right side of the tree.\n\n\n              step = head._2;\n\n              if (tail === null) {\n                head = null;\n              } else {\n                head = tail._1;\n                tail = tail._2;\n              }\n\n              break;\n\n            case MAP:\n              step = step._2;\n              break;\n\n            case APPLY:\n            case ALT:\n              if (head) {\n                tail = new Aff(CONS, head, tail);\n              }\n\n              head = step;\n              step = step._1;\n              break;\n          }\n        }\n\n        if (count === 0) {\n          cb(util.right(void 0))();\n        } else {\n          // Run the cancelation effects. We alias `count` because it's mutable.\n          kid = 0;\n          tmp = count;\n\n          for (; kid < tmp; kid++) {\n            kills[kid] = kills[kid]();\n          }\n        }\n\n        return kills;\n      } // When a fiber resolves, we need to bubble back up the tree with the\n      // result, computing the applicative nodes.\n\n\n      function join(result, head, tail) {\n        var fail, step, lhs, rhs, tmp, kid;\n\n        if (util.isLeft(result)) {\n          fail = result;\n          step = null;\n        } else {\n          step = result;\n          fail = null;\n        }\n\n        loop: while (true) {\n          lhs = null;\n          rhs = null;\n          tmp = null;\n          kid = null; // We should never continue if the entire tree has been interrupted.\n\n          if (interrupt !== null) {\n            return;\n          } // We've made it all the way to the root of the tree, which means\n          // the tree has fully evaluated.\n\n\n          if (head === null) {\n            cb(fail || step)();\n            return;\n          } // The tree has already been computed, so we shouldn't try to do it\n          // again. This should never happen.\n          // TODO: Remove this?\n\n\n          if (head._3 !== EMPTY) {\n            return;\n          }\n\n          switch (head.tag) {\n            case MAP:\n              if (fail === null) {\n                head._3 = util.right(head._1(util.fromRight(step)));\n                step = head._3;\n              } else {\n                head._3 = fail;\n              }\n\n              break;\n\n            case APPLY:\n              lhs = head._1._3;\n              rhs = head._2._3; // If we have a failure we should kill the other side because we\n              // can't possible yield a result anymore.\n\n              if (fail) {\n                head._3 = fail;\n                tmp = true;\n                kid = killId++;\n                kills[kid] = kill(early, fail === lhs ? head._2 : head._1, function ()\n                /* unused */\n                {\n                  return function () {\n                    delete kills[kid];\n\n                    if (tmp) {\n                      tmp = false;\n                    } else if (tail === null) {\n                      join(fail, null, null);\n                    } else {\n                      join(fail, tail._1, tail._2);\n                    }\n                  };\n                });\n\n                if (tmp) {\n                  tmp = false;\n                  return;\n                }\n              } else if (lhs === EMPTY || rhs === EMPTY) {\n                // We can only proceed if both sides have resolved.\n                return;\n              } else {\n                step = util.right(util.fromRight(lhs)(util.fromRight(rhs)));\n                head._3 = step;\n              }\n\n              break;\n\n            case ALT:\n              lhs = head._1._3;\n              rhs = head._2._3; // We can only proceed if both have resolved or we have a success\n\n              if (lhs === EMPTY && util.isLeft(rhs) || rhs === EMPTY && util.isLeft(lhs)) {\n                return;\n              } // If both sides resolve with an error, we should continue with the\n              // first error\n\n\n              if (lhs !== EMPTY && util.isLeft(lhs) && rhs !== EMPTY && util.isLeft(rhs)) {\n                fail = step === lhs ? rhs : lhs;\n                step = null;\n                head._3 = fail;\n              } else {\n                head._3 = step;\n                tmp = true;\n                kid = killId++; // Once a side has resolved, we need to cancel the side that is still\n                // pending before we can continue.\n\n                kills[kid] = kill(early, step === lhs ? head._2 : head._1, function ()\n                /* unused */\n                {\n                  return function () {\n                    delete kills[kid];\n\n                    if (tmp) {\n                      tmp = false;\n                    } else if (tail === null) {\n                      join(step, null, null);\n                    } else {\n                      join(step, tail._1, tail._2);\n                    }\n                  };\n                });\n\n                if (tmp) {\n                  tmp = false;\n                  return;\n                }\n              }\n\n              break;\n          }\n\n          if (tail === null) {\n            head = null;\n          } else {\n            head = tail._1;\n            tail = tail._2;\n          }\n        }\n      }\n\n      function resolve(fiber) {\n        return function (result) {\n          return function () {\n            delete fibers[fiber._1];\n            fiber._3 = result;\n            join(result, fiber._2._1, fiber._2._2);\n          };\n        };\n      } // Walks the applicative tree, substituting non-applicative nodes with\n      // `FORKED` nodes. In this tree, all applicative nodes use the `_3` slot\n      // as a mutable slot for memoization. In an unresolved state, the `_3`\n      // slot is `EMPTY`. In the cases of `ALT` and `APPLY`, we always walk\n      // the left side first, because both operations are left-associative. As\n      // we `RETURN` from those branches, we then walk the right side.\n\n\n      function run() {\n        var status = CONTINUE;\n        var step = par;\n        var head = null;\n        var tail = null;\n        var tmp, fid;\n\n        loop: while (true) {\n          tmp = null;\n          fid = null;\n\n          switch (status) {\n            case CONTINUE:\n              switch (step.tag) {\n                case MAP:\n                  if (head) {\n                    tail = new Aff(CONS, head, tail);\n                  }\n\n                  head = new Aff(MAP, step._1, EMPTY, EMPTY);\n                  step = step._2;\n                  break;\n\n                case APPLY:\n                  if (head) {\n                    tail = new Aff(CONS, head, tail);\n                  }\n\n                  head = new Aff(APPLY, EMPTY, step._2, EMPTY);\n                  step = step._1;\n                  break;\n\n                case ALT:\n                  if (head) {\n                    tail = new Aff(CONS, head, tail);\n                  }\n\n                  head = new Aff(ALT, EMPTY, step._2, EMPTY);\n                  step = step._1;\n                  break;\n\n                default:\n                  // When we hit a leaf value, we suspend the stack in the `FORKED`.\n                  // When the fiber resolves, it can bubble back up the tree.\n                  fid = fiberId++;\n                  status = RETURN;\n                  tmp = step;\n                  step = new Aff(FORKED, fid, new Aff(CONS, head, tail), EMPTY);\n                  tmp = Fiber(util, supervisor, tmp);\n                  tmp.onComplete({\n                    rethrow: false,\n                    handler: resolve(step)\n                  })();\n                  fibers[fid] = tmp;\n\n                  if (supervisor) {\n                    supervisor.register(tmp);\n                  }\n\n              }\n\n              break;\n\n            case RETURN:\n              // Terminal case, we are back at the root.\n              if (head === null) {\n                break loop;\n              } // If we are done with the right side, we need to continue down the\n              // left. Otherwise we should continue up the stack.\n\n\n              if (head._1 === EMPTY) {\n                head._1 = step;\n                status = CONTINUE;\n                step = head._2;\n                head._2 = EMPTY;\n              } else {\n                head._2 = step;\n                step = head;\n\n                if (tail === null) {\n                  head = null;\n                } else {\n                  head = tail._1;\n                  tail = tail._2;\n                }\n              }\n\n          }\n        } // Keep a reference to the tree root so it can be cancelled.\n\n\n        root = step;\n\n        for (fid = 0; fid < fiberId; fid++) {\n          fibers[fid].run();\n        }\n      } // Cancels the entire tree. If there are already subtrees being canceled,\n      // we need to first cancel those joins. We will then add fresh joins for\n      // all pending branches including those that were in the process of being\n      // canceled.\n\n\n      function cancel(error, cb) {\n        interrupt = util.left(error);\n        var innerKills;\n\n        for (var kid in kills) {\n          if (kills.hasOwnProperty(kid)) {\n            innerKills = kills[kid];\n\n            for (kid in innerKills) {\n              if (innerKills.hasOwnProperty(kid)) {\n                innerKills[kid]();\n              }\n            }\n          }\n        }\n\n        kills = null;\n        var newKills = kill(error, root, cb);\n        return function (killError) {\n          return new Aff(ASYNC, function (killCb) {\n            return function () {\n              for (var kid in newKills) {\n                if (newKills.hasOwnProperty(kid)) {\n                  newKills[kid]();\n                }\n              }\n\n              return nonCanceler;\n            };\n          });\n        };\n      }\n\n      run();\n      return function (killError) {\n        return new Aff(ASYNC, function (killCb) {\n          return function () {\n            return cancel(killError, killCb);\n          };\n        });\n      };\n    }\n\n    function sequential(util, supervisor, par) {\n      return new Aff(ASYNC, function (cb) {\n        return function () {\n          return runPar(util, supervisor, par, cb);\n        };\n      });\n    }\n\n    Aff.EMPTY = EMPTY;\n    Aff.Pure = AffCtr(PURE);\n    Aff.Throw = AffCtr(THROW);\n    Aff.Catch = AffCtr(CATCH);\n    Aff.Sync = AffCtr(SYNC);\n    Aff.Async = AffCtr(ASYNC);\n    Aff.Bind = AffCtr(BIND);\n    Aff.Bracket = AffCtr(BRACKET);\n    Aff.Fork = AffCtr(FORK);\n    Aff.Seq = AffCtr(SEQ);\n    Aff.ParMap = AffCtr(MAP);\n    Aff.ParApply = AffCtr(APPLY);\n    Aff.ParAlt = AffCtr(ALT);\n    Aff.Fiber = Fiber;\n    Aff.Supervisor = Supervisor;\n    Aff.Scheduler = Scheduler;\n    Aff.nonCanceler = nonCanceler;\n    return Aff;\n  }();\n\n  exports._pure = Aff.Pure;\n  exports._throwError = Aff.Throw;\n\n  exports._catchError = function (aff) {\n    return function (k) {\n      return Aff.Catch(aff, k);\n    };\n  };\n\n  exports._map = function (f) {\n    return function (aff) {\n      if (aff.tag === Aff.Pure.tag) {\n        return Aff.Pure(f(aff._1));\n      } else {\n        return Aff.Bind(aff, function (value) {\n          return Aff.Pure(f(value));\n        });\n      }\n    };\n  };\n\n  exports._bind = function (aff) {\n    return function (k) {\n      return Aff.Bind(aff, k);\n    };\n  };\n\n  exports._fork = function (immediate) {\n    return function (aff) {\n      return Aff.Fork(immediate, aff);\n    };\n  };\n\n  exports._liftEffect = Aff.Sync;\n\n  exports._parAffMap = function (f) {\n    return function (aff) {\n      return Aff.ParMap(f, aff);\n    };\n  };\n\n  exports._parAffApply = function (aff1) {\n    return function (aff2) {\n      return Aff.ParApply(aff1, aff2);\n    };\n  };\n\n  exports.makeAff = Aff.Async;\n\n  exports.generalBracket = function (acquire) {\n    return function (options) {\n      return function (k) {\n        return Aff.Bracket(acquire, options, k);\n      };\n    };\n  };\n\n  exports._makeFiber = function (util, aff) {\n    return function () {\n      return Aff.Fiber(util, null, aff);\n    };\n  };\n\n  exports._sequential = Aff.Seq;\n})(PS[\"Effect.Aff\"] = PS[\"Effect.Aff\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Effect.Class\"] = $PS[\"Effect.Class\"] || {};\n  var exports = $PS[\"Effect.Class\"];\n  var Control_Category = $PS[\"Control.Category\"];\n  var Effect = $PS[\"Effect\"];\n\n  var MonadEffect = function MonadEffect(Monad0, liftEffect) {\n    this.Monad0 = Monad0;\n    this.liftEffect = liftEffect;\n  };\n\n  var monadEffectEffect = new MonadEffect(function () {\n    return Effect.monadEffect;\n  }, Control_Category.identity(Control_Category.categoryFn));\n\n  var liftEffect = function liftEffect(dict) {\n    return dict.liftEffect;\n  };\n\n  exports[\"liftEffect\"] = liftEffect;\n  exports[\"MonadEffect\"] = MonadEffect;\n  exports[\"monadEffectEffect\"] = monadEffectEffect;\n})(PS);\n\n(function (exports) {\n  \"use strict\";\n\n  exports.unsafePerformEffect = function (f) {\n    return f();\n  };\n})(PS[\"Effect.Unsafe\"] = PS[\"Effect.Unsafe\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Effect.Unsafe\"] = $PS[\"Effect.Unsafe\"] || {};\n  var exports = $PS[\"Effect.Unsafe\"];\n  var $foreign = $PS[\"Effect.Unsafe\"];\n  exports[\"unsafePerformEffect\"] = $foreign.unsafePerformEffect;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Effect.Aff\"] = $PS[\"Effect.Aff\"] || {};\n  var exports = $PS[\"Effect.Aff\"];\n  var $foreign = $PS[\"Effect.Aff\"];\n  var Control_Applicative = $PS[\"Control.Applicative\"];\n  var Control_Apply = $PS[\"Control.Apply\"];\n  var Control_Bind = $PS[\"Control.Bind\"];\n  var Control_Monad = $PS[\"Control.Monad\"];\n  var Control_Monad_Error_Class = $PS[\"Control.Monad.Error.Class\"];\n  var Control_Monad_Rec_Class = $PS[\"Control.Monad.Rec.Class\"];\n  var Control_Parallel_Class = $PS[\"Control.Parallel.Class\"];\n  var Data_Either = $PS[\"Data.Either\"];\n  var Data_Function = $PS[\"Data.Function\"];\n  var Data_Functor = $PS[\"Data.Functor\"];\n  var Data_Unit = $PS[\"Data.Unit\"];\n  var Effect = $PS[\"Effect\"];\n  var Effect_Class = $PS[\"Effect.Class\"];\n  var Effect_Unsafe = $PS[\"Effect.Unsafe\"];\n  var Partial_Unsafe = $PS[\"Partial.Unsafe\"];\n  var Unsafe_Coerce = $PS[\"Unsafe.Coerce\"];\n\n  var Canceler = function Canceler(x) {\n    return x;\n  };\n\n  var suspendAff = $foreign[\"_fork\"](false);\n  var functorParAff = new Data_Functor.Functor($foreign[\"_parAffMap\"]);\n  var functorAff = new Data_Functor.Functor($foreign[\"_map\"]);\n  var forkAff = $foreign[\"_fork\"](true);\n\n  var ffiUtil = function () {\n    var unsafeFromRight = function unsafeFromRight(v) {\n      if (v instanceof Data_Either.Right) {\n        return v.value0;\n      }\n\n      ;\n\n      if (v instanceof Data_Either.Left) {\n        return Partial_Unsafe.unsafeCrashWith(\"unsafeFromRight: Left\");\n      }\n\n      ;\n      throw new Error(\"Failed pattern match at Effect.Aff (line 400, column 21 - line 402, column 54): \" + [v.constructor.name]);\n    };\n\n    var unsafeFromLeft = function unsafeFromLeft(v) {\n      if (v instanceof Data_Either.Left) {\n        return v.value0;\n      }\n\n      ;\n\n      if (v instanceof Data_Either.Right) {\n        return Partial_Unsafe.unsafeCrashWith(\"unsafeFromLeft: Right\");\n      }\n\n      ;\n      throw new Error(\"Failed pattern match at Effect.Aff (line 395, column 20 - line 397, column 54): \" + [v.constructor.name]);\n    };\n\n    var isLeft = function isLeft(v) {\n      if (v instanceof Data_Either.Left) {\n        return true;\n      }\n\n      ;\n\n      if (v instanceof Data_Either.Right) {\n        return false;\n      }\n\n      ;\n      throw new Error(\"Failed pattern match at Effect.Aff (line 390, column 12 - line 392, column 20): \" + [v.constructor.name]);\n    };\n\n    return {\n      isLeft: isLeft,\n      fromLeft: unsafeFromLeft,\n      fromRight: unsafeFromRight,\n      left: Data_Either.Left.create,\n      right: Data_Either.Right.create\n    };\n  }();\n\n  var makeFiber = function makeFiber(aff) {\n    return $foreign[\"_makeFiber\"](ffiUtil, aff);\n  };\n\n  var launchAff = function launchAff(aff) {\n    return function __do() {\n      var fiber = makeFiber(aff)();\n      fiber.run();\n      return fiber;\n    };\n  };\n\n  var launchAff_ = function () {\n    var $43 = Data_Functor[\"void\"](Effect.functorEffect);\n    return function ($44) {\n      return $43(launchAff($44));\n    };\n  }();\n\n  var bracket = function bracket(acquire) {\n    return function (completed) {\n      return $foreign.generalBracket(acquire)({\n        killed: Data_Function[\"const\"](completed),\n        failed: Data_Function[\"const\"](completed),\n        completed: Data_Function[\"const\"](completed)\n      });\n    };\n  };\n\n  var applyParAff = new Control_Apply.Apply(function () {\n    return functorParAff;\n  }, $foreign[\"_parAffApply\"]);\n  var monadAff = new Control_Monad.Monad(function () {\n    return applicativeAff;\n  }, function () {\n    return bindAff;\n  });\n  var bindAff = new Control_Bind.Bind(function () {\n    return applyAff;\n  }, $foreign[\"_bind\"]);\n  var applyAff = new Control_Apply.Apply(function () {\n    return functorAff;\n  }, Control_Monad.ap(monadAff));\n  var applicativeAff = new Control_Applicative.Applicative(function () {\n    return applyAff;\n  }, $foreign[\"_pure\"]);\n\n  var $$finally = function $$finally(fin) {\n    return function (a) {\n      return bracket(Control_Applicative.pure(applicativeAff)(Data_Unit.unit))(Data_Function[\"const\"](fin))(Data_Function[\"const\"](a));\n    };\n  };\n\n  var monadEffectAff = new Effect_Class.MonadEffect(function () {\n    return monadAff;\n  }, $foreign[\"_liftEffect\"]);\n\n  var effectCanceler = function () {\n    var $45 = Effect_Class.liftEffect(monadEffectAff);\n    return function ($46) {\n      return Canceler(Data_Function[\"const\"]($45($46)));\n    };\n  }();\n\n  var joinFiber = function joinFiber(v) {\n    return $foreign.makeAff(function (k) {\n      return Data_Functor.map(Effect.functorEffect)(effectCanceler)(v.join(k));\n    });\n  };\n\n  var functorFiber = new Data_Functor.Functor(function (f) {\n    return function (t) {\n      return Effect_Unsafe.unsafePerformEffect(makeFiber(Data_Functor.map(functorAff)(f)(joinFiber(t))));\n    };\n  });\n\n  var killFiber = function killFiber(e) {\n    return function (v) {\n      return Control_Bind.bind(bindAff)(Effect_Class.liftEffect(monadEffectAff)(v.isSuspended))(function (v1) {\n        if (v1) {\n          return Effect_Class.liftEffect(monadEffectAff)(Data_Functor[\"void\"](Effect.functorEffect)(v.kill(e, Data_Function[\"const\"](Control_Applicative.pure(Effect.applicativeEffect)(Data_Unit.unit)))));\n        }\n\n        ;\n        return $foreign.makeAff(function (k) {\n          return Data_Functor.map(Effect.functorEffect)(effectCanceler)(v.kill(e, k));\n        });\n      });\n    };\n  };\n\n  var monadThrowAff = new Control_Monad_Error_Class.MonadThrow(function () {\n    return monadAff;\n  }, $foreign[\"_throwError\"]);\n  var monadErrorAff = new Control_Monad_Error_Class.MonadError(function () {\n    return monadThrowAff;\n  }, $foreign[\"_catchError\"]);\n  var attempt = Control_Monad_Error_Class[\"try\"](monadErrorAff);\n\n  var runAff = function runAff(k) {\n    return function (aff) {\n      return launchAff(Control_Bind.bindFlipped(bindAff)(function () {\n        var $49 = Effect_Class.liftEffect(monadEffectAff);\n        return function ($50) {\n          return $49(k($50));\n        };\n      }())(Control_Monad_Error_Class[\"try\"](monadErrorAff)(aff)));\n    };\n  };\n\n  var runAff_ = function runAff_(k) {\n    return function (aff) {\n      return Data_Functor[\"void\"](Effect.functorEffect)(runAff(k)(aff));\n    };\n  };\n\n  var parallelAff = new Control_Parallel_Class.Parallel(function () {\n    return applicativeParAff;\n  }, function () {\n    return monadAff;\n  }, Unsafe_Coerce.unsafeCoerce, $foreign[\"_sequential\"]);\n  var applicativeParAff = new Control_Applicative.Applicative(function () {\n    return applyParAff;\n  }, function () {\n    var $53 = Control_Parallel_Class.parallel(parallelAff);\n    var $54 = Control_Applicative.pure(applicativeAff);\n    return function ($55) {\n      return $53($54($55));\n    };\n  }());\n  var monadRecAff = new Control_Monad_Rec_Class.MonadRec(function () {\n    return monadAff;\n  }, function (k) {\n    var go = function go(a) {\n      return Control_Bind.bind(bindAff)(k(a))(function (res) {\n        if (res instanceof Control_Monad_Rec_Class.Done) {\n          return Control_Applicative.pure(applicativeAff)(res.value0);\n        }\n\n        ;\n\n        if (res instanceof Control_Monad_Rec_Class.Loop) {\n          return go(res.value0);\n        }\n\n        ;\n        throw new Error(\"Failed pattern match at Effect.Aff (line 100, column 7 - line 102, column 22): \" + [res.constructor.name]);\n      });\n    };\n\n    return go;\n  });\n  var nonCanceler = Data_Function[\"const\"](Control_Applicative.pure(applicativeAff)(Data_Unit.unit));\n  exports[\"launchAff_\"] = launchAff_;\n  exports[\"runAff_\"] = runAff_;\n  exports[\"forkAff\"] = forkAff;\n  exports[\"suspendAff\"] = suspendAff;\n  exports[\"attempt\"] = attempt;\n  exports[\"finally\"] = $$finally;\n  exports[\"killFiber\"] = killFiber;\n  exports[\"joinFiber\"] = joinFiber;\n  exports[\"nonCanceler\"] = nonCanceler;\n  exports[\"effectCanceler\"] = effectCanceler;\n  exports[\"functorAff\"] = functorAff;\n  exports[\"applicativeAff\"] = applicativeAff;\n  exports[\"bindAff\"] = bindAff;\n  exports[\"monadAff\"] = monadAff;\n  exports[\"monadRecAff\"] = monadRecAff;\n  exports[\"monadThrowAff\"] = monadThrowAff;\n  exports[\"monadErrorAff\"] = monadErrorAff;\n  exports[\"monadEffectAff\"] = monadEffectAff;\n  exports[\"applicativeParAff\"] = applicativeParAff;\n  exports[\"parallelAff\"] = parallelAff;\n  exports[\"functorFiber\"] = functorFiber;\n  exports[\"makeAff\"] = $foreign.makeAff;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Control.Monad.Fork.Class\"] = $PS[\"Control.Monad.Fork.Class\"] || {};\n  var exports = $PS[\"Control.Monad.Fork.Class\"];\n  var Effect_Aff = $PS[\"Effect.Aff\"];\n\n  var MonadFork = function MonadFork(Functor1, Monad0, fork, join, suspend) {\n    this.Functor1 = Functor1;\n    this.Monad0 = Monad0;\n    this.fork = fork;\n    this.join = join;\n    this.suspend = suspend;\n  };\n\n  var monadForkAff = new MonadFork(function () {\n    return Effect_Aff.functorFiber;\n  }, function () {\n    return Effect_Aff.monadAff;\n  }, Effect_Aff.forkAff, Effect_Aff.joinFiber, Effect_Aff.suspendAff);\n\n  var fork = function fork(dict) {\n    return dict.fork;\n  };\n\n  exports[\"fork\"] = fork;\n  exports[\"monadForkAff\"] = monadForkAff;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Control.Parallel\"] = $PS[\"Control.Parallel\"] || {};\n  var exports = $PS[\"Control.Parallel\"];\n  var Control_Category = $PS[\"Control.Category\"];\n  var Control_Parallel_Class = $PS[\"Control.Parallel.Class\"];\n  var Data_Foldable = $PS[\"Data.Foldable\"];\n\n  var parTraverse_ = function parTraverse_(dictParallel) {\n    return function (dictFoldable) {\n      return function (f) {\n        var $17 = Control_Parallel_Class.sequential(dictParallel);\n        var $18 = Data_Foldable.traverse_(dictParallel.Applicative1())(dictFoldable)(function () {\n          var $20 = Control_Parallel_Class.parallel(dictParallel);\n          return function ($21) {\n            return $20(f($21));\n          };\n        }());\n        return function ($19) {\n          return $17($18($19));\n        };\n      };\n    };\n  };\n\n  var parSequence_ = function parSequence_(dictParallel) {\n    return function (dictFoldable) {\n      return parTraverse_(dictParallel)(dictFoldable)(Control_Category.identity(Control_Category.categoryFn));\n    };\n  };\n\n  exports[\"parSequence_\"] = parSequence_;\n})(PS);\n\n(function (exports) {\n  \"use strict\"; //------------------------------------------------------------------------------\n  // Array size ------------------------------------------------------------------\n  //------------------------------------------------------------------------------\n\n  exports.length = function (xs) {\n    return xs.length;\n  };\n})(PS[\"Data.Array\"] = PS[\"Data.Array\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.Array\"] = $PS[\"Data.Array\"] || {};\n  var exports = $PS[\"Data.Array\"];\n  var $foreign = $PS[\"Data.Array\"];\n  exports[\"length\"] = $foreign.length;\n})(PS);\n\n(function (exports) {\n  \"use strict\";\n\n  exports.boolConj = function (b1) {\n    return function (b2) {\n      return b1 && b2;\n    };\n  };\n\n  exports.boolDisj = function (b1) {\n    return function (b2) {\n      return b1 || b2;\n    };\n  };\n\n  exports.boolNot = function (b) {\n    return !b;\n  };\n})(PS[\"Data.HeytingAlgebra\"] = PS[\"Data.HeytingAlgebra\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.HeytingAlgebra\"] = $PS[\"Data.HeytingAlgebra\"] || {};\n  var exports = $PS[\"Data.HeytingAlgebra\"];\n  var $foreign = $PS[\"Data.HeytingAlgebra\"];\n\n  var HeytingAlgebra = function HeytingAlgebra(conj, disj, ff, implies, not, tt) {\n    this.conj = conj;\n    this.disj = disj;\n    this.ff = ff;\n    this.implies = implies;\n    this.not = not;\n    this.tt = tt;\n  };\n\n  var tt = function tt(dict) {\n    return dict.tt;\n  };\n\n  var not = function not(dict) {\n    return dict.not;\n  };\n\n  var implies = function implies(dict) {\n    return dict.implies;\n  };\n\n  var ff = function ff(dict) {\n    return dict.ff;\n  };\n\n  var disj = function disj(dict) {\n    return dict.disj;\n  };\n\n  var heytingAlgebraBoolean = new HeytingAlgebra($foreign.boolConj, $foreign.boolDisj, false, function (a) {\n    return function (b) {\n      return disj(heytingAlgebraBoolean)(not(heytingAlgebraBoolean)(a))(b);\n    };\n  }, $foreign.boolNot, true);\n\n  var conj = function conj(dict) {\n    return dict.conj;\n  };\n\n  var heytingAlgebraFunction = function heytingAlgebraFunction(dictHeytingAlgebra) {\n    return new HeytingAlgebra(function (f) {\n      return function (g) {\n        return function (a) {\n          return conj(dictHeytingAlgebra)(f(a))(g(a));\n        };\n      };\n    }, function (f) {\n      return function (g) {\n        return function (a) {\n          return disj(dictHeytingAlgebra)(f(a))(g(a));\n        };\n      };\n    }, function (v) {\n      return ff(dictHeytingAlgebra);\n    }, function (f) {\n      return function (g) {\n        return function (a) {\n          return implies(dictHeytingAlgebra)(f(a))(g(a));\n        };\n      };\n    }, function (f) {\n      return function (a) {\n        return not(dictHeytingAlgebra)(f(a));\n      };\n    }, function (v) {\n      return tt(dictHeytingAlgebra);\n    });\n  };\n\n  exports[\"not\"] = not;\n  exports[\"heytingAlgebraBoolean\"] = heytingAlgebraBoolean;\n  exports[\"heytingAlgebraFunction\"] = heytingAlgebraFunction;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Data.Map.Internal\"] = $PS[\"Data.Map.Internal\"] || {};\n  var exports = $PS[\"Data.Map.Internal\"];\n  var Control_Applicative = $PS[\"Control.Applicative\"];\n  var Data_Foldable = $PS[\"Data.Foldable\"];\n  var Data_Functor = $PS[\"Data.Functor\"];\n  var Data_List_Types = $PS[\"Data.List.Types\"];\n  var Data_Maybe = $PS[\"Data.Maybe\"];\n  var Data_Ord = $PS[\"Data.Ord\"];\n  var Data_Ordering = $PS[\"Data.Ordering\"];\n  var Data_Semigroup = $PS[\"Data.Semigroup\"];\n  var Data_Tuple = $PS[\"Data.Tuple\"];\n\n  var Leaf = function () {\n    function Leaf() {}\n\n    ;\n    Leaf.value = new Leaf();\n    return Leaf;\n  }();\n\n  var Two = function () {\n    function Two(value0, value1, value2, value3) {\n      this.value0 = value0;\n      this.value1 = value1;\n      this.value2 = value2;\n      this.value3 = value3;\n    }\n\n    ;\n\n    Two.create = function (value0) {\n      return function (value1) {\n        return function (value2) {\n          return function (value3) {\n            return new Two(value0, value1, value2, value3);\n          };\n        };\n      };\n    };\n\n    return Two;\n  }();\n\n  var Three = function () {\n    function Three(value0, value1, value2, value3, value4, value5, value6) {\n      this.value0 = value0;\n      this.value1 = value1;\n      this.value2 = value2;\n      this.value3 = value3;\n      this.value4 = value4;\n      this.value5 = value5;\n      this.value6 = value6;\n    }\n\n    ;\n\n    Three.create = function (value0) {\n      return function (value1) {\n        return function (value2) {\n          return function (value3) {\n            return function (value4) {\n              return function (value5) {\n                return function (value6) {\n                  return new Three(value0, value1, value2, value3, value4, value5, value6);\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n\n    return Three;\n  }();\n\n  var TwoLeft = function () {\n    function TwoLeft(value0, value1, value2) {\n      this.value0 = value0;\n      this.value1 = value1;\n      this.value2 = value2;\n    }\n\n    ;\n\n    TwoLeft.create = function (value0) {\n      return function (value1) {\n        return function (value2) {\n          return new TwoLeft(value0, value1, value2);\n        };\n      };\n    };\n\n    return TwoLeft;\n  }();\n\n  var TwoRight = function () {\n    function TwoRight(value0, value1, value2) {\n      this.value0 = value0;\n      this.value1 = value1;\n      this.value2 = value2;\n    }\n\n    ;\n\n    TwoRight.create = function (value0) {\n      return function (value1) {\n        return function (value2) {\n          return new TwoRight(value0, value1, value2);\n        };\n      };\n    };\n\n    return TwoRight;\n  }();\n\n  var ThreeLeft = function () {\n    function ThreeLeft(value0, value1, value2, value3, value4, value5) {\n      this.value0 = value0;\n      this.value1 = value1;\n      this.value2 = value2;\n      this.value3 = value3;\n      this.value4 = value4;\n      this.value5 = value5;\n    }\n\n    ;\n\n    ThreeLeft.create = function (value0) {\n      return function (value1) {\n        return function (value2) {\n          return function (value3) {\n            return function (value4) {\n              return function (value5) {\n                return new ThreeLeft(value0, value1, value2, value3, value4, value5);\n              };\n            };\n          };\n        };\n      };\n    };\n\n    return ThreeLeft;\n  }();\n\n  var ThreeMiddle = function () {\n    function ThreeMiddle(value0, value1, value2, value3, value4, value5) {\n      this.value0 = value0;\n      this.value1 = value1;\n      this.value2 = value2;\n      this.value3 = value3;\n      this.value4 = value4;\n      this.value5 = value5;\n    }\n\n    ;\n\n    ThreeMiddle.create = function (value0) {\n      return function (value1) {\n        return function (value2) {\n          return function (value3) {\n            return function (value4) {\n              return function (value5) {\n                return new ThreeMiddle(value0, value1, value2, value3, value4, value5);\n              };\n            };\n          };\n        };\n      };\n    };\n\n    return ThreeMiddle;\n  }();\n\n  var ThreeRight = function () {\n    function ThreeRight(value0, value1, value2, value3, value4, value5) {\n      this.value0 = value0;\n      this.value1 = value1;\n      this.value2 = value2;\n      this.value3 = value3;\n      this.value4 = value4;\n      this.value5 = value5;\n    }\n\n    ;\n\n    ThreeRight.create = function (value0) {\n      return function (value1) {\n        return function (value2) {\n          return function (value3) {\n            return function (value4) {\n              return function (value5) {\n                return new ThreeRight(value0, value1, value2, value3, value4, value5);\n              };\n            };\n          };\n        };\n      };\n    };\n\n    return ThreeRight;\n  }();\n\n  var KickUp = function () {\n    function KickUp(value0, value1, value2, value3) {\n      this.value0 = value0;\n      this.value1 = value1;\n      this.value2 = value2;\n      this.value3 = value3;\n    }\n\n    ;\n\n    KickUp.create = function (value0) {\n      return function (value1) {\n        return function (value2) {\n          return function (value3) {\n            return new KickUp(value0, value1, value2, value3);\n          };\n        };\n      };\n    };\n\n    return KickUp;\n  }();\n\n  var values = function values(v) {\n    if (v instanceof Leaf) {\n      return Data_List_Types.Nil.value;\n    }\n\n    ;\n\n    if (v instanceof Two) {\n      return Data_Semigroup.append(Data_List_Types.semigroupList)(values(v.value0))(Data_Semigroup.append(Data_List_Types.semigroupList)(Control_Applicative.pure(Data_List_Types.applicativeList)(v.value2))(values(v.value3)));\n    }\n\n    ;\n\n    if (v instanceof Three) {\n      return Data_Semigroup.append(Data_List_Types.semigroupList)(values(v.value0))(Data_Semigroup.append(Data_List_Types.semigroupList)(Control_Applicative.pure(Data_List_Types.applicativeList)(v.value2))(Data_Semigroup.append(Data_List_Types.semigroupList)(values(v.value3))(Data_Semigroup.append(Data_List_Types.semigroupList)(Control_Applicative.pure(Data_List_Types.applicativeList)(v.value5))(values(v.value6)))));\n    }\n\n    ;\n    throw new Error(\"Failed pattern match at Data.Map.Internal (line 612, column 1 - line 612, column 40): \" + [v.constructor.name]);\n  };\n\n  var lookup = function lookup(dictOrd) {\n    return function (k) {\n      var comp = Data_Ord.compare(dictOrd);\n\n      var go = function go($copy_v) {\n        var $tco_done = false;\n        var $tco_result;\n\n        function $tco_loop(v) {\n          if (v instanceof Leaf) {\n            $tco_done = true;\n            return Data_Maybe.Nothing.value;\n          }\n\n          ;\n\n          if (v instanceof Two) {\n            var v2 = comp(k)(v.value1);\n\n            if (v2 instanceof Data_Ordering.EQ) {\n              $tco_done = true;\n              return new Data_Maybe.Just(v.value2);\n            }\n\n            ;\n\n            if (v2 instanceof Data_Ordering.LT) {\n              $copy_v = v.value0;\n              return;\n            }\n\n            ;\n            $copy_v = v.value3;\n            return;\n          }\n\n          ;\n\n          if (v instanceof Three) {\n            var v3 = comp(k)(v.value1);\n\n            if (v3 instanceof Data_Ordering.EQ) {\n              $tco_done = true;\n              return new Data_Maybe.Just(v.value2);\n            }\n\n            ;\n            var v4 = comp(k)(v.value4);\n\n            if (v4 instanceof Data_Ordering.EQ) {\n              $tco_done = true;\n              return new Data_Maybe.Just(v.value5);\n            }\n\n            ;\n\n            if (v3 instanceof Data_Ordering.LT) {\n              $copy_v = v.value0;\n              return;\n            }\n\n            ;\n\n            if (v4 instanceof Data_Ordering.GT) {\n              $copy_v = v.value6;\n              return;\n            }\n\n            ;\n            $copy_v = v.value3;\n            return;\n          }\n\n          ;\n          throw new Error(\"Failed pattern match at Data.Map.Internal (line 200, column 5 - line 200, column 22): \" + [v.constructor.name]);\n        }\n\n        ;\n\n        while (!$tco_done) {\n          $tco_result = $tco_loop($copy_v);\n        }\n\n        ;\n        return $tco_result;\n      };\n\n      return go;\n    };\n  };\n\n  var member = function member(dictOrd) {\n    return function (k) {\n      return function (m) {\n        return Data_Maybe.isJust(lookup(dictOrd)(k)(m));\n      };\n    };\n  };\n\n  var functorMap = new Data_Functor.Functor(function (v) {\n    return function (v1) {\n      if (v1 instanceof Leaf) {\n        return Leaf.value;\n      }\n\n      ;\n\n      if (v1 instanceof Two) {\n        return new Two(Data_Functor.map(functorMap)(v)(v1.value0), v1.value1, v(v1.value2), Data_Functor.map(functorMap)(v)(v1.value3));\n      }\n\n      ;\n\n      if (v1 instanceof Three) {\n        return new Three(Data_Functor.map(functorMap)(v)(v1.value0), v1.value1, v(v1.value2), Data_Functor.map(functorMap)(v)(v1.value3), v1.value4, v(v1.value5), Data_Functor.map(functorMap)(v)(v1.value6));\n      }\n\n      ;\n      throw new Error(\"Failed pattern match at Data.Map.Internal (line 96, column 1 - line 99, column 110): \" + [v.constructor.name, v1.constructor.name]);\n    };\n  });\n\n  var fromZipper = function fromZipper($copy_dictOrd) {\n    return function ($copy_v) {\n      return function ($copy_tree) {\n        var $tco_var_dictOrd = $copy_dictOrd;\n        var $tco_var_v = $copy_v;\n        var $tco_done = false;\n        var $tco_result;\n\n        function $tco_loop(dictOrd, v, tree) {\n          if (v instanceof Data_List_Types.Nil) {\n            $tco_done = true;\n            return tree;\n          }\n\n          ;\n\n          if (v instanceof Data_List_Types.Cons) {\n            if (v.value0 instanceof TwoLeft) {\n              $tco_var_dictOrd = dictOrd;\n              $tco_var_v = v.value1;\n              $copy_tree = new Two(tree, v.value0.value0, v.value0.value1, v.value0.value2);\n              return;\n            }\n\n            ;\n\n            if (v.value0 instanceof TwoRight) {\n              $tco_var_dictOrd = dictOrd;\n              $tco_var_v = v.value1;\n              $copy_tree = new Two(v.value0.value0, v.value0.value1, v.value0.value2, tree);\n              return;\n            }\n\n            ;\n\n            if (v.value0 instanceof ThreeLeft) {\n              $tco_var_dictOrd = dictOrd;\n              $tco_var_v = v.value1;\n              $copy_tree = new Three(tree, v.value0.value0, v.value0.value1, v.value0.value2, v.value0.value3, v.value0.value4, v.value0.value5);\n              return;\n            }\n\n            ;\n\n            if (v.value0 instanceof ThreeMiddle) {\n              $tco_var_dictOrd = dictOrd;\n              $tco_var_v = v.value1;\n              $copy_tree = new Three(v.value0.value0, v.value0.value1, v.value0.value2, tree, v.value0.value3, v.value0.value4, v.value0.value5);\n              return;\n            }\n\n            ;\n\n            if (v.value0 instanceof ThreeRight) {\n              $tco_var_dictOrd = dictOrd;\n              $tco_var_v = v.value1;\n              $copy_tree = new Three(v.value0.value0, v.value0.value1, v.value0.value2, v.value0.value3, v.value0.value4, v.value0.value5, tree);\n              return;\n            }\n\n            ;\n            throw new Error(\"Failed pattern match at Data.Map.Internal (line 418, column 3 - line 423, column 88): \" + [v.value0.constructor.name]);\n          }\n\n          ;\n          throw new Error(\"Failed pattern match at Data.Map.Internal (line 415, column 1 - line 415, column 80): \" + [v.constructor.name, tree.constructor.name]);\n        }\n\n        ;\n\n        while (!$tco_done) {\n          $tco_result = $tco_loop($tco_var_dictOrd, $tco_var_v, $copy_tree);\n        }\n\n        ;\n        return $tco_result;\n      };\n    };\n  };\n\n  var insert = function insert(dictOrd) {\n    return function (k) {\n      return function (v) {\n        var up = function up($copy_v1) {\n          return function ($copy_v2) {\n            var $tco_var_v1 = $copy_v1;\n            var $tco_done = false;\n            var $tco_result;\n\n            function $tco_loop(v1, v2) {\n              if (v1 instanceof Data_List_Types.Nil) {\n                $tco_done = true;\n                return new Two(v2.value0, v2.value1, v2.value2, v2.value3);\n              }\n\n              ;\n\n              if (v1 instanceof Data_List_Types.Cons) {\n                if (v1.value0 instanceof TwoLeft) {\n                  $tco_done = true;\n                  return fromZipper(dictOrd)(v1.value1)(new Three(v2.value0, v2.value1, v2.value2, v2.value3, v1.value0.value0, v1.value0.value1, v1.value0.value2));\n                }\n\n                ;\n\n                if (v1.value0 instanceof TwoRight) {\n                  $tco_done = true;\n                  return fromZipper(dictOrd)(v1.value1)(new Three(v1.value0.value0, v1.value0.value1, v1.value0.value2, v2.value0, v2.value1, v2.value2, v2.value3));\n                }\n\n                ;\n\n                if (v1.value0 instanceof ThreeLeft) {\n                  $tco_var_v1 = v1.value1;\n                  $copy_v2 = new KickUp(new Two(v2.value0, v2.value1, v2.value2, v2.value3), v1.value0.value0, v1.value0.value1, new Two(v1.value0.value2, v1.value0.value3, v1.value0.value4, v1.value0.value5));\n                  return;\n                }\n\n                ;\n\n                if (v1.value0 instanceof ThreeMiddle) {\n                  $tco_var_v1 = v1.value1;\n                  $copy_v2 = new KickUp(new Two(v1.value0.value0, v1.value0.value1, v1.value0.value2, v2.value0), v2.value1, v2.value2, new Two(v2.value3, v1.value0.value3, v1.value0.value4, v1.value0.value5));\n                  return;\n                }\n\n                ;\n\n                if (v1.value0 instanceof ThreeRight) {\n                  $tco_var_v1 = v1.value1;\n                  $copy_v2 = new KickUp(new Two(v1.value0.value0, v1.value0.value1, v1.value0.value2, v1.value0.value3), v1.value0.value4, v1.value0.value5, new Two(v2.value0, v2.value1, v2.value2, v2.value3));\n                  return;\n                }\n\n                ;\n                throw new Error(\"Failed pattern match at Data.Map.Internal (line 454, column 5 - line 459, column 108): \" + [v1.value0.constructor.name, v2.constructor.name]);\n              }\n\n              ;\n              throw new Error(\"Failed pattern match at Data.Map.Internal (line 451, column 3 - line 451, column 56): \" + [v1.constructor.name, v2.constructor.name]);\n            }\n\n            ;\n\n            while (!$tco_done) {\n              $tco_result = $tco_loop($tco_var_v1, $copy_v2);\n            }\n\n            ;\n            return $tco_result;\n          };\n        };\n\n        var comp = Data_Ord.compare(dictOrd);\n\n        var down = function down($copy_ctx) {\n          return function ($copy_v1) {\n            var $tco_var_ctx = $copy_ctx;\n            var $tco_done = false;\n            var $tco_result;\n\n            function $tco_loop(ctx, v1) {\n              if (v1 instanceof Leaf) {\n                $tco_done = true;\n                return up(ctx)(new KickUp(Leaf.value, k, v, Leaf.value));\n              }\n\n              ;\n\n              if (v1 instanceof Two) {\n                var v2 = comp(k)(v1.value1);\n\n                if (v2 instanceof Data_Ordering.EQ) {\n                  $tco_done = true;\n                  return fromZipper(dictOrd)(ctx)(new Two(v1.value0, k, v, v1.value3));\n                }\n\n                ;\n\n                if (v2 instanceof Data_Ordering.LT) {\n                  $tco_var_ctx = new Data_List_Types.Cons(new TwoLeft(v1.value1, v1.value2, v1.value3), ctx);\n                  $copy_v1 = v1.value0;\n                  return;\n                }\n\n                ;\n                $tco_var_ctx = new Data_List_Types.Cons(new TwoRight(v1.value0, v1.value1, v1.value2), ctx);\n                $copy_v1 = v1.value3;\n                return;\n              }\n\n              ;\n\n              if (v1 instanceof Three) {\n                var v3 = comp(k)(v1.value1);\n\n                if (v3 instanceof Data_Ordering.EQ) {\n                  $tco_done = true;\n                  return fromZipper(dictOrd)(ctx)(new Three(v1.value0, k, v, v1.value3, v1.value4, v1.value5, v1.value6));\n                }\n\n                ;\n                var v4 = comp(k)(v1.value4);\n\n                if (v4 instanceof Data_Ordering.EQ) {\n                  $tco_done = true;\n                  return fromZipper(dictOrd)(ctx)(new Three(v1.value0, v1.value1, v1.value2, v1.value3, k, v, v1.value6));\n                }\n\n                ;\n\n                if (v3 instanceof Data_Ordering.LT) {\n                  $tco_var_ctx = new Data_List_Types.Cons(new ThreeLeft(v1.value1, v1.value2, v1.value3, v1.value4, v1.value5, v1.value6), ctx);\n                  $copy_v1 = v1.value0;\n                  return;\n                }\n\n                ;\n\n                if (v3 instanceof Data_Ordering.GT && v4 instanceof Data_Ordering.LT) {\n                  $tco_var_ctx = new Data_List_Types.Cons(new ThreeMiddle(v1.value0, v1.value1, v1.value2, v1.value4, v1.value5, v1.value6), ctx);\n                  $copy_v1 = v1.value3;\n                  return;\n                }\n\n                ;\n                $tco_var_ctx = new Data_List_Types.Cons(new ThreeRight(v1.value0, v1.value1, v1.value2, v1.value3, v1.value4, v1.value5), ctx);\n                $copy_v1 = v1.value6;\n                return;\n              }\n\n              ;\n              throw new Error(\"Failed pattern match at Data.Map.Internal (line 434, column 3 - line 434, column 55): \" + [ctx.constructor.name, v1.constructor.name]);\n            }\n\n            ;\n\n            while (!$tco_done) {\n              $tco_result = $tco_loop($tco_var_ctx, $copy_v1);\n            }\n\n            ;\n            return $tco_result;\n          };\n        };\n\n        return down(Data_List_Types.Nil.value);\n      };\n    };\n  };\n\n  var pop = function pop(dictOrd) {\n    return function (k) {\n      var up = function up($copy_ctxs) {\n        return function ($copy_tree) {\n          var $tco_var_ctxs = $copy_ctxs;\n          var $tco_done = false;\n          var $tco_result;\n\n          function $tco_loop(ctxs, tree) {\n            if (ctxs instanceof Data_List_Types.Nil) {\n              $tco_done = true;\n              return tree;\n            }\n\n            ;\n\n            if (ctxs instanceof Data_List_Types.Cons) {\n              if (ctxs.value0 instanceof TwoLeft && ctxs.value0.value2 instanceof Leaf && tree instanceof Leaf) {\n                $tco_done = true;\n                return fromZipper(dictOrd)(ctxs.value1)(new Two(Leaf.value, ctxs.value0.value0, ctxs.value0.value1, Leaf.value));\n              }\n\n              ;\n\n              if (ctxs.value0 instanceof TwoRight && ctxs.value0.value0 instanceof Leaf && tree instanceof Leaf) {\n                $tco_done = true;\n                return fromZipper(dictOrd)(ctxs.value1)(new Two(Leaf.value, ctxs.value0.value1, ctxs.value0.value2, Leaf.value));\n              }\n\n              ;\n\n              if (ctxs.value0 instanceof TwoLeft && ctxs.value0.value2 instanceof Two) {\n                $tco_var_ctxs = ctxs.value1;\n                $copy_tree = new Three(tree, ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2.value0, ctxs.value0.value2.value1, ctxs.value0.value2.value2, ctxs.value0.value2.value3);\n                return;\n              }\n\n              ;\n\n              if (ctxs.value0 instanceof TwoRight && ctxs.value0.value0 instanceof Two) {\n                $tco_var_ctxs = ctxs.value1;\n                $copy_tree = new Three(ctxs.value0.value0.value0, ctxs.value0.value0.value1, ctxs.value0.value0.value2, ctxs.value0.value0.value3, ctxs.value0.value1, ctxs.value0.value2, tree);\n                return;\n              }\n\n              ;\n\n              if (ctxs.value0 instanceof TwoLeft && ctxs.value0.value2 instanceof Three) {\n                $tco_done = true;\n                return fromZipper(dictOrd)(ctxs.value1)(new Two(new Two(tree, ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2.value0), ctxs.value0.value2.value1, ctxs.value0.value2.value2, new Two(ctxs.value0.value2.value3, ctxs.value0.value2.value4, ctxs.value0.value2.value5, ctxs.value0.value2.value6)));\n              }\n\n              ;\n\n              if (ctxs.value0 instanceof TwoRight && ctxs.value0.value0 instanceof Three) {\n                $tco_done = true;\n                return fromZipper(dictOrd)(ctxs.value1)(new Two(new Two(ctxs.value0.value0.value0, ctxs.value0.value0.value1, ctxs.value0.value0.value2, ctxs.value0.value0.value3), ctxs.value0.value0.value4, ctxs.value0.value0.value5, new Two(ctxs.value0.value0.value6, ctxs.value0.value1, ctxs.value0.value2, tree)));\n              }\n\n              ;\n\n              if (ctxs.value0 instanceof ThreeLeft && ctxs.value0.value2 instanceof Leaf && ctxs.value0.value5 instanceof Leaf && tree instanceof Leaf) {\n                $tco_done = true;\n                return fromZipper(dictOrd)(ctxs.value1)(new Three(Leaf.value, ctxs.value0.value0, ctxs.value0.value1, Leaf.value, ctxs.value0.value3, ctxs.value0.value4, Leaf.value));\n              }\n\n              ;\n\n              if (ctxs.value0 instanceof ThreeMiddle && ctxs.value0.value0 instanceof Leaf && ctxs.value0.value5 instanceof Leaf && tree instanceof Leaf) {\n                $tco_done = true;\n                return fromZipper(dictOrd)(ctxs.value1)(new Three(Leaf.value, ctxs.value0.value1, ctxs.value0.value2, Leaf.value, ctxs.value0.value3, ctxs.value0.value4, Leaf.value));\n              }\n\n              ;\n\n              if (ctxs.value0 instanceof ThreeRight && ctxs.value0.value0 instanceof Leaf && ctxs.value0.value3 instanceof Leaf && tree instanceof Leaf) {\n                $tco_done = true;\n                return fromZipper(dictOrd)(ctxs.value1)(new Three(Leaf.value, ctxs.value0.value1, ctxs.value0.value2, Leaf.value, ctxs.value0.value4, ctxs.value0.value5, Leaf.value));\n              }\n\n              ;\n\n              if (ctxs.value0 instanceof ThreeLeft && ctxs.value0.value2 instanceof Two) {\n                $tco_done = true;\n                return fromZipper(dictOrd)(ctxs.value1)(new Two(new Three(tree, ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2.value0, ctxs.value0.value2.value1, ctxs.value0.value2.value2, ctxs.value0.value2.value3), ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5));\n              }\n\n              ;\n\n              if (ctxs.value0 instanceof ThreeMiddle && ctxs.value0.value0 instanceof Two) {\n                $tco_done = true;\n                return fromZipper(dictOrd)(ctxs.value1)(new Two(new Three(ctxs.value0.value0.value0, ctxs.value0.value0.value1, ctxs.value0.value0.value2, ctxs.value0.value0.value3, ctxs.value0.value1, ctxs.value0.value2, tree), ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5));\n              }\n\n              ;\n\n              if (ctxs.value0 instanceof ThreeMiddle && ctxs.value0.value5 instanceof Two) {\n                $tco_done = true;\n                return fromZipper(dictOrd)(ctxs.value1)(new Two(ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2, new Three(tree, ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5.value0, ctxs.value0.value5.value1, ctxs.value0.value5.value2, ctxs.value0.value5.value3)));\n              }\n\n              ;\n\n              if (ctxs.value0 instanceof ThreeRight && ctxs.value0.value3 instanceof Two) {\n                $tco_done = true;\n                return fromZipper(dictOrd)(ctxs.value1)(new Two(ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2, new Three(ctxs.value0.value3.value0, ctxs.value0.value3.value1, ctxs.value0.value3.value2, ctxs.value0.value3.value3, ctxs.value0.value4, ctxs.value0.value5, tree)));\n              }\n\n              ;\n\n              if (ctxs.value0 instanceof ThreeLeft && ctxs.value0.value2 instanceof Three) {\n                $tco_done = true;\n                return fromZipper(dictOrd)(ctxs.value1)(new Three(new Two(tree, ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2.value0), ctxs.value0.value2.value1, ctxs.value0.value2.value2, new Two(ctxs.value0.value2.value3, ctxs.value0.value2.value4, ctxs.value0.value2.value5, ctxs.value0.value2.value6), ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5));\n              }\n\n              ;\n\n              if (ctxs.value0 instanceof ThreeMiddle && ctxs.value0.value0 instanceof Three) {\n                $tco_done = true;\n                return fromZipper(dictOrd)(ctxs.value1)(new Three(new Two(ctxs.value0.value0.value0, ctxs.value0.value0.value1, ctxs.value0.value0.value2, ctxs.value0.value0.value3), ctxs.value0.value0.value4, ctxs.value0.value0.value5, new Two(ctxs.value0.value0.value6, ctxs.value0.value1, ctxs.value0.value2, tree), ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5));\n              }\n\n              ;\n\n              if (ctxs.value0 instanceof ThreeMiddle && ctxs.value0.value5 instanceof Three) {\n                $tco_done = true;\n                return fromZipper(dictOrd)(ctxs.value1)(new Three(ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2, new Two(tree, ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5.value0), ctxs.value0.value5.value1, ctxs.value0.value5.value2, new Two(ctxs.value0.value5.value3, ctxs.value0.value5.value4, ctxs.value0.value5.value5, ctxs.value0.value5.value6)));\n              }\n\n              ;\n\n              if (ctxs.value0 instanceof ThreeRight && ctxs.value0.value3 instanceof Three) {\n                $tco_done = true;\n                return fromZipper(dictOrd)(ctxs.value1)(new Three(ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2, new Two(ctxs.value0.value3.value0, ctxs.value0.value3.value1, ctxs.value0.value3.value2, ctxs.value0.value3.value3), ctxs.value0.value3.value4, ctxs.value0.value3.value5, new Two(ctxs.value0.value3.value6, ctxs.value0.value4, ctxs.value0.value5, tree)));\n              }\n\n              ;\n              throw new Error(\"Failed pattern match at Data.Map.Internal (line 511, column 9 - line 528, column 136): \" + [ctxs.value0.constructor.name, tree.constructor.name]);\n            }\n\n            ;\n            throw new Error(\"Failed pattern match at Data.Map.Internal (line 508, column 5 - line 528, column 136): \" + [ctxs.constructor.name]);\n          }\n\n          ;\n\n          while (!$tco_done) {\n            $tco_result = $tco_loop($tco_var_ctxs, $copy_tree);\n          }\n\n          ;\n          return $tco_result;\n        };\n      };\n\n      var removeMaxNode = function removeMaxNode($copy_ctx) {\n        return function ($copy_m) {\n          var $tco_var_ctx = $copy_ctx;\n          var $tco_done = false;\n          var $tco_result;\n\n          function $tco_loop(ctx, m) {\n            if (m instanceof Two && m.value0 instanceof Leaf && m.value3 instanceof Leaf) {\n              $tco_done = true;\n              return up(ctx)(Leaf.value);\n            }\n\n            ;\n\n            if (m instanceof Two) {\n              $tco_var_ctx = new Data_List_Types.Cons(new TwoRight(m.value0, m.value1, m.value2), ctx);\n              $copy_m = m.value3;\n              return;\n            }\n\n            ;\n\n            if (m instanceof Three && m.value0 instanceof Leaf && m.value3 instanceof Leaf && m.value6 instanceof Leaf) {\n              $tco_done = true;\n              return up(new Data_List_Types.Cons(new TwoRight(Leaf.value, m.value1, m.value2), ctx))(Leaf.value);\n            }\n\n            ;\n\n            if (m instanceof Three) {\n              $tco_var_ctx = new Data_List_Types.Cons(new ThreeRight(m.value0, m.value1, m.value2, m.value3, m.value4, m.value5), ctx);\n              $copy_m = m.value6;\n              return;\n            }\n\n            ;\n            throw new Error(\"Failed pattern match at Data.Map.Internal (line 540, column 5 - line 544, column 107): \" + [m.constructor.name]);\n          }\n\n          ;\n\n          while (!$tco_done) {\n            $tco_result = $tco_loop($tco_var_ctx, $copy_m);\n          }\n\n          ;\n          return $tco_result;\n        };\n      };\n\n      var maxNode = function maxNode($copy_m) {\n        var $tco_done = false;\n        var $tco_result;\n\n        function $tco_loop(m) {\n          if (m instanceof Two && m.value3 instanceof Leaf) {\n            $tco_done = true;\n            return {\n              key: m.value1,\n              value: m.value2\n            };\n          }\n\n          ;\n\n          if (m instanceof Two) {\n            $copy_m = m.value3;\n            return;\n          }\n\n          ;\n\n          if (m instanceof Three && m.value6 instanceof Leaf) {\n            $tco_done = true;\n            return {\n              key: m.value4,\n              value: m.value5\n            };\n          }\n\n          ;\n\n          if (m instanceof Three) {\n            $copy_m = m.value6;\n            return;\n          }\n\n          ;\n          throw new Error(\"Failed pattern match at Data.Map.Internal (line 531, column 33 - line 535, column 45): \" + [m.constructor.name]);\n        }\n\n        ;\n\n        while (!$tco_done) {\n          $tco_result = $tco_loop($copy_m);\n        }\n\n        ;\n        return $tco_result;\n      };\n\n      var comp = Data_Ord.compare(dictOrd);\n\n      var down = function down($copy_ctx) {\n        return function ($copy_m) {\n          var $tco_var_ctx = $copy_ctx;\n          var $tco_done = false;\n          var $tco_result;\n\n          function $tco_loop(ctx, m) {\n            if (m instanceof Leaf) {\n              $tco_done = true;\n              return Data_Maybe.Nothing.value;\n            }\n\n            ;\n\n            if (m instanceof Two) {\n              var v = comp(k)(m.value1);\n\n              if (m.value3 instanceof Leaf && v instanceof Data_Ordering.EQ) {\n                $tco_done = true;\n                return new Data_Maybe.Just(new Data_Tuple.Tuple(m.value2, up(ctx)(Leaf.value)));\n              }\n\n              ;\n\n              if (v instanceof Data_Ordering.EQ) {\n                var max = maxNode(m.value0);\n                $tco_done = true;\n                return new Data_Maybe.Just(new Data_Tuple.Tuple(m.value2, removeMaxNode(new Data_List_Types.Cons(new TwoLeft(max.key, max.value, m.value3), ctx))(m.value0)));\n              }\n\n              ;\n\n              if (v instanceof Data_Ordering.LT) {\n                $tco_var_ctx = new Data_List_Types.Cons(new TwoLeft(m.value1, m.value2, m.value3), ctx);\n                $copy_m = m.value0;\n                return;\n              }\n\n              ;\n              $tco_var_ctx = new Data_List_Types.Cons(new TwoRight(m.value0, m.value1, m.value2), ctx);\n              $copy_m = m.value3;\n              return;\n            }\n\n            ;\n\n            if (m instanceof Three) {\n              var leaves = function () {\n                if (m.value0 instanceof Leaf && m.value3 instanceof Leaf && m.value6 instanceof Leaf) {\n                  return true;\n                }\n\n                ;\n                return false;\n              }();\n\n              var v = comp(k)(m.value4);\n              var v3 = comp(k)(m.value1);\n\n              if (leaves && v3 instanceof Data_Ordering.EQ) {\n                $tco_done = true;\n                return new Data_Maybe.Just(new Data_Tuple.Tuple(m.value2, fromZipper(dictOrd)(ctx)(new Two(Leaf.value, m.value4, m.value5, Leaf.value))));\n              }\n\n              ;\n\n              if (leaves && v instanceof Data_Ordering.EQ) {\n                $tco_done = true;\n                return new Data_Maybe.Just(new Data_Tuple.Tuple(m.value5, fromZipper(dictOrd)(ctx)(new Two(Leaf.value, m.value1, m.value2, Leaf.value))));\n              }\n\n              ;\n\n              if (v3 instanceof Data_Ordering.EQ) {\n                var max = maxNode(m.value0);\n                $tco_done = true;\n                return new Data_Maybe.Just(new Data_Tuple.Tuple(m.value2, removeMaxNode(new Data_List_Types.Cons(new ThreeLeft(max.key, max.value, m.value3, m.value4, m.value5, m.value6), ctx))(m.value0)));\n              }\n\n              ;\n\n              if (v instanceof Data_Ordering.EQ) {\n                var max = maxNode(m.value3);\n                $tco_done = true;\n                return new Data_Maybe.Just(new Data_Tuple.Tuple(m.value5, removeMaxNode(new Data_List_Types.Cons(new ThreeMiddle(m.value0, m.value1, m.value2, max.key, max.value, m.value6), ctx))(m.value3)));\n              }\n\n              ;\n\n              if (v3 instanceof Data_Ordering.LT) {\n                $tco_var_ctx = new Data_List_Types.Cons(new ThreeLeft(m.value1, m.value2, m.value3, m.value4, m.value5, m.value6), ctx);\n                $copy_m = m.value0;\n                return;\n              }\n\n              ;\n\n              if (v3 instanceof Data_Ordering.GT && v instanceof Data_Ordering.LT) {\n                $tco_var_ctx = new Data_List_Types.Cons(new ThreeMiddle(m.value0, m.value1, m.value2, m.value4, m.value5, m.value6), ctx);\n                $copy_m = m.value3;\n                return;\n              }\n\n              ;\n              $tco_var_ctx = new Data_List_Types.Cons(new ThreeRight(m.value0, m.value1, m.value2, m.value3, m.value4, m.value5), ctx);\n              $copy_m = m.value6;\n              return;\n            }\n\n            ;\n            throw new Error(\"Failed pattern match at Data.Map.Internal (line 481, column 34 - line 504, column 80): \" + [m.constructor.name]);\n          }\n\n          ;\n\n          while (!$tco_done) {\n            $tco_result = $tco_loop($tco_var_ctx, $copy_m);\n          }\n\n          ;\n          return $tco_result;\n        };\n      };\n\n      return down(Data_List_Types.Nil.value);\n    };\n  };\n\n  var foldableMap = new Data_Foldable.Foldable(function (dictMonoid) {\n    return function (f) {\n      return function (m) {\n        return Data_Foldable.foldMap(Data_List_Types.foldableList)(dictMonoid)(f)(values(m));\n      };\n    };\n  }, function (f) {\n    return function (z) {\n      return function (m) {\n        return Data_Foldable.foldl(Data_List_Types.foldableList)(f)(z)(values(m));\n      };\n    };\n  }, function (f) {\n    return function (z) {\n      return function (m) {\n        return Data_Foldable.foldr(Data_List_Types.foldableList)(f)(z)(values(m));\n      };\n    };\n  });\n  var empty = Leaf.value;\n\n  var $$delete = function $$delete(dictOrd) {\n    return function (k) {\n      return function (m) {\n        return Data_Maybe.maybe(m)(Data_Tuple.snd)(pop(dictOrd)(k)(m));\n      };\n    };\n  };\n\n  var alter = function alter(dictOrd) {\n    return function (f) {\n      return function (k) {\n        return function (m) {\n          var v = f(lookup(dictOrd)(k)(m));\n\n          if (v instanceof Data_Maybe.Nothing) {\n            return $$delete(dictOrd)(k)(m);\n          }\n\n          ;\n\n          if (v instanceof Data_Maybe.Just) {\n            return insert(dictOrd)(k)(v.value0)(m);\n          }\n\n          ;\n          throw new Error(\"Failed pattern match at Data.Map.Internal (line 549, column 15 - line 551, column 25): \" + [v.constructor.name]);\n        };\n      };\n    };\n  };\n\n  exports[\"empty\"] = empty;\n  exports[\"insert\"] = insert;\n  exports[\"lookup\"] = lookup;\n  exports[\"delete\"] = $$delete;\n  exports[\"member\"] = member;\n  exports[\"alter\"] = alter;\n  exports[\"functorMap\"] = functorMap;\n  exports[\"foldableMap\"] = foldableMap;\n})(PS);\n\n(function (exports) {\n  /* globals exports, setTimeout */\n  \"use strict\";\n\n  var AVar = function () {\n    function MutableQueue() {\n      this.head = null;\n      this.last = null;\n      this.size = 0;\n    }\n\n    function MutableCell(queue, value) {\n      this.queue = queue;\n      this.value = value;\n      this.next = null;\n      this.prev = null;\n    }\n\n    function AVar(value) {\n      this.draining = false;\n      this.error = null;\n      this.value = value;\n      this.takes = new MutableQueue();\n      this.reads = new MutableQueue();\n      this.puts = new MutableQueue();\n    }\n\n    var EMPTY = {};\n\n    function runEff(eff) {\n      try {\n        eff();\n      } catch (error) {\n        setTimeout(function () {\n          throw error;\n        }, 0);\n      }\n    }\n\n    function putLast(queue, value) {\n      var cell = new MutableCell(queue, value);\n\n      switch (queue.size) {\n        case 0:\n          queue.head = cell;\n          break;\n\n        case 1:\n          cell.prev = queue.head;\n          queue.head.next = cell;\n          queue.last = cell;\n          break;\n\n        default:\n          cell.prev = queue.last;\n          queue.last.next = cell;\n          queue.last = cell;\n      }\n\n      queue.size++;\n      return cell;\n    }\n\n    function takeLast(queue) {\n      var cell;\n\n      switch (queue.size) {\n        case 0:\n          return null;\n\n        case 1:\n          cell = queue.head;\n          queue.head = null;\n          break;\n\n        case 2:\n          cell = queue.last;\n          queue.head.next = null;\n          queue.last = null;\n          break;\n\n        default:\n          cell = queue.last;\n          queue.last = cell.prev;\n          queue.last.next = null;\n      }\n\n      cell.prev = null;\n      cell.queue = null;\n      queue.size--;\n      return cell.value;\n    }\n\n    function takeHead(queue) {\n      var cell;\n\n      switch (queue.size) {\n        case 0:\n          return null;\n\n        case 1:\n          cell = queue.head;\n          queue.head = null;\n          break;\n\n        case 2:\n          cell = queue.head;\n          queue.last.prev = null;\n          queue.head = queue.last;\n          queue.last = null;\n          break;\n\n        default:\n          cell = queue.head;\n          queue.head = cell.next;\n          queue.head.prev = null;\n      }\n\n      cell.next = null;\n      cell.queue = null;\n      queue.size--;\n      return cell.value;\n    }\n\n    function deleteCell(cell) {\n      if (cell.queue === null) {\n        return;\n      }\n\n      if (cell.queue.last === cell) {\n        takeLast(cell.queue);\n        return;\n      }\n\n      if (cell.queue.head === cell) {\n        takeHead(cell.queue);\n        return;\n      }\n\n      if (cell.prev) {\n        cell.prev.next = cell.next;\n      }\n\n      if (cell.next) {\n        cell.next.prev = cell.prev;\n      }\n\n      cell.queue.size--;\n      cell.queue = null;\n      cell.value = null;\n      cell.next = null;\n      cell.prev = null;\n    }\n\n    function drainVar(util, avar) {\n      if (avar.draining) {\n        return;\n      }\n\n      var ps = avar.puts;\n      var ts = avar.takes;\n      var rs = avar.reads;\n      var p, r, t, value, rsize;\n      avar.draining = true;\n\n      while (1) {\n        // eslint-disable-line no-constant-condition\n        p = null;\n        r = null;\n        t = null;\n        value = avar.value;\n        rsize = rs.size;\n\n        if (avar.error !== null) {\n          value = util.left(avar.error);\n\n          while (p = takeHead(ps)) {\n            // eslint-disable-line no-cond-assign\n            runEff(p.cb(value));\n          }\n\n          while (r = takeHead(rs)) {\n            // eslint-disable-line no-cond-assign\n            runEff(r(value));\n          }\n\n          while (t = takeHead(ts)) {\n            // eslint-disable-line no-cond-assign\n            runEff(t(value));\n          }\n\n          break;\n        } // Process the next put. We do not immediately invoke the callback\n        // because we want to preserve ordering. If there are takes/reads\n        // we want to run those first.\n\n\n        if (value === EMPTY && (p = takeHead(ps))) {\n          avar.value = value = p.value;\n        }\n\n        if (value !== EMPTY) {\n          // We go ahead and queue up the next take for the same reasons as\n          // above. Invoking the read callbacks can affect the mutable queue.\n          t = takeHead(ts); // We only want to process the reads queued up before running these\n          // callbacks so we guard on rsize.\n\n          while (rsize-- && (r = takeHead(rs))) {\n            runEff(r(util.right(value)));\n          }\n\n          if (t !== null) {\n            avar.value = EMPTY;\n            runEff(t(util.right(value)));\n          }\n        }\n\n        if (p !== null) {\n          runEff(p.cb(util.right(void 0)));\n        } // Callbacks could have queued up more items so we need to guard on the\n        // actual mutable properties.\n\n\n        if (avar.value === EMPTY && ps.size === 0 || avar.value !== EMPTY && ts.size === 0) {\n          break;\n        }\n      }\n\n      avar.draining = false;\n    }\n\n    AVar.EMPTY = EMPTY;\n    AVar.putLast = putLast;\n    AVar.takeLast = takeLast;\n    AVar.takeHead = takeHead;\n    AVar.deleteCell = deleteCell;\n    AVar.drainVar = drainVar;\n    return AVar;\n  }();\n\n  exports.empty = function () {\n    return new AVar(AVar.EMPTY);\n  };\n\n  exports._newVar = function (value) {\n    return function () {\n      return new AVar(value);\n    };\n  };\n\n  exports._killVar = function (util, error, avar) {\n    return function () {\n      if (avar.error === null) {\n        avar.error = error;\n        avar.value = AVar.EMPTY;\n        AVar.drainVar(util, avar);\n      }\n    };\n  };\n\n  exports._putVar = function (util, value, avar, cb) {\n    return function () {\n      var cell = AVar.putLast(avar.puts, {\n        cb: cb,\n        value: value\n      });\n      AVar.drainVar(util, avar);\n      return function () {\n        AVar.deleteCell(cell);\n      };\n    };\n  };\n\n  exports._takeVar = function (util, avar, cb) {\n    return function () {\n      var cell = AVar.putLast(avar.takes, cb);\n      AVar.drainVar(util, avar);\n      return function () {\n        AVar.deleteCell(cell);\n      };\n    };\n  };\n})(PS[\"Effect.AVar\"] = PS[\"Effect.AVar\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Effect.AVar\"] = $PS[\"Effect.AVar\"] || {};\n  var exports = $PS[\"Effect.AVar\"];\n  var $foreign = $PS[\"Effect.AVar\"];\n  var Data_Either = $PS[\"Data.Either\"];\n  var Data_Maybe = $PS[\"Data.Maybe\"];\n\n  var Killed = function () {\n    function Killed(value0) {\n      this.value0 = value0;\n    }\n\n    ;\n\n    Killed.create = function (value0) {\n      return new Killed(value0);\n    };\n\n    return Killed;\n  }();\n\n  var Filled = function () {\n    function Filled(value0) {\n      this.value0 = value0;\n    }\n\n    ;\n\n    Filled.create = function (value0) {\n      return new Filled(value0);\n    };\n\n    return Filled;\n  }();\n\n  var Empty = function () {\n    function Empty() {}\n\n    ;\n    Empty.value = new Empty();\n    return Empty;\n  }();\n\n  var $$new = $foreign[\"_newVar\"];\n  var ffiUtil = {\n    left: Data_Either.Left.create,\n    right: Data_Either.Right.create,\n    nothing: Data_Maybe.Nothing.value,\n    just: Data_Maybe.Just.create,\n    killed: Killed.create,\n    filled: Filled.create,\n    empty: Empty.value\n  };\n\n  var kill = function kill(err) {\n    return function (avar) {\n      return $foreign[\"_killVar\"](ffiUtil, err, avar);\n    };\n  };\n\n  var put = function put(value) {\n    return function (avar) {\n      return function (cb) {\n        return $foreign[\"_putVar\"](ffiUtil, value, avar, cb);\n      };\n    };\n  };\n\n  var take = function take(avar) {\n    return function (cb) {\n      return $foreign[\"_takeVar\"](ffiUtil, avar, cb);\n    };\n  };\n\n  exports[\"new\"] = $$new;\n  exports[\"take\"] = take;\n  exports[\"put\"] = put;\n  exports[\"kill\"] = kill;\n  exports[\"empty\"] = $foreign.empty;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Effect.Aff.AVar\"] = $PS[\"Effect.Aff.AVar\"] || {};\n  var exports = $PS[\"Effect.Aff.AVar\"];\n  var Effect_AVar = $PS[\"Effect.AVar\"];\n  var Effect_Aff = $PS[\"Effect.Aff\"];\n  var Effect_Class = $PS[\"Effect.Class\"];\n\n  var take = function take(avar) {\n    return Effect_Aff.makeAff(function (k) {\n      return function __do() {\n        var c = Effect_AVar.take(avar)(k)();\n        return Effect_Aff.effectCanceler(c);\n      };\n    });\n  };\n\n  var put = function put(value) {\n    return function (avar) {\n      return Effect_Aff.makeAff(function (k) {\n        return function __do() {\n          var c = Effect_AVar.put(value)(avar)(k)();\n          return Effect_Aff.effectCanceler(c);\n        };\n      });\n    };\n  };\n\n  var kill = function kill(error) {\n    var $11 = Effect_Class.liftEffect(Effect_Aff.monadEffectAff);\n    var $12 = Effect_AVar.kill(error);\n    return function ($13) {\n      return $11($12($13));\n    };\n  };\n\n  var empty = Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_AVar.empty);\n  exports[\"empty\"] = empty;\n  exports[\"take\"] = take;\n  exports[\"put\"] = put;\n  exports[\"kill\"] = kill;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Effect.Aff.Bus\"] = $PS[\"Effect.Aff.Bus\"] || {};\n  var exports = $PS[\"Effect.Aff.Bus\"];\n  var Control_Bind = $PS[\"Control.Bind\"];\n  var Control_Monad_Rec_Class = $PS[\"Control.Monad.Rec.Class\"];\n  var Data_Foldable = $PS[\"Data.Foldable\"];\n  var Data_List_Types = $PS[\"Data.List.Types\"];\n  var Data_Monoid = $PS[\"Data.Monoid\"];\n  var Effect_AVar = $PS[\"Effect.AVar\"];\n  var Effect_Aff = $PS[\"Effect.Aff\"];\n  var Effect_Aff_AVar = $PS[\"Effect.Aff.AVar\"];\n  var Effect_Class = $PS[\"Effect.Class\"];\n\n  var Bus = function () {\n    function Bus(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n\n    ;\n\n    Bus.create = function (value0) {\n      return function (value1) {\n        return new Bus(value0, value1);\n      };\n    };\n\n    return Bus;\n  }();\n\n  var make = function make(dictMonadEffect) {\n    return Effect_Class.liftEffect(dictMonadEffect)(function __do() {\n      var cell = Effect_AVar.empty();\n      var consumers = Effect_AVar[\"new\"](Data_Monoid.mempty(Data_List_Types.monoidList))();\n      Effect_Aff.launchAff_(Effect_Aff.attempt(Control_Monad_Rec_Class.forever(Effect_Aff.monadRecAff)(Control_Bind.bind(Effect_Aff.bindAff)(Effect_Aff_AVar.take(cell))(function (res) {\n        return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Aff_AVar.take(consumers))(function (vars) {\n          return Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)(Effect_Aff_AVar.put(Data_List_Types.Nil.value)(consumers))(function () {\n            return Data_Foldable.sequence_(Effect_Aff.applicativeAff)(Data_List_Types.foldableList)(Data_Foldable.foldl(Data_List_Types.foldableList)(function (xs) {\n              return function (a) {\n                return new Data_List_Types.Cons(Effect_Aff_AVar.put(res)(a), xs);\n              };\n            })(Data_Monoid.mempty(Data_List_Types.monoidList))(vars));\n          });\n        });\n      }))))();\n      return new Bus(cell, consumers);\n    });\n  };\n\n  exports[\"make\"] = make;\n})(PS);\n\n(function (exports) {\n  \"use strict\";\n\n  exports.warn = function (s) {\n    return function () {\n      console.warn(s);\n      return {};\n    };\n  };\n})(PS[\"Effect.Console\"] = PS[\"Effect.Console\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Effect.Console\"] = $PS[\"Effect.Console\"] || {};\n  var exports = $PS[\"Effect.Console\"];\n  var $foreign = $PS[\"Effect.Console\"];\n  exports[\"warn\"] = $foreign.warn;\n})(PS);\n\n(function (exports) {\n  \"use strict\";\n\n  exports.error = function (msg) {\n    return new Error(msg);\n  };\n\n  exports.throwException = function (e) {\n    return function () {\n      throw e;\n    };\n  };\n})(PS[\"Effect.Exception\"] = PS[\"Effect.Exception\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Effect.Exception\"] = $PS[\"Effect.Exception\"] || {};\n  var exports = $PS[\"Effect.Exception\"];\n  var $foreign = $PS[\"Effect.Exception\"];\n\n  var $$throw = function $$throw($2) {\n    return $foreign.throwException($foreign.error($2));\n  };\n\n  exports[\"throw\"] = $$throw;\n  exports[\"error\"] = $foreign.error;\n  exports[\"throwException\"] = $foreign.throwException;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Halogen.Data.Slot\"] = $PS[\"Halogen.Data.Slot\"] || {};\n  var exports = $PS[\"Halogen.Data.Slot\"];\n  var Data_Foldable = $PS[\"Data.Foldable\"];\n  var Data_Map_Internal = $PS[\"Data.Map.Internal\"];\n\n  var foreachSlot = function foreachSlot(dictApplicative) {\n    return function (v) {\n      return function (k) {\n        return Data_Foldable.traverse_(dictApplicative)(Data_Map_Internal.foldableMap)(function ($37) {\n          return k($37);\n        })(v);\n      };\n    };\n  };\n\n  var empty = Data_Map_Internal.empty;\n  exports[\"empty\"] = empty;\n  exports[\"foreachSlot\"] = foreachSlot;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Halogen.Aff.Driver.State\"] = $PS[\"Halogen.Aff.Driver.State\"] || {};\n  var exports = $PS[\"Halogen.Aff.Driver.State\"];\n  var Data_Foldable = $PS[\"Data.Foldable\"];\n  var Data_List_Types = $PS[\"Data.List.Types\"];\n  var Data_Map_Internal = $PS[\"Data.Map.Internal\"];\n  var Data_Maybe = $PS[\"Data.Maybe\"];\n  var Effect_Ref = $PS[\"Effect.Ref\"];\n  var Halogen_Data_Slot = $PS[\"Halogen.Data.Slot\"];\n  var Unsafe_Coerce = $PS[\"Unsafe.Coerce\"];\n  var unRenderStateX = Unsafe_Coerce.unsafeCoerce;\n  var unDriverStateX = Unsafe_Coerce.unsafeCoerce;\n\n  var renderStateX_ = function renderStateX_(dictApplicative) {\n    return function (f) {\n      return unDriverStateX(function (st) {\n        return Data_Foldable.traverse_(dictApplicative)(Data_Foldable.foldableMaybe)(f)(st.rendering);\n      });\n    };\n  };\n\n  var mkRenderStateX = Unsafe_Coerce.unsafeCoerce;\n\n  var renderStateX = function renderStateX(dictFunctor) {\n    return function (f) {\n      return unDriverStateX(function (st) {\n        return mkRenderStateX(f(st.rendering));\n      });\n    };\n  };\n\n  var mkDriverStateXRef = Unsafe_Coerce.unsafeCoerce;\n\n  var mapDriverState = function mapDriverState(f) {\n    return function (v) {\n      return f(v);\n    };\n  };\n\n  var initDriverState = function initDriverState(component) {\n    return function (input) {\n      return function (handler) {\n        return function (lchs) {\n          return function __do() {\n            var selfRef = Effect_Ref[\"new\"]({})();\n            var childrenIn = Effect_Ref[\"new\"](Halogen_Data_Slot.empty)();\n            var childrenOut = Effect_Ref[\"new\"](Halogen_Data_Slot.empty)();\n            var handlerRef = Effect_Ref[\"new\"](handler)();\n            var pendingQueries = Effect_Ref[\"new\"](new Data_Maybe.Just(Data_List_Types.Nil.value))();\n            var pendingOuts = Effect_Ref[\"new\"](new Data_Maybe.Just(Data_List_Types.Nil.value))();\n            var pendingHandlers = Effect_Ref[\"new\"](Data_Maybe.Nothing.value)();\n            var fresh = Effect_Ref[\"new\"](1)();\n            var subscriptions = Effect_Ref[\"new\"](new Data_Maybe.Just(Data_Map_Internal.empty))();\n            var forks = Effect_Ref[\"new\"](Data_Map_Internal.empty)();\n            var ds = {\n              component: component,\n              state: component.initialState(input),\n              refs: Data_Map_Internal.empty,\n              children: Halogen_Data_Slot.empty,\n              childrenIn: childrenIn,\n              childrenOut: childrenOut,\n              selfRef: selfRef,\n              handlerRef: handlerRef,\n              pendingQueries: pendingQueries,\n              pendingOuts: pendingOuts,\n              pendingHandlers: pendingHandlers,\n              rendering: Data_Maybe.Nothing.value,\n              fresh: fresh,\n              subscriptions: subscriptions,\n              forks: forks,\n              lifecycleHandlers: lchs\n            };\n            Effect_Ref.write(ds)(selfRef)();\n            return mkDriverStateXRef(selfRef);\n          };\n        };\n      };\n    };\n  };\n\n  exports[\"mapDriverState\"] = mapDriverState;\n  exports[\"unDriverStateX\"] = unDriverStateX;\n  exports[\"renderStateX\"] = renderStateX;\n  exports[\"renderStateX_\"] = renderStateX_;\n  exports[\"unRenderStateX\"] = unRenderStateX;\n  exports[\"initDriverState\"] = initDriverState;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Halogen.Query.ChildQuery\"] = $PS[\"Halogen.Query.ChildQuery\"] || {};\n  var exports = $PS[\"Halogen.Query.ChildQuery\"];\n  var Unsafe_Coerce = $PS[\"Unsafe.Coerce\"];\n  var unChildQueryBox = Unsafe_Coerce.unsafeCoerce;\n  exports[\"unChildQueryBox\"] = unChildQueryBox;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Halogen.Query.EventSource\"] = $PS[\"Halogen.Query.EventSource\"] || {};\n  var exports = $PS[\"Halogen.Query.EventSource\"];\n\n  var finalize = function finalize(v) {\n    return v;\n  };\n\n  exports[\"finalize\"] = finalize;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Halogen.Query.Input\"] = $PS[\"Halogen.Query.Input\"] || {};\n  var exports = $PS[\"Halogen.Query.Input\"];\n\n  var RefUpdate = function () {\n    function RefUpdate(value0, value1) {\n      this.value0 = value0;\n      this.value1 = value1;\n    }\n\n    ;\n\n    RefUpdate.create = function (value0) {\n      return function (value1) {\n        return new RefUpdate(value0, value1);\n      };\n    };\n\n    return RefUpdate;\n  }();\n\n  var Action = function () {\n    function Action(value0) {\n      this.value0 = value0;\n    }\n\n    ;\n\n    Action.create = function (value0) {\n      return new Action(value0);\n    };\n\n    return Action;\n  }();\n\n  exports[\"RefUpdate\"] = RefUpdate;\n  exports[\"Action\"] = Action;\n})(PS);\n\n(function (exports) {\n  \"use strict\";\n\n  exports.reallyUnsafeRefEq = function (a) {\n    return function (b) {\n      return a === b;\n    };\n  };\n})(PS[\"Unsafe.Reference\"] = PS[\"Unsafe.Reference\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Unsafe.Reference\"] = $PS[\"Unsafe.Reference\"] || {};\n  var exports = $PS[\"Unsafe.Reference\"];\n  var $foreign = $PS[\"Unsafe.Reference\"];\n  var unsafeRefEq = $foreign.reallyUnsafeRefEq;\n  exports[\"unsafeRefEq\"] = unsafeRefEq;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Halogen.Aff.Driver.Eval\"] = $PS[\"Halogen.Aff.Driver.Eval\"] || {};\n  var exports = $PS[\"Halogen.Aff.Driver.Eval\"];\n  var Control_Applicative = $PS[\"Control.Applicative\"];\n  var Control_Applicative_Free = $PS[\"Control.Applicative.Free\"];\n  var Control_Bind = $PS[\"Control.Bind\"];\n  var Control_Coroutine = $PS[\"Control.Coroutine\"];\n  var Control_Monad = $PS[\"Control.Monad\"];\n  var Control_Monad_Fork_Class = $PS[\"Control.Monad.Fork.Class\"];\n  var Control_Monad_Free = $PS[\"Control.Monad.Free\"];\n  var Control_Monad_Free_Trans = $PS[\"Control.Monad.Free.Trans\"];\n  var Control_Monad_Trans_Class = $PS[\"Control.Monad.Trans.Class\"];\n  var Control_Parallel = $PS[\"Control.Parallel\"];\n  var Control_Parallel_Class = $PS[\"Control.Parallel.Class\"];\n  var Data_Boolean = $PS[\"Data.Boolean\"];\n  var Data_Coyoneda = $PS[\"Data.Coyoneda\"];\n  var Data_Eq = $PS[\"Data.Eq\"];\n  var Data_Foldable = $PS[\"Data.Foldable\"];\n  var Data_Function = $PS[\"Data.Function\"];\n  var Data_Functor = $PS[\"Data.Functor\"];\n  var Data_List_Types = $PS[\"Data.List.Types\"];\n  var Data_Map_Internal = $PS[\"Data.Map.Internal\"];\n  var Data_Maybe = $PS[\"Data.Maybe\"];\n  var Data_Ord = $PS[\"Data.Ord\"];\n  var Data_Unit = $PS[\"Data.Unit\"];\n  var Effect = $PS[\"Effect\"];\n  var Effect_Aff = $PS[\"Effect.Aff\"];\n  var Effect_Class = $PS[\"Effect.Class\"];\n  var Effect_Exception = $PS[\"Effect.Exception\"];\n  var Effect_Ref = $PS[\"Effect.Ref\"];\n  var Halogen_Aff_Driver_State = $PS[\"Halogen.Aff.Driver.State\"];\n  var Halogen_Query_ChildQuery = $PS[\"Halogen.Query.ChildQuery\"];\n  var Halogen_Query_EventSource = $PS[\"Halogen.Query.EventSource\"];\n  var Halogen_Query_HalogenM = $PS[\"Halogen.Query.HalogenM\"];\n  var Halogen_Query_HalogenQ = $PS[\"Halogen.Query.HalogenQ\"];\n  var Halogen_Query_Input = $PS[\"Halogen.Query.Input\"];\n  var Unsafe_Reference = $PS[\"Unsafe.Reference\"];\n\n  var unsubscribe = function unsubscribe(sid) {\n    return function (ref) {\n      return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref.read(ref)))(function (v) {\n        return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref.read(v.subscriptions)))(function (subs) {\n          return Data_Foldable.traverse_(Effect_Aff.applicativeAff)(Data_Foldable.foldableMaybe)(Halogen_Query_EventSource.finalize)(Control_Bind.bindFlipped(Data_Maybe.bindMaybe)(Data_Map_Internal.lookup(Halogen_Query_HalogenM.ordSubscriptionId)(sid))(subs));\n        });\n      });\n    };\n  };\n\n  var queueOrRun = function queueOrRun(ref) {\n    return function (au) {\n      return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref.read(ref)))(function (v) {\n        if (v instanceof Data_Maybe.Nothing) {\n          return au;\n        }\n\n        ;\n\n        if (v instanceof Data_Maybe.Just) {\n          return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref.write(new Data_Maybe.Just(new Data_List_Types.Cons(au, v.value0)))(ref));\n        }\n\n        ;\n        throw new Error(\"Failed pattern match at Halogen.Aff.Driver.Eval (line 195, column 33 - line 197, column 57): \" + [v.constructor.name]);\n      });\n    };\n  };\n\n  var handleLifecycle = function handleLifecycle(lchs) {\n    return function (f) {\n      return Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref.write({\n        initializers: Data_List_Types.Nil.value,\n        finalizers: Data_List_Types.Nil.value\n      })(lchs)))(function () {\n        return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(f))(function (result) {\n          return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref.read(lchs)))(function (v) {\n            return Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)(Data_Foldable.traverse_(Effect_Aff.applicativeAff)(Data_List_Types.foldableList)(Control_Monad_Fork_Class.fork(Control_Monad_Fork_Class.monadForkAff))(v.finalizers))(function () {\n              return Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)(Control_Parallel.parSequence_(Effect_Aff.parallelAff)(Data_List_Types.foldableList)(v.initializers))(function () {\n                return Control_Applicative.pure(Effect_Aff.applicativeAff)(result);\n              });\n            });\n          });\n        });\n      });\n    };\n  };\n\n  var fresh = function fresh(f) {\n    return function (ref) {\n      return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref.read(ref)))(function (v) {\n        return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref[\"modify'\"](function (i) {\n          return {\n            state: i + 1 | 0,\n            value: f(i)\n          };\n        })(v.fresh));\n      });\n    };\n  };\n\n  var evalQ = function evalQ(render) {\n    return function (ref) {\n      return function (q) {\n        return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref.read(ref)))(function (v) {\n          return evalM(render)(ref)(v[\"component\"][\"eval\"](new Halogen_Query_HalogenQ.Query(Data_Functor.map(Data_Coyoneda.functorCoyoneda)(Data_Maybe.Just.create)(Data_Coyoneda.liftCoyoneda(q)), Data_Function[\"const\"](Data_Maybe.Nothing.value))));\n        });\n      };\n    };\n  };\n\n  var evalM = function evalM(render) {\n    return function (initRef) {\n      return function (v) {\n        var evalChildQuery = function evalChildQuery(ref) {\n          return function (cqb) {\n            return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref.read(ref)))(function (v1) {\n              return Halogen_Query_ChildQuery.unChildQueryBox(function (v2) {\n                var evalChild = function evalChild(v3) {\n                  return Control_Parallel_Class.parallel(Effect_Aff.parallelAff)(Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref.read(v3)))(function (dsx) {\n                    return Halogen_Aff_Driver_State.unDriverStateX(function (ds) {\n                      return evalQ(render)(ds.selfRef)(v2.value1);\n                    })(dsx);\n                  }));\n                };\n\n                return Data_Functor.map(Effect_Aff.functorAff)(v2.value2)(Control_Parallel_Class.sequential(Effect_Aff.parallelAff)(v2.value0(Effect_Aff.applicativeParAff)(evalChild)(v1.children)));\n              })(cqb);\n            });\n          };\n        };\n\n        var go = function go(ref) {\n          return function (v1) {\n            if (v1 instanceof Halogen_Query_HalogenM.State) {\n              return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref.read(ref)))(function (v2) {\n                var v3 = v1.value0(v2.state);\n\n                if (Unsafe_Reference.unsafeRefEq(v2.state)(v3.value1)) {\n                  return Control_Applicative.pure(Effect_Aff.applicativeAff)(v3.value0);\n                }\n\n                ;\n\n                if (Data_Boolean.otherwise) {\n                  return Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref.write({\n                    component: v2.component,\n                    state: v3.value1,\n                    refs: v2.refs,\n                    children: v2.children,\n                    childrenIn: v2.childrenIn,\n                    childrenOut: v2.childrenOut,\n                    selfRef: v2.selfRef,\n                    handlerRef: v2.handlerRef,\n                    pendingQueries: v2.pendingQueries,\n                    pendingOuts: v2.pendingOuts,\n                    pendingHandlers: v2.pendingHandlers,\n                    rendering: v2.rendering,\n                    fresh: v2.fresh,\n                    subscriptions: v2.subscriptions,\n                    forks: v2.forks,\n                    lifecycleHandlers: v2.lifecycleHandlers\n                  })(ref)))(function () {\n                    return Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)(handleLifecycle(v2.lifecycleHandlers)(render(v2.lifecycleHandlers)(ref)))(function () {\n                      return Control_Applicative.pure(Effect_Aff.applicativeAff)(v3.value0);\n                    });\n                  });\n                }\n\n                ;\n                throw new Error(\"Failed pattern match at Halogen.Aff.Driver.Eval (line 85, column 7 - line 91, column 21): \" + [v3.constructor.name]);\n              });\n            }\n\n            ;\n\n            if (v1 instanceof Halogen_Query_HalogenM.Subscribe) {\n              return Control_Bind.bind(Effect_Aff.bindAff)(fresh(Halogen_Query_HalogenM.SubscriptionId)(ref))(function (sid) {\n                var v2 = v1.value0(sid);\n                return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref.read(ref)))(function (v3) {\n                  return Control_Bind.bind(Effect_Aff.bindAff)(Control_Monad_Fork_Class.fork(Control_Monad_Fork_Class.monadForkAff)(Control_Bind.bind(Effect_Aff.bindAff)(v2)(function (v4) {\n                    var done = Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref.read(v3.subscriptions)))(function (subs) {\n                      return Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref.modify_(Data_Functor.map(Data_Maybe.functorMaybe)(Data_Map_Internal[\"delete\"](Halogen_Query_HalogenM.ordSubscriptionId)(sid)))(v3.subscriptions)))(function () {\n                        return Control_Applicative.when(Effect_Aff.applicativeAff)(Data_Maybe.maybe(false)(Data_Map_Internal.member(Halogen_Query_HalogenM.ordSubscriptionId)(sid))(subs))(Halogen_Query_EventSource.finalize(v4.finalizer));\n                      });\n                    });\n                    var consumer = Control_Bind.bind(Control_Monad_Free_Trans.bindFreeT(Control_Coroutine.functorAwait)(Effect_Aff.monadAff))(Control_Coroutine[\"await\"](Effect_Aff.monadAff))(function (act) {\n                      return Control_Bind.bind(Control_Monad_Free_Trans.bindFreeT(Control_Coroutine.functorAwait)(Effect_Aff.monadAff))(Control_Monad_Trans_Class.lift(Control_Monad_Free_Trans.monadTransFreeT(Control_Coroutine.functorAwait))(Effect_Aff.monadAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref.read(v3.subscriptions))))(function (subs) {\n                        return Control_Applicative.when(Control_Monad_Free_Trans.applicativeFreeT(Control_Coroutine.functorAwait)(Effect_Aff.monadAff))(Data_Eq.eq(Data_Maybe.eqMaybe(Data_Eq.eqBoolean))(Data_Functor.map(Data_Maybe.functorMaybe)(Data_Map_Internal.member(Halogen_Query_HalogenM.ordSubscriptionId)(sid))(subs))(new Data_Maybe.Just(true)))(Control_Bind.bind(Control_Monad_Free_Trans.bindFreeT(Control_Coroutine.functorAwait)(Effect_Aff.monadAff))(Control_Monad_Trans_Class.lift(Control_Monad_Free_Trans.monadTransFreeT(Control_Coroutine.functorAwait))(Effect_Aff.monadAff)(Control_Monad_Fork_Class.fork(Control_Monad_Fork_Class.monadForkAff)(evalF(render)(ref)(new Halogen_Query_Input.Action(act)))))(function () {\n                          return consumer;\n                        }));\n                      });\n                    });\n                    return Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref.modify_(Data_Functor.map(Data_Maybe.functorMaybe)(Data_Map_Internal.insert(Halogen_Query_HalogenM.ordSubscriptionId)(sid)(done)))(v3.subscriptions)))(function () {\n                      return Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)(Control_Coroutine.runProcess(Effect_Aff.monadRecAff)(Control_Coroutine.pullFrom(Effect_Aff.monadRecAff)(consumer)(v4.producer)))(function () {\n                        return Halogen_Query_EventSource.finalize(done);\n                      });\n                    });\n                  })))(function () {\n                    return Control_Applicative.pure(Effect_Aff.applicativeAff)(v1.value1(sid));\n                  });\n                });\n              });\n            }\n\n            ;\n\n            if (v1 instanceof Halogen_Query_HalogenM.Unsubscribe) {\n              return Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)(unsubscribe(v1.value0)(ref))(function () {\n                return Control_Applicative.pure(Effect_Aff.applicativeAff)(v1.value1);\n              });\n            }\n\n            ;\n\n            if (v1 instanceof Halogen_Query_HalogenM.Lift) {\n              return v1.value0;\n            }\n\n            ;\n\n            if (v1 instanceof Halogen_Query_HalogenM.ChildQuery) {\n              return evalChildQuery(ref)(v1.value0);\n            }\n\n            ;\n\n            if (v1 instanceof Halogen_Query_HalogenM.Raise) {\n              return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref.read(ref)))(function (v2) {\n                return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref.read(v2.handlerRef)))(function (handler) {\n                  return Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)(queueOrRun(v2.pendingOuts)(handler(v1.value0)))(function () {\n                    return Control_Applicative.pure(Effect_Aff.applicativeAff)(v1.value1);\n                  });\n                });\n              });\n            }\n\n            ;\n\n            if (v1 instanceof Halogen_Query_HalogenM.Par) {\n              return Control_Parallel_Class.sequential(Effect_Aff.parallelAff)(Control_Applicative_Free.retractFreeAp(Effect_Aff.applicativeParAff)(Control_Applicative_Free.hoistFreeAp(function () {\n                var $85 = Control_Parallel_Class.parallel(Effect_Aff.parallelAff);\n                var $86 = evalM(render)(ref);\n                return function ($87) {\n                  return $85($86($87));\n                };\n              }())(v1.value0)));\n            }\n\n            ;\n\n            if (v1 instanceof Halogen_Query_HalogenM.Fork) {\n              return Control_Bind.bind(Effect_Aff.bindAff)(fresh(Halogen_Query_HalogenM.ForkId)(ref))(function (fid) {\n                return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref.read(ref)))(function (v2) {\n                  return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref[\"new\"](false)))(function (doneRef) {\n                    return Control_Bind.bind(Effect_Aff.bindAff)(Control_Monad_Fork_Class.fork(Control_Monad_Fork_Class.monadForkAff)(Effect_Aff[\"finally\"](Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(function __do() {\n                      Effect_Ref.modify_(Data_Map_Internal[\"delete\"](Halogen_Query_HalogenM.ordForkId)(fid))(v2.forks)();\n                      return Effect_Ref.write(true)(doneRef)();\n                    }))(evalM(render)(ref)(v1.value0))))(function (fiber) {\n                      return Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Control_Monad.unlessM(Effect.monadEffect)(Effect_Ref.read(doneRef))(Effect_Ref.modify_(Data_Map_Internal.insert(Halogen_Query_HalogenM.ordForkId)(fid)(fiber))(v2.forks))))(function () {\n                        return Control_Applicative.pure(Effect_Aff.applicativeAff)(v1.value1(fid));\n                      });\n                    });\n                  });\n                });\n              });\n            }\n\n            ;\n\n            if (v1 instanceof Halogen_Query_HalogenM.Kill) {\n              return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref.read(ref)))(function (v2) {\n                return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref.read(v2.forks)))(function (forkMap) {\n                  return Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)(Data_Foldable.traverse_(Effect_Aff.applicativeAff)(Data_Foldable.foldableMaybe)(Effect_Aff.killFiber(Effect_Exception.error(\"Cancelled\")))(Data_Map_Internal.lookup(Halogen_Query_HalogenM.ordForkId)(v1.value0)(forkMap)))(function () {\n                    return Control_Applicative.pure(Effect_Aff.applicativeAff)(v1.value1);\n                  });\n                });\n              });\n            }\n\n            ;\n\n            if (v1 instanceof Halogen_Query_HalogenM.GetRef) {\n              return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref.read(ref)))(function (v2) {\n                return Control_Applicative.pure(Effect_Aff.applicativeAff)(v1.value1(Data_Map_Internal.lookup(Data_Ord.ordString)(v1.value0)(v2.refs)));\n              });\n            }\n\n            ;\n            throw new Error(\"Failed pattern match at Halogen.Aff.Driver.Eval (line 82, column 12 - line 146, column 33): \" + [v1.constructor.name]);\n          };\n        };\n\n        return Control_Monad_Free.foldFree(Effect_Aff.monadRecAff)(go(initRef))(v);\n      };\n    };\n  };\n\n  var evalF = function evalF(render) {\n    return function (ref) {\n      return function (v) {\n        if (v instanceof Halogen_Query_Input.RefUpdate) {\n          return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Data_Function.flip(Effect_Ref.modify_)(ref)(Halogen_Aff_Driver_State.mapDriverState(function (st) {\n            return {\n              component: st.component,\n              state: st.state,\n              refs: Data_Map_Internal.alter(Data_Ord.ordString)(Data_Function[\"const\"](v.value1))(v.value0)(st.refs),\n              children: st.children,\n              childrenIn: st.childrenIn,\n              childrenOut: st.childrenOut,\n              selfRef: st.selfRef,\n              handlerRef: st.handlerRef,\n              pendingQueries: st.pendingQueries,\n              pendingOuts: st.pendingOuts,\n              pendingHandlers: st.pendingHandlers,\n              rendering: st.rendering,\n              fresh: st.fresh,\n              subscriptions: st.subscriptions,\n              forks: st.forks,\n              lifecycleHandlers: st.lifecycleHandlers\n            };\n          })));\n        }\n\n        ;\n\n        if (v instanceof Halogen_Query_Input.Action) {\n          return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref.read(ref)))(function (v1) {\n            return evalM(render)(ref)(v1[\"component\"][\"eval\"](new Halogen_Query_HalogenQ.Action(v.value0, Data_Unit.unit)));\n          });\n        }\n\n        ;\n        throw new Error(\"Failed pattern match at Halogen.Aff.Driver.Eval (line 51, column 20 - line 57, column 62): \" + [v.constructor.name]);\n      };\n    };\n  };\n\n  exports[\"evalF\"] = evalF;\n  exports[\"evalQ\"] = evalQ;\n  exports[\"evalM\"] = evalM;\n  exports[\"handleLifecycle\"] = handleLifecycle;\n  exports[\"queueOrRun\"] = queueOrRun;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Halogen.Aff.Driver\"] = $PS[\"Halogen.Aff.Driver\"] || {};\n  var exports = $PS[\"Halogen.Aff.Driver\"];\n  var Control_Applicative = $PS[\"Control.Applicative\"];\n  var Control_Bind = $PS[\"Control.Bind\"];\n  var Control_Category = $PS[\"Control.Category\"];\n  var Control_Coroutine = $PS[\"Control.Coroutine\"];\n  var Control_Monad_Error_Class = $PS[\"Control.Monad.Error.Class\"];\n  var Control_Monad_Fork_Class = $PS[\"Control.Monad.Fork.Class\"];\n  var Control_Monad_Rec_Class = $PS[\"Control.Monad.Rec.Class\"];\n  var Control_Parallel = $PS[\"Control.Parallel\"];\n  var Data_Either = $PS[\"Data.Either\"];\n  var Data_Foldable = $PS[\"Data.Foldable\"];\n  var Data_Function = $PS[\"Data.Function\"];\n  var Data_Functor = $PS[\"Data.Functor\"];\n  var Data_List = $PS[\"Data.List\"];\n  var Data_List_Types = $PS[\"Data.List.Types\"];\n  var Data_Map_Internal = $PS[\"Data.Map.Internal\"];\n  var Data_Maybe = $PS[\"Data.Maybe\"];\n  var Data_Ord = $PS[\"Data.Ord\"];\n  var Data_Unit = $PS[\"Data.Unit\"];\n  var Effect = $PS[\"Effect\"];\n  var Effect_Aff = $PS[\"Effect.Aff\"];\n  var Effect_Aff_AVar = $PS[\"Effect.Aff.AVar\"];\n  var Effect_Class = $PS[\"Effect.Class\"];\n  var Effect_Console = $PS[\"Effect.Console\"];\n  var Effect_Exception = $PS[\"Effect.Exception\"];\n  var Effect_Ref = $PS[\"Effect.Ref\"];\n  var Halogen_Aff_Driver_Eval = $PS[\"Halogen.Aff.Driver.Eval\"];\n  var Halogen_Aff_Driver_State = $PS[\"Halogen.Aff.Driver.State\"];\n  var Halogen_Component = $PS[\"Halogen.Component\"];\n  var Halogen_Data_Slot = $PS[\"Halogen.Data.Slot\"];\n  var Halogen_Query_EventSource = $PS[\"Halogen.Query.EventSource\"];\n  var Halogen_Query_HalogenQ = $PS[\"Halogen.Query.HalogenQ\"];\n  var Halogen_Query_Input = $PS[\"Halogen.Query.Input\"];\n  var newLifecycleHandlers = Effect_Ref[\"new\"]({\n    initializers: Data_List_Types.Nil.value,\n    finalizers: Data_List_Types.Nil.value\n  });\n  var handleAff = Effect_Aff.runAff_(Data_Either.either(Effect_Exception.throwException)(Data_Function[\"const\"](Control_Applicative.pure(Effect.applicativeEffect)(Data_Unit.unit))));\n\n  var handlePending = function handlePending(ref) {\n    return function __do() {\n      var queue = Effect_Ref.read(ref)();\n      Effect_Ref.write(Data_Maybe.Nothing.value)(ref)();\n      return Data_Foldable.for_(Effect.applicativeEffect)(Data_Foldable.foldableMaybe)(queue)(function () {\n        var $25 = Data_Foldable.traverse_(Effect_Aff.applicativeAff)(Data_List_Types.foldableList)(Control_Monad_Fork_Class.fork(Control_Monad_Fork_Class.monadForkAff));\n        return function ($26) {\n          return handleAff($25(Data_List.reverse($26)));\n        };\n      }())();\n    };\n  };\n\n  var cleanupSubscriptionsAndForks = function cleanupSubscriptionsAndForks(v) {\n    return function __do() {\n      Control_Bind.bindFlipped(Effect.bindEffect)(Data_Foldable.traverse_(Effect.applicativeEffect)(Data_Foldable.foldableMaybe)(function () {\n        var $27 = Data_Foldable.traverse_(Effect_Aff.applicativeAff)(Data_Map_Internal.foldableMap)(function () {\n          var $29 = Control_Monad_Fork_Class.fork(Control_Monad_Fork_Class.monadForkAff);\n          return function ($30) {\n            return $29(Halogen_Query_EventSource.finalize($30));\n          };\n        }());\n        return function ($28) {\n          return handleAff($27($28));\n        };\n      }()))(Effect_Ref.read(v.subscriptions))();\n      Effect_Ref.write(Data_Maybe.Nothing.value)(v.subscriptions)();\n      Control_Bind.bindFlipped(Effect.bindEffect)(Data_Foldable.traverse_(Effect.applicativeEffect)(Data_Map_Internal.foldableMap)(function () {\n        var $31 = Effect_Aff.killFiber(Effect_Exception.error(\"finalized\"));\n        return function ($32) {\n          return handleAff($31($32));\n        };\n      }()))(Effect_Ref.read(v.forks))();\n      return Effect_Ref.write(Data_Map_Internal.empty)(v.forks)();\n    };\n  };\n\n  var runUI = function runUI(renderSpec) {\n    return function (component) {\n      return function (i) {\n        var subscribe = function subscribe(fresh) {\n          return function (ref) {\n            return function (consumer) {\n              return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Aff_AVar.empty)(function (inputVar) {\n                return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(function __do() {\n                  var listenerId = Effect_Ref.read(fresh)();\n                  Effect_Ref.modify_(function (v) {\n                    return v + 1 | 0;\n                  })(fresh)();\n                  Effect_Ref.modify_(Data_Map_Internal.insert(Data_Ord.ordInt)(listenerId)(inputVar))(ref)();\n                  return listenerId;\n                }))(function (listenerId) {\n                  var producer = Control_Coroutine.producer(Effect_Aff.monadAff)(Data_Functor.map(Effect_Aff.functorAff)(Data_Either.either(Data_Function[\"const\"](new Data_Either.Right(Data_Unit.unit)))(Data_Either.Left.create))(Control_Monad_Error_Class[\"try\"](Effect_Aff.monadErrorAff)(Effect_Aff_AVar.take(inputVar))));\n                  return Data_Functor[\"void\"](Effect_Aff.functorAff)(Control_Monad_Fork_Class.fork(Control_Monad_Fork_Class.monadForkAff)(Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)(Control_Coroutine.runProcess(Effect_Aff.monadRecAff)(Control_Coroutine.connect(Effect_Aff.monadRecAff)(Effect_Aff.parallelAff)(producer)(consumer)))(function () {\n                    return Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref.modify_(Data_Map_Internal[\"delete\"](Data_Ord.ordInt)(listenerId))(ref)))(function () {\n                      return Effect_Aff_AVar.kill(Effect_Exception.error(\"ended\"))(inputVar);\n                    });\n                  })));\n                });\n              });\n            };\n          };\n        };\n\n        var rootHandler = function rootHandler(ref) {\n          return function (message) {\n            return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref.read(ref)))(function (listeners) {\n              return Data_Foldable.traverse_(Effect_Aff.applicativeAff)(Data_Map_Internal.foldableMap)(Control_Monad_Fork_Class.fork(Control_Monad_Fork_Class.monadForkAff))(Data_Functor.map(Data_Map_Internal.functorMap)(Effect_Aff_AVar.put(message))(listeners));\n            });\n          };\n        };\n\n        var squashChildInitializers = function squashChildInitializers(lchs) {\n          return function (preInits) {\n            return Halogen_Aff_Driver_State.unDriverStateX(function (st) {\n              var parentInitializer = Halogen_Aff_Driver_Eval.evalM(render)(st.selfRef)(st[\"component\"][\"eval\"](new Halogen_Query_HalogenQ.Initialize(Data_Unit.unit)));\n              return Effect_Ref.modify_(function (handlers) {\n                return {\n                  initializers: new Data_List_Types.Cons(Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)(Control_Parallel.parSequence_(Effect_Aff.parallelAff)(Data_List_Types.foldableList)(Data_List.reverse(handlers.initializers)))(function () {\n                    return Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)(parentInitializer)(function () {\n                      return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(function __do() {\n                        handlePending(st.pendingQueries)();\n                        return handlePending(st.pendingOuts)();\n                      });\n                    });\n                  }), preInits),\n                  finalizers: handlers.finalizers\n                };\n              })(lchs);\n            });\n          };\n        };\n\n        var runComponent = function runComponent(lchs) {\n          return function (handler) {\n            return function (j) {\n              return Halogen_Component.unComponent(function (c) {\n                return function __do() {\n                  var lchs$prime = newLifecycleHandlers();\n                  var $$var = Halogen_Aff_Driver_State.initDriverState(c)(j)(handler)(lchs$prime)();\n                  var pre = Effect_Ref.read(lchs)();\n                  Effect_Ref.write({\n                    initializers: Data_List_Types.Nil.value,\n                    finalizers: pre.finalizers\n                  })(lchs)();\n                  Control_Bind.bindFlipped(Effect.bindEffect)(Halogen_Aff_Driver_State.unDriverStateX(function () {\n                    var $33 = render(lchs);\n                    return function ($34) {\n                      return $33(function (v) {\n                        return v.selfRef;\n                      }($34));\n                    };\n                  }()))(Effect_Ref.read($$var))();\n                  Control_Bind.bindFlipped(Effect.bindEffect)(squashChildInitializers(lchs)(pre.initializers))(Effect_Ref.read($$var))();\n                  return $$var;\n                };\n              });\n            };\n          };\n        };\n\n        var renderChild = function renderChild(lchs) {\n          return function (handler) {\n            return function (childrenInRef) {\n              return function (childrenOutRef) {\n                return Halogen_Component.unComponentSlot(function (slot) {\n                  return function __do() {\n                    var childrenIn = Data_Functor.map(Effect.functorEffect)(slot.pop)(Effect_Ref.read(childrenInRef))();\n\n                    var $$var = function () {\n                      if (childrenIn instanceof Data_Maybe.Just) {\n                        Effect_Ref.write(childrenIn.value0.value1)(childrenInRef)();\n                        var dsx = Effect_Ref.read(childrenIn.value0.value0)();\n                        Halogen_Aff_Driver_State.unDriverStateX(function (st) {\n                          return function __do() {\n                            Data_Function.flip(Effect_Ref.write)(st.handlerRef)(function () {\n                              var $35 = Data_Maybe.maybe(Control_Applicative.pure(Effect_Aff.applicativeAff)(Data_Unit.unit))(handler);\n                              return function ($36) {\n                                return $35(slot.output($36));\n                              };\n                            }())();\n                            return handleAff(Halogen_Aff_Driver_Eval.evalM(render)(st.selfRef)(st[\"component\"][\"eval\"](new Halogen_Query_HalogenQ.Receive(slot.input, Data_Unit.unit))))();\n                          };\n                        })(dsx)();\n                        return childrenIn.value0.value0;\n                      }\n\n                      ;\n\n                      if (childrenIn instanceof Data_Maybe.Nothing) {\n                        return runComponent(lchs)(function () {\n                          var $37 = Data_Maybe.maybe(Control_Applicative.pure(Effect_Aff.applicativeAff)(Data_Unit.unit))(handler);\n                          return function ($38) {\n                            return $37(slot.output($38));\n                          };\n                        }())(slot.input)(slot.component)();\n                      }\n\n                      ;\n                      throw new Error(\"Failed pattern match at Halogen.Aff.Driver (line 236, column 14 - line 245, column 98): \" + [childrenIn.constructor.name]);\n                    }();\n\n                    var isDuplicate = Data_Functor.map(Effect.functorEffect)(function ($39) {\n                      return Data_Maybe.isJust(slot.get($39));\n                    })(Effect_Ref.read(childrenOutRef))();\n                    Control_Applicative.when(Effect.applicativeEffect)(isDuplicate)(Effect_Console.warn(\"Halogen: Duplicate slot address was detected during rendering, unexpected results may occur\"))();\n                    Effect_Ref.modify_(slot.set($$var))(childrenOutRef)();\n                    return Control_Bind.bind(Effect.bindEffect)(Effect_Ref.read($$var))(Halogen_Aff_Driver_State.renderStateX(Effect.functorEffect)(function (v) {\n                      if (v instanceof Data_Maybe.Nothing) {\n                        return Effect_Exception[\"throw\"](\"Halogen internal error: child was not initialized in renderChild\");\n                      }\n\n                      ;\n\n                      if (v instanceof Data_Maybe.Just) {\n                        return Control_Applicative.pure(Effect.applicativeEffect)(renderSpec.renderChild(v.value0));\n                      }\n\n                      ;\n                      throw new Error(\"Failed pattern match at Halogen.Aff.Driver (line 250, column 37 - line 252, column 50): \" + [v.constructor.name]);\n                    }))();\n                  };\n                });\n              };\n            };\n          };\n        };\n\n        var render = function render(lchs) {\n          return function ($$var) {\n            return function __do() {\n              var v = Effect_Ref.read($$var)();\n              var shouldProcessHandlers = Data_Functor.map(Effect.functorEffect)(Data_Maybe.isNothing)(Effect_Ref.read(v.pendingHandlers))();\n              Control_Applicative.when(Effect.applicativeEffect)(shouldProcessHandlers)(Effect_Ref.write(new Data_Maybe.Just(Data_List_Types.Nil.value))(v.pendingHandlers))();\n              Effect_Ref.write(Halogen_Data_Slot.empty)(v.childrenOut)();\n              Effect_Ref.write(v.children)(v.childrenIn)();\n              var selfRef = Control_Category.identity(Control_Category.categoryFn)(v.selfRef);\n              var pendingQueries = Control_Category.identity(Control_Category.categoryFn)(v.pendingQueries);\n              var pendingHandlers = Control_Category.identity(Control_Category.categoryFn)(v.pendingHandlers);\n\n              var handler = function () {\n                var $40 = Halogen_Aff_Driver_Eval.queueOrRun(pendingHandlers);\n                var $41 = Data_Functor[\"void\"](Effect_Aff.functorAff);\n                var $42 = Halogen_Aff_Driver_Eval.evalF(render)(selfRef);\n                return function ($43) {\n                  return $40($41($42($43)));\n                };\n              }();\n\n              var childHandler = function () {\n                var $44 = Halogen_Aff_Driver_Eval.queueOrRun(pendingQueries);\n                return function ($45) {\n                  return $44(handler(Halogen_Query_Input.Action.create($45)));\n                };\n              }();\n\n              var rendering = renderSpec.render(function ($46) {\n                return handleAff(handler($46));\n              })(renderChild(lchs)(childHandler)(v.childrenIn)(v.childrenOut))(v.component.render(v.state))(v.rendering)();\n              var children = Effect_Ref.read(v.childrenOut)();\n              var childrenIn = Effect_Ref.read(v.childrenIn)();\n              Halogen_Data_Slot.foreachSlot(Effect.applicativeEffect)(childrenIn)(function (v1) {\n                return function __do() {\n                  var childDS = Effect_Ref.read(v1)();\n                  Halogen_Aff_Driver_State.renderStateX_(Effect.applicativeEffect)(renderSpec.removeChild)(childDS)();\n                  return finalize(lchs)(childDS)();\n                };\n              })();\n              Data_Function.flip(Effect_Ref.modify_)(v.selfRef)(Halogen_Aff_Driver_State.mapDriverState(function (ds$prime) {\n                return {\n                  component: ds$prime.component,\n                  state: ds$prime.state,\n                  refs: ds$prime.refs,\n                  children: children,\n                  childrenIn: ds$prime.childrenIn,\n                  childrenOut: ds$prime.childrenOut,\n                  selfRef: ds$prime.selfRef,\n                  handlerRef: ds$prime.handlerRef,\n                  pendingQueries: ds$prime.pendingQueries,\n                  pendingOuts: ds$prime.pendingOuts,\n                  pendingHandlers: ds$prime.pendingHandlers,\n                  rendering: new Data_Maybe.Just(rendering),\n                  fresh: ds$prime.fresh,\n                  subscriptions: ds$prime.subscriptions,\n                  forks: ds$prime.forks,\n                  lifecycleHandlers: ds$prime.lifecycleHandlers\n                };\n              }))();\n              return Control_Applicative.when(Effect.applicativeEffect)(shouldProcessHandlers)(Data_Function.flip(Control_Monad_Rec_Class.tailRecM(Control_Monad_Rec_Class.monadRecEffect))(Data_Unit.unit)(function (v1) {\n                return function __do() {\n                  var handlers = Effect_Ref.read(pendingHandlers)();\n                  Effect_Ref.write(new Data_Maybe.Just(Data_List_Types.Nil.value))(pendingHandlers)();\n                  Data_Foldable.traverse_(Effect.applicativeEffect)(Data_Foldable.foldableMaybe)(function () {\n                    var $47 = Data_Foldable.traverse_(Effect_Aff.applicativeAff)(Data_List_Types.foldableList)(Control_Monad_Fork_Class.fork(Control_Monad_Fork_Class.monadForkAff));\n                    return function ($48) {\n                      return handleAff($47(Data_List.reverse($48)));\n                    };\n                  }())(handlers)();\n                  var mmore = Effect_Ref.read(pendingHandlers)();\n                  var $21 = Data_Maybe.maybe(false)(Data_List[\"null\"])(mmore);\n\n                  if ($21) {\n                    return Data_Functor.voidLeft(Effect.functorEffect)(Effect_Ref.write(Data_Maybe.Nothing.value)(pendingHandlers))(new Control_Monad_Rec_Class.Done(Data_Unit.unit))();\n                  }\n\n                  ;\n                  return new Control_Monad_Rec_Class.Loop(Data_Unit.unit);\n                };\n              }))();\n            };\n          };\n        };\n\n        var finalize = function finalize(lchs) {\n          return Halogen_Aff_Driver_State.unDriverStateX(function (st) {\n            return function __do() {\n              cleanupSubscriptionsAndForks(st)();\n              var f = Halogen_Aff_Driver_Eval.evalM(render)(st.selfRef)(st[\"component\"][\"eval\"](new Halogen_Query_HalogenQ.Finalize(Data_Unit.unit)));\n              Effect_Ref.modify_(function (handlers) {\n                return {\n                  initializers: handlers.initializers,\n                  finalizers: new Data_List_Types.Cons(f, handlers.finalizers)\n                };\n              })(lchs)();\n              return Halogen_Data_Slot.foreachSlot(Effect.applicativeEffect)(st.children)(function (v) {\n                return function __do() {\n                  var dsx = Effect_Ref.read(v)();\n                  return finalize(lchs)(dsx)();\n                };\n              })();\n            };\n          });\n        };\n\n        var evalDriver = function evalDriver(disposed) {\n          return function (ref) {\n            return function (q) {\n              return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref.read(disposed)))(function (v) {\n                if (v) {\n                  return Control_Applicative.pure(Effect_Aff.applicativeAff)(Data_Maybe.Nothing.value);\n                }\n\n                ;\n                return Halogen_Aff_Driver_Eval.evalQ(render)(ref)(q);\n              });\n            };\n          };\n        };\n\n        var dispose = function dispose(disposed) {\n          return function (lchs) {\n            return function (dsx) {\n              return function (subsRef) {\n                return Halogen_Aff_Driver_Eval.handleLifecycle(lchs)(function __do() {\n                  var v = Effect_Ref.read(disposed)();\n\n                  if (v) {\n                    return Data_Unit.unit;\n                  }\n\n                  ;\n                  Effect_Ref.write(true)(disposed)();\n                  Control_Bind.bindFlipped(Effect.bindEffect)(Data_Foldable.traverse_(Effect.applicativeEffect)(Data_Map_Internal.foldableMap)(function () {\n                    var $49 = Effect_Aff_AVar.kill(Effect_Exception.error(\"disposed\"));\n                    return function ($50) {\n                      return Effect_Aff.launchAff_($49($50));\n                    };\n                  }()))(Effect_Ref.read(subsRef))();\n                  finalize(lchs)(dsx)();\n                  return Halogen_Aff_Driver_State.unDriverStateX(function () {\n                    var $51 = Data_Foldable.traverse_(Effect.applicativeEffect)(Data_Foldable.foldableMaybe)(renderSpec.dispose);\n                    return function ($52) {\n                      return $51(function (v1) {\n                        return v1.rendering;\n                      }($52));\n                    };\n                  }())(dsx)();\n                });\n              };\n            };\n          };\n        };\n\n        return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(newLifecycleHandlers))(function (lchs) {\n          return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref[\"new\"](0)))(function (fresh) {\n            return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref[\"new\"](false)))(function (disposed) {\n              return Halogen_Aff_Driver_Eval.handleLifecycle(lchs)(function __do() {\n                var listeners = Effect_Ref[\"new\"](Data_Map_Internal.empty)();\n                var dsx = Control_Bind.bindFlipped(Effect.bindEffect)(Effect_Ref.read)(runComponent(lchs)(rootHandler(listeners))(i)(component))();\n                return Halogen_Aff_Driver_State.unDriverStateX(function (st) {\n                  return Control_Applicative.pure(Effect.applicativeEffect)({\n                    query: evalDriver(disposed)(st.selfRef),\n                    subscribe: subscribe(fresh)(listeners),\n                    dispose: dispose(disposed)(lchs)(dsx)(listeners)\n                  });\n                })(dsx)();\n              });\n            });\n          });\n        });\n      };\n    };\n  };\n\n  exports[\"runUI\"] = runUI;\n})(PS);\n\n(function (exports) {\n  \"use strict\";\n\n  exports._querySelector = function (selector) {\n    return function (node) {\n      return function () {\n        return node.querySelector(selector);\n      };\n    };\n  };\n})(PS[\"Web.DOM.ParentNode\"] = PS[\"Web.DOM.ParentNode\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Web.DOM.ParentNode\"] = $PS[\"Web.DOM.ParentNode\"] || {};\n  var exports = $PS[\"Web.DOM.ParentNode\"];\n  var $foreign = $PS[\"Web.DOM.ParentNode\"];\n  var Data_Functor = $PS[\"Data.Functor\"];\n  var Data_Nullable = $PS[\"Data.Nullable\"];\n  var Effect = $PS[\"Effect\"];\n\n  var querySelector = function querySelector(qs) {\n    var $3 = Data_Functor.map(Effect.functorEffect)(Data_Nullable.toMaybe);\n    var $4 = $foreign[\"_querySelector\"](qs);\n    return function ($5) {\n      return $3($4($5));\n    };\n  };\n\n  exports[\"querySelector\"] = querySelector;\n})(PS);\n\n(function (exports) {\n  /* global window */\n  \"use strict\";\n\n  exports.window = function () {\n    return window;\n  };\n})(PS[\"Web.HTML\"] = PS[\"Web.HTML\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Web.HTML\"] = $PS[\"Web.HTML\"] || {};\n  var exports = $PS[\"Web.HTML\"];\n  var $foreign = $PS[\"Web.HTML\"];\n  exports[\"window\"] = $foreign.window;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Web.HTML.Event.EventTypes\"] = $PS[\"Web.HTML.Event.EventTypes\"] || {};\n  var exports = $PS[\"Web.HTML.Event.EventTypes\"];\n  var domcontentloaded = \"DOMContentLoaded\";\n  exports[\"domcontentloaded\"] = domcontentloaded;\n})(PS);\n\n(function (exports) {\n  \"use strict\";\n\n  exports._readyState = function (doc) {\n    return function () {\n      return doc.readyState;\n    };\n  };\n})(PS[\"Web.HTML.HTMLDocument\"] = PS[\"Web.HTML.HTMLDocument\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Web.HTML.HTMLDocument.ReadyState\"] = $PS[\"Web.HTML.HTMLDocument.ReadyState\"] || {};\n  var exports = $PS[\"Web.HTML.HTMLDocument.ReadyState\"];\n  var Data_Maybe = $PS[\"Data.Maybe\"];\n\n  var Loading = function () {\n    function Loading() {}\n\n    ;\n    Loading.value = new Loading();\n    return Loading;\n  }();\n\n  var Interactive = function () {\n    function Interactive() {}\n\n    ;\n    Interactive.value = new Interactive();\n    return Interactive;\n  }();\n\n  var Complete = function () {\n    function Complete() {}\n\n    ;\n    Complete.value = new Complete();\n    return Complete;\n  }();\n\n  var parse = function parse(v) {\n    if (v === \"loading\") {\n      return new Data_Maybe.Just(Loading.value);\n    }\n\n    ;\n\n    if (v === \"interactive\") {\n      return new Data_Maybe.Just(Interactive.value);\n    }\n\n    ;\n\n    if (v === \"complete\") {\n      return new Data_Maybe.Just(Complete.value);\n    }\n\n    ;\n    return Data_Maybe.Nothing.value;\n  };\n\n  exports[\"Loading\"] = Loading;\n  exports[\"parse\"] = parse;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Web.HTML.HTMLDocument\"] = $PS[\"Web.HTML.HTMLDocument\"] || {};\n  var exports = $PS[\"Web.HTML.HTMLDocument\"];\n  var $foreign = $PS[\"Web.HTML.HTMLDocument\"];\n  var Data_Functor = $PS[\"Data.Functor\"];\n  var Data_Maybe = $PS[\"Data.Maybe\"];\n  var Effect = $PS[\"Effect\"];\n  var Unsafe_Coerce = $PS[\"Unsafe.Coerce\"];\n  var Web_HTML_HTMLDocument_ReadyState = $PS[\"Web.HTML.HTMLDocument.ReadyState\"];\n  var toParentNode = Unsafe_Coerce.unsafeCoerce;\n  var toDocument = Unsafe_Coerce.unsafeCoerce;\n\n  var readyState = function () {\n    var $0 = Data_Functor.map(Effect.functorEffect)(function () {\n      var $2 = Data_Maybe.fromMaybe(Web_HTML_HTMLDocument_ReadyState.Loading.value);\n      return function ($3) {\n        return $2(Web_HTML_HTMLDocument_ReadyState.parse($3));\n      };\n    }());\n    return function ($1) {\n      return $0($foreign[\"_readyState\"]($1));\n    };\n  }();\n\n  exports[\"toDocument\"] = toDocument;\n  exports[\"toParentNode\"] = toParentNode;\n  exports[\"readyState\"] = readyState;\n})(PS);\n\n(function (exports) {\n  \"use strict\";\n\n  exports._read = function (nothing, just, value) {\n    var tag = Object.prototype.toString.call(value);\n\n    if (tag.indexOf(\"[object HTML\") === 0 && tag.indexOf(\"Element]\") === tag.length - 8) {\n      return just(value);\n    } else {\n      return nothing;\n    }\n  };\n})(PS[\"Web.HTML.HTMLElement\"] = PS[\"Web.HTML.HTMLElement\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Web.HTML.HTMLElement\"] = $PS[\"Web.HTML.HTMLElement\"] || {};\n  var exports = $PS[\"Web.HTML.HTMLElement\"];\n  var $foreign = $PS[\"Web.HTML.HTMLElement\"];\n  var Data_Maybe = $PS[\"Data.Maybe\"];\n  var Unsafe_Coerce = $PS[\"Unsafe.Coerce\"];\n  var toNode = Unsafe_Coerce.unsafeCoerce;\n\n  var fromElement = function fromElement(x) {\n    return $foreign[\"_read\"](Data_Maybe.Nothing.value, Data_Maybe.Just.create, x);\n  };\n\n  exports[\"fromElement\"] = fromElement;\n  exports[\"toNode\"] = toNode;\n})(PS);\n\n(function (exports) {\n  \"use strict\";\n\n  exports.document = function (window) {\n    return function () {\n      return window.document;\n    };\n  };\n})(PS[\"Web.HTML.Window\"] = PS[\"Web.HTML.Window\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Web.HTML.Window\"] = $PS[\"Web.HTML.Window\"] || {};\n  var exports = $PS[\"Web.HTML.Window\"];\n  var $foreign = $PS[\"Web.HTML.Window\"];\n  var Unsafe_Coerce = $PS[\"Unsafe.Coerce\"];\n  var toEventTarget = Unsafe_Coerce.unsafeCoerce;\n  exports[\"toEventTarget\"] = toEventTarget;\n  exports[\"document\"] = $foreign.document;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Halogen.Aff.Util\"] = $PS[\"Halogen.Aff.Util\"] || {};\n  var exports = $PS[\"Halogen.Aff.Util\"];\n  var Control_Applicative = $PS[\"Control.Applicative\"];\n  var Control_Bind = $PS[\"Control.Bind\"];\n  var Control_Monad_Error_Class = $PS[\"Control.Monad.Error.Class\"];\n  var Data_Either = $PS[\"Data.Either\"];\n  var Data_Function = $PS[\"Data.Function\"];\n  var Data_Functor = $PS[\"Data.Functor\"];\n  var Data_Maybe = $PS[\"Data.Maybe\"];\n  var Data_Unit = $PS[\"Data.Unit\"];\n  var Effect = $PS[\"Effect\"];\n  var Effect_Aff = $PS[\"Effect.Aff\"];\n  var Effect_Class = $PS[\"Effect.Class\"];\n  var Effect_Exception = $PS[\"Effect.Exception\"];\n  var Web_DOM_ParentNode = $PS[\"Web.DOM.ParentNode\"];\n  var Web_Event_EventTarget = $PS[\"Web.Event.EventTarget\"];\n  var Web_HTML = $PS[\"Web.HTML\"];\n  var Web_HTML_Event_EventTypes = $PS[\"Web.HTML.Event.EventTypes\"];\n  var Web_HTML_HTMLDocument = $PS[\"Web.HTML.HTMLDocument\"];\n  var Web_HTML_HTMLDocument_ReadyState = $PS[\"Web.HTML.HTMLDocument.ReadyState\"];\n  var Web_HTML_HTMLElement = $PS[\"Web.HTML.HTMLElement\"];\n  var Web_HTML_Window = $PS[\"Web.HTML.Window\"];\n\n  var selectElement = function selectElement(query) {\n    return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Control_Bind.bindFlipped(Effect.bindEffect)(Control_Bind.composeKleisliFlipped(Effect.bindEffect)(function () {\n      var $2 = Web_DOM_ParentNode.querySelector(query);\n      return function ($3) {\n        return $2(Web_HTML_HTMLDocument.toParentNode($3));\n      };\n    }())(Web_HTML_Window.document))(Web_HTML.window)))(function (mel) {\n      return Control_Applicative.pure(Effect_Aff.applicativeAff)(Control_Bind.bindFlipped(Data_Maybe.bindMaybe)(Web_HTML_HTMLElement.fromElement)(mel));\n    });\n  };\n\n  var runHalogenAff = Effect_Aff.runAff_(Data_Either.either(Effect_Exception.throwException)(Data_Function[\"const\"](Control_Applicative.pure(Effect.applicativeEffect)(Data_Unit.unit))));\n  var awaitLoad = Effect_Aff.makeAff(function (callback) {\n    return function __do() {\n      var rs = Control_Bind.bindFlipped(Effect.bindEffect)(Web_HTML_HTMLDocument.readyState)(Control_Bind.bindFlipped(Effect.bindEffect)(Web_HTML_Window.document)(Web_HTML.window))();\n\n      if (rs instanceof Web_HTML_HTMLDocument_ReadyState.Loading) {\n        var et = Data_Functor.map(Effect.functorEffect)(Web_HTML_Window.toEventTarget)(Web_HTML.window)();\n        var listener = Web_Event_EventTarget.eventListener(function (v) {\n          return callback(new Data_Either.Right(Data_Unit.unit));\n        })();\n        Web_Event_EventTarget.addEventListener(Web_HTML_Event_EventTypes.domcontentloaded)(listener)(false)(et)();\n        return Effect_Aff.effectCanceler(Web_Event_EventTarget.removeEventListener(Web_HTML_Event_EventTypes.domcontentloaded)(listener)(false)(et));\n      }\n\n      ;\n      callback(new Data_Either.Right(Data_Unit.unit))();\n      return Effect_Aff.nonCanceler;\n    };\n  });\n  var awaitBody = Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)(awaitLoad)(function () {\n    return Control_Bind.bind(Effect_Aff.bindAff)(selectElement(\"body\"))(function (body) {\n      return Data_Maybe.maybe(Control_Monad_Error_Class.throwError(Effect_Aff.monadThrowAff)(Effect_Exception.error(\"Could not find body\")))(Control_Applicative.pure(Effect_Aff.applicativeAff))(body);\n    });\n  });\n  exports[\"awaitBody\"] = awaitBody;\n  exports[\"runHalogenAff\"] = runHalogenAff;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Web.DOM.Element\"] = $PS[\"Web.DOM.Element\"] || {};\n  var exports = $PS[\"Web.DOM.Element\"];\n  var Unsafe_Coerce = $PS[\"Unsafe.Coerce\"];\n  var toNode = Unsafe_Coerce.unsafeCoerce;\n  exports[\"toNode\"] = toNode;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Halogen.VDom.DOM\"] = $PS[\"Halogen.VDom.DOM\"] || {};\n  var exports = $PS[\"Halogen.VDom.DOM\"];\n  var Data_Array = $PS[\"Data.Array\"];\n  var Data_Boolean = $PS[\"Data.Boolean\"];\n  var Data_Maybe = $PS[\"Data.Maybe\"];\n  var Data_Nullable = $PS[\"Data.Nullable\"];\n  var Data_Tuple = $PS[\"Data.Tuple\"];\n  var Halogen_VDom_Machine = $PS[\"Halogen.VDom.Machine\"];\n  var Halogen_VDom_Types = $PS[\"Halogen.VDom.Types\"];\n  var Halogen_VDom_Util = $PS[\"Halogen.VDom.Util\"];\n  var Web_DOM_Element = $PS[\"Web.DOM.Element\"];\n\n  var haltWidget = function haltWidget(v) {\n    return Halogen_VDom_Machine.halt(v.widget);\n  };\n\n  var patchWidget = function patchWidget(state, vdom) {\n    if (vdom instanceof Halogen_VDom_Types.Grafted) {\n      return patchWidget(state, Halogen_VDom_Types.runGraft(vdom.value0));\n    }\n\n    ;\n\n    if (vdom instanceof Halogen_VDom_Types.Widget) {\n      var res = Halogen_VDom_Machine.step(state.widget, vdom.value0);\n      var res$prime = Halogen_VDom_Machine.unStep(function (v) {\n        return Halogen_VDom_Machine.mkStep(new Halogen_VDom_Machine.Step(v.value0, {\n          build: state.build,\n          widget: res\n        }, patchWidget, haltWidget));\n      })(res);\n      return res$prime;\n    }\n\n    ;\n    haltWidget(state);\n    return state.build(vdom);\n  };\n\n  var haltText = function haltText(v) {\n    var parent = Halogen_VDom_Util.parentNode(v.node);\n    return Halogen_VDom_Util.removeChild(v.node, parent);\n  };\n\n  var patchText = function patchText(state, vdom) {\n    if (vdom instanceof Halogen_VDom_Types.Grafted) {\n      return patchText(state, Halogen_VDom_Types.runGraft(vdom.value0));\n    }\n\n    ;\n\n    if (vdom instanceof Halogen_VDom_Types.Text) {\n      if (state.value === vdom.value0) {\n        return Halogen_VDom_Machine.mkStep(new Halogen_VDom_Machine.Step(state.node, state, patchText, haltText));\n      }\n\n      ;\n\n      if (Data_Boolean.otherwise) {\n        var nextState = {\n          build: state.build,\n          node: state.node,\n          value: vdom.value0\n        };\n        Halogen_VDom_Util.setTextContent(vdom.value0, state.node);\n        return Halogen_VDom_Machine.mkStep(new Halogen_VDom_Machine.Step(state.node, nextState, patchText, haltText));\n      }\n\n      ;\n    }\n\n    ;\n    haltText(state);\n    return state.build(vdom);\n  };\n\n  var haltKeyed = function haltKeyed(v) {\n    var parent = Halogen_VDom_Util.parentNode(v.node);\n    Halogen_VDom_Util.removeChild(v.node, parent);\n    Halogen_VDom_Util.forInE(v.children, function (v1, s) {\n      return Halogen_VDom_Machine.halt(s);\n    });\n    return Halogen_VDom_Machine.halt(v.attrs);\n  };\n\n  var haltElem = function haltElem(v) {\n    var parent = Halogen_VDom_Util.parentNode(v.node);\n    Halogen_VDom_Util.removeChild(v.node, parent);\n    Halogen_VDom_Util.forEachE(v.children, Halogen_VDom_Machine.halt);\n    return Halogen_VDom_Machine.halt(v.attrs);\n  };\n\n  var eqElemSpec = function eqElemSpec(ns1, v, ns2, v1) {\n    var $56 = v === v1;\n\n    if ($56) {\n      if (ns1 instanceof Data_Maybe.Just && ns2 instanceof Data_Maybe.Just && ns1.value0 === ns2.value0) {\n        return true;\n      }\n\n      ;\n\n      if (ns1 instanceof Data_Maybe.Nothing && ns2 instanceof Data_Maybe.Nothing) {\n        return true;\n      }\n\n      ;\n      return false;\n    }\n\n    ;\n    return false;\n  };\n\n  var patchElem = function patchElem(state, vdom) {\n    if (vdom instanceof Halogen_VDom_Types.Grafted) {\n      return patchElem(state, Halogen_VDom_Types.runGraft(vdom.value0));\n    }\n\n    ;\n\n    if (vdom instanceof Halogen_VDom_Types.Elem && eqElemSpec(state.ns, state.name, vdom.value0, vdom.value1)) {\n      var v = Data_Array.length(vdom.value3);\n      var v1 = Data_Array.length(state.children);\n\n      if (v1 === 0 && v === 0) {\n        var attrs2 = Halogen_VDom_Machine.step(state.attrs, vdom.value2);\n        var nextState = {\n          build: state.build,\n          node: state.node,\n          attrs: attrs2,\n          ns: vdom.value0,\n          name: vdom.value1,\n          children: state.children\n        };\n        return Halogen_VDom_Machine.mkStep(new Halogen_VDom_Machine.Step(state.node, nextState, patchElem, haltElem));\n      }\n\n      ;\n\n      var onThis = function onThis(ix, s) {\n        return Halogen_VDom_Machine.halt(s);\n      };\n\n      var onThese = function onThese(ix, s, v2) {\n        var res = Halogen_VDom_Machine.step(s, v2);\n        Halogen_VDom_Util.insertChildIx(ix, Halogen_VDom_Machine.extract(res), state.node);\n        return res;\n      };\n\n      var onThat = function onThat(ix, v2) {\n        var res = state.build(v2);\n        Halogen_VDom_Util.insertChildIx(ix, Halogen_VDom_Machine.extract(res), state.node);\n        return res;\n      };\n\n      var children2 = Halogen_VDom_Util.diffWithIxE(state.children, vdom.value3, onThese, onThis, onThat);\n      var attrs2 = Halogen_VDom_Machine.step(state.attrs, vdom.value2);\n      var nextState = {\n        build: state.build,\n        node: state.node,\n        attrs: attrs2,\n        ns: vdom.value0,\n        name: vdom.value1,\n        children: children2\n      };\n      return Halogen_VDom_Machine.mkStep(new Halogen_VDom_Machine.Step(state.node, nextState, patchElem, haltElem));\n    }\n\n    ;\n    haltElem(state);\n    return state.build(vdom);\n  };\n\n  var patchKeyed = function patchKeyed(state, vdom) {\n    if (vdom instanceof Halogen_VDom_Types.Grafted) {\n      return patchKeyed(state, Halogen_VDom_Types.runGraft(vdom.value0));\n    }\n\n    ;\n\n    if (vdom instanceof Halogen_VDom_Types.Keyed && eqElemSpec(state.ns, state.name, vdom.value0, vdom.value1)) {\n      var v = Data_Array.length(vdom.value3);\n\n      if (state.length === 0 && v === 0) {\n        var attrs2 = Halogen_VDom_Machine.step(state.attrs, vdom.value2);\n        var nextState = {\n          build: state.build,\n          node: state.node,\n          attrs: attrs2,\n          ns: vdom.value0,\n          name: vdom.value1,\n          children: state.children,\n          length: 0\n        };\n        return Halogen_VDom_Machine.mkStep(new Halogen_VDom_Machine.Step(state.node, nextState, patchKeyed, haltKeyed));\n      }\n\n      ;\n\n      var onThis = function onThis(v2, s) {\n        return Halogen_VDom_Machine.halt(s);\n      };\n\n      var onThese = function onThese(v2, ix$prime, s, v3) {\n        var res = Halogen_VDom_Machine.step(s, v3.value1);\n        Halogen_VDom_Util.insertChildIx(ix$prime, Halogen_VDom_Machine.extract(res), state.node);\n        return res;\n      };\n\n      var onThat = function onThat(v2, ix, v3) {\n        var res = state.build(v3.value1);\n        Halogen_VDom_Util.insertChildIx(ix, Halogen_VDom_Machine.extract(res), state.node);\n        return res;\n      };\n\n      var children2 = Halogen_VDom_Util.diffWithKeyAndIxE(state.children, vdom.value3, Data_Tuple.fst, onThese, onThis, onThat);\n      var attrs2 = Halogen_VDom_Machine.step(state.attrs, vdom.value2);\n      var nextState = {\n        build: state.build,\n        node: state.node,\n        attrs: attrs2,\n        ns: vdom.value0,\n        name: vdom.value1,\n        children: children2,\n        length: v\n      };\n      return Halogen_VDom_Machine.mkStep(new Halogen_VDom_Machine.Step(state.node, nextState, patchKeyed, haltKeyed));\n    }\n\n    ;\n    haltKeyed(state);\n    return state.build(vdom);\n  };\n\n  var buildWidget = function buildWidget(v, build, w) {\n    var res = v.buildWidget(v)(w);\n    var res$prime = Halogen_VDom_Machine.unStep(function (v1) {\n      return Halogen_VDom_Machine.mkStep(new Halogen_VDom_Machine.Step(v1.value0, {\n        build: build,\n        widget: res\n      }, patchWidget, haltWidget));\n    })(res);\n    return res$prime;\n  };\n\n  var buildText = function buildText(v, build, s) {\n    var node = Halogen_VDom_Util.createTextNode(s, v.document);\n    var state = {\n      build: build,\n      node: node,\n      value: s\n    };\n    return Halogen_VDom_Machine.mkStep(new Halogen_VDom_Machine.Step(node, state, patchText, haltText));\n  };\n\n  var buildKeyed = function buildKeyed(v, build, ns1, name1, as1, ch1) {\n    var el = Halogen_VDom_Util.createElement(Data_Nullable.toNullable(ns1), name1, v.document);\n    var node = Web_DOM_Element.toNode(el);\n\n    var onChild = function onChild(k, ix, v1) {\n      var res = build(v1.value1);\n      Halogen_VDom_Util.insertChildIx(ix, Halogen_VDom_Machine.extract(res), node);\n      return res;\n    };\n\n    var children = Halogen_VDom_Util.strMapWithIxE(ch1, Data_Tuple.fst, onChild);\n    var attrs = v.buildAttributes(el)(as1);\n    var state = {\n      build: build,\n      node: node,\n      attrs: attrs,\n      ns: ns1,\n      name: name1,\n      children: children,\n      length: Data_Array.length(ch1)\n    };\n    return Halogen_VDom_Machine.mkStep(new Halogen_VDom_Machine.Step(node, state, patchKeyed, haltKeyed));\n  };\n\n  var buildElem = function buildElem(v, build, ns1, name1, as1, ch1) {\n    var el = Halogen_VDom_Util.createElement(Data_Nullable.toNullable(ns1), name1, v.document);\n    var node = Web_DOM_Element.toNode(el);\n\n    var onChild = function onChild(ix, child) {\n      var res = build(child);\n      Halogen_VDom_Util.insertChildIx(ix, Halogen_VDom_Machine.extract(res), node);\n      return res;\n    };\n\n    var children = Halogen_VDom_Util.forE(ch1, onChild);\n    var attrs = v.buildAttributes(el)(as1);\n    var state = {\n      build: build,\n      node: node,\n      attrs: attrs,\n      ns: ns1,\n      name: name1,\n      children: children\n    };\n    return Halogen_VDom_Machine.mkStep(new Halogen_VDom_Machine.Step(node, state, patchElem, haltElem));\n  };\n\n  var buildVDom = function buildVDom(spec) {\n    var build = function build(v) {\n      if (v instanceof Halogen_VDom_Types.Text) {\n        return buildText(spec, build, v.value0);\n      }\n\n      ;\n\n      if (v instanceof Halogen_VDom_Types.Elem) {\n        return buildElem(spec, build, v.value0, v.value1, v.value2, v.value3);\n      }\n\n      ;\n\n      if (v instanceof Halogen_VDom_Types.Keyed) {\n        return buildKeyed(spec, build, v.value0, v.value1, v.value2, v.value3);\n      }\n\n      ;\n\n      if (v instanceof Halogen_VDom_Types.Widget) {\n        return buildWidget(spec, build, v.value0);\n      }\n\n      ;\n\n      if (v instanceof Halogen_VDom_Types.Grafted) {\n        return build(Halogen_VDom_Types.runGraft(v.value0));\n      }\n\n      ;\n      throw new Error(\"Failed pattern match at Halogen.VDom.DOM (line 58, column 27 - line 63, column 52): \" + [v.constructor.name]);\n    };\n\n    return build;\n  };\n\n  exports[\"buildVDom\"] = buildVDom;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Halogen.VDom.Thunk\"] = $PS[\"Halogen.VDom.Thunk\"] || {};\n  var exports = $PS[\"Halogen.VDom.Thunk\"];\n  var Halogen_VDom_DOM = $PS[\"Halogen.VDom.DOM\"];\n  var Halogen_VDom_Machine = $PS[\"Halogen.VDom.Machine\"];\n  var Halogen_VDom_Util = $PS[\"Halogen.VDom.Util\"];\n\n  var Thunk = function () {\n    function Thunk(value0, value1, value2, value3) {\n      this.value0 = value0;\n      this.value1 = value1;\n      this.value2 = value2;\n      this.value3 = value3;\n    }\n\n    ;\n\n    Thunk.create = function (value0) {\n      return function (value1) {\n        return function (value2) {\n          return function (value3) {\n            return new Thunk(value0, value1, value2, value3);\n          };\n        };\n      };\n    };\n\n    return Thunk;\n  }();\n\n  var unsafeEqThunk = function unsafeEqThunk(v, v1) {\n    return Halogen_VDom_Util.refEq(v.value0, v1.value0) && Halogen_VDom_Util.refEq(v.value1, v1.value1) && v.value1(v.value3, v1.value3);\n  };\n\n  var thunk = function thunk(tid, eqFn, f, a) {\n    return new Thunk(tid, eqFn, f, a);\n  };\n\n  var runThunk = function runThunk(v) {\n    return v.value2(v.value3);\n  };\n\n  var buildThunk = function buildThunk(toVDom) {\n    var haltThunk = function haltThunk(state) {\n      return Halogen_VDom_Machine.halt(state.vdom);\n    };\n\n    var patchThunk = function patchThunk(state, t2) {\n      var $43 = unsafeEqThunk(state.thunk, t2);\n\n      if ($43) {\n        return Halogen_VDom_Machine.mkStep(new Halogen_VDom_Machine.Step(Halogen_VDom_Machine.extract(state.vdom), state, patchThunk, haltThunk));\n      }\n\n      ;\n      var vdom = Halogen_VDom_Machine.step(state.vdom, toVDom(runThunk(t2)));\n      return Halogen_VDom_Machine.mkStep(new Halogen_VDom_Machine.Step(Halogen_VDom_Machine.extract(vdom), {\n        vdom: vdom,\n        thunk: t2\n      }, patchThunk, haltThunk));\n    };\n\n    var renderThunk = function renderThunk(spec) {\n      return function (t) {\n        var vdom = Halogen_VDom_DOM.buildVDom(spec)(toVDom(runThunk(t)));\n        return Halogen_VDom_Machine.mkStep(new Halogen_VDom_Machine.Step(Halogen_VDom_Machine.extract(vdom), {\n          thunk: t,\n          vdom: vdom\n        }, patchThunk, haltThunk));\n      };\n    };\n\n    return renderThunk;\n  };\n\n  exports[\"buildThunk\"] = buildThunk;\n})(PS);\n\n(function (exports) {\n  \"use strict\";\n\n  var getEffProp = function getEffProp(name) {\n    return function (node) {\n      return function () {\n        return node[name];\n      };\n    };\n  };\n\n  exports._parentNode = getEffProp(\"parentNode\");\n  exports._nextSibling = getEffProp(\"nextSibling\");\n\n  exports.insertBefore = function (node1) {\n    return function (node2) {\n      return function (parent) {\n        return function () {\n          return parent.insertBefore(node1, node2);\n        };\n      };\n    };\n  };\n\n  exports.appendChild = function (node) {\n    return function (parent) {\n      return function () {\n        return parent.appendChild(node);\n      };\n    };\n  };\n\n  exports.removeChild = function (node) {\n    return function (parent) {\n      return function () {\n        return parent.removeChild(node);\n      };\n    };\n  };\n})(PS[\"Web.DOM.Node\"] = PS[\"Web.DOM.Node\"] || {});\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Web.DOM.Node\"] = $PS[\"Web.DOM.Node\"] || {};\n  var exports = $PS[\"Web.DOM.Node\"];\n  var $foreign = $PS[\"Web.DOM.Node\"];\n  var Data_Functor = $PS[\"Data.Functor\"];\n  var Data_Nullable = $PS[\"Data.Nullable\"];\n  var Effect = $PS[\"Effect\"];\n\n  var parentNode = function () {\n    var $3 = Data_Functor.map(Effect.functorEffect)(Data_Nullable.toMaybe);\n    return function ($4) {\n      return $3($foreign[\"_parentNode\"]($4));\n    };\n  }();\n\n  var nextSibling = function () {\n    var $14 = Data_Functor.map(Effect.functorEffect)(Data_Nullable.toMaybe);\n    return function ($15) {\n      return $14($foreign[\"_nextSibling\"]($15));\n    };\n  }();\n\n  exports[\"parentNode\"] = parentNode;\n  exports[\"nextSibling\"] = nextSibling;\n  exports[\"insertBefore\"] = $foreign.insertBefore;\n  exports[\"appendChild\"] = $foreign.appendChild;\n  exports[\"removeChild\"] = $foreign.removeChild;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Halogen.VDom.Driver\"] = $PS[\"Halogen.VDom.Driver\"] || {};\n  var exports = $PS[\"Halogen.VDom.Driver\"];\n  var Control_Applicative = $PS[\"Control.Applicative\"];\n  var Control_Bind = $PS[\"Control.Bind\"];\n  var Control_Category = $PS[\"Control.Category\"];\n  var Data_Foldable = $PS[\"Data.Foldable\"];\n  var Data_Functor = $PS[\"Data.Functor\"];\n  var Data_HeytingAlgebra = $PS[\"Data.HeytingAlgebra\"];\n  var Data_Maybe = $PS[\"Data.Maybe\"];\n  var Data_Newtype = $PS[\"Data.Newtype\"];\n  var Data_Unit = $PS[\"Data.Unit\"];\n  var Effect = $PS[\"Effect\"];\n  var Effect_Aff = $PS[\"Effect.Aff\"];\n  var Effect_Class = $PS[\"Effect.Class\"];\n  var Effect_Ref = $PS[\"Effect.Ref\"];\n  var Halogen_Aff_Driver = $PS[\"Halogen.Aff.Driver\"];\n  var Halogen_Aff_Driver_State = $PS[\"Halogen.Aff.Driver.State\"];\n  var Halogen_Component = $PS[\"Halogen.Component\"];\n  var Halogen_HTML_Core = $PS[\"Halogen.HTML.Core\"];\n  var Halogen_VDom_DOM = $PS[\"Halogen.VDom.DOM\"];\n  var Halogen_VDom_DOM_Prop = $PS[\"Halogen.VDom.DOM.Prop\"];\n  var Halogen_VDom_Machine = $PS[\"Halogen.VDom.Machine\"];\n  var Halogen_VDom_Thunk = $PS[\"Halogen.VDom.Thunk\"];\n  var Unsafe_Reference = $PS[\"Unsafe.Reference\"];\n  var Web_DOM_Node = $PS[\"Web.DOM.Node\"];\n  var Web_HTML = $PS[\"Web.HTML\"];\n  var Web_HTML_HTMLDocument = $PS[\"Web.HTML.HTMLDocument\"];\n  var Web_HTML_HTMLElement = $PS[\"Web.HTML.HTMLElement\"];\n  var Web_HTML_Window = $PS[\"Web.HTML.Window\"];\n\n  var substInParent = function substInParent(v) {\n    return function (v1) {\n      return function (v2) {\n        if (v1 instanceof Data_Maybe.Just && v2 instanceof Data_Maybe.Just) {\n          return Data_Functor[\"void\"](Effect.functorEffect)(Web_DOM_Node.insertBefore(v)(v1.value0)(v2.value0));\n        }\n\n        ;\n\n        if (v1 instanceof Data_Maybe.Nothing && v2 instanceof Data_Maybe.Just) {\n          return Data_Functor[\"void\"](Effect.functorEffect)(Web_DOM_Node.appendChild(v)(v2.value0));\n        }\n\n        ;\n        return Control_Applicative.pure(Effect.applicativeEffect)(Data_Unit.unit);\n      };\n    };\n  };\n\n  var removeChild = function removeChild(v) {\n    return function __do() {\n      var npn = Web_DOM_Node.parentNode(v.node)();\n      return Data_Foldable.traverse_(Effect.applicativeEffect)(Data_Foldable.foldableMaybe)(function (pn) {\n        return Web_DOM_Node.removeChild(v.node)(pn);\n      })(npn)();\n    };\n  };\n\n  var mkSpec = function mkSpec(handler) {\n    return function (renderChildRef) {\n      return function (document) {\n        var getNode = Halogen_Aff_Driver_State.unRenderStateX(function (v) {\n          return v.node;\n        });\n\n        var done = function done(st) {\n          if (st instanceof Data_Maybe.Just) {\n            return Halogen_VDom_Machine.halt(st.value0);\n          }\n\n          ;\n          return Data_Unit.unit;\n        };\n\n        var buildWidget = function buildWidget(spec) {\n          var buildThunk = Halogen_VDom_Thunk.buildThunk(Data_Newtype.unwrap(Halogen_HTML_Core.newtypeHTML))(spec);\n\n          var renderComponentSlot = function renderComponentSlot(cs) {\n            var renderChild = Effect_Ref.read(renderChildRef)();\n            var rsx = renderChild(cs)();\n            var node = getNode(rsx);\n            return Halogen_VDom_Machine.mkStep(new Halogen_VDom_Machine.Step(node, Data_Maybe.Nothing.value, patch, done));\n          };\n\n          var render = function render(slot) {\n            if (slot instanceof Halogen_Component.ComponentSlot) {\n              return renderComponentSlot(slot.value0);\n            }\n\n            ;\n\n            if (slot instanceof Halogen_Component.ThunkSlot) {\n              var step = buildThunk(slot.value0);\n              return Halogen_VDom_Machine.mkStep(new Halogen_VDom_Machine.Step(Halogen_VDom_Machine.extract(step), new Data_Maybe.Just(step), patch, done));\n            }\n\n            ;\n            throw new Error(\"Failed pattern match at Halogen.VDom.Driver (line 85, column 7 - line 90, column 75): \" + [slot.constructor.name]);\n          };\n\n          var patch = function patch(st, slot) {\n            if (st instanceof Data_Maybe.Just) {\n              if (slot instanceof Halogen_Component.ComponentSlot) {\n                Halogen_VDom_Machine.halt(st.value0);\n                return renderComponentSlot(slot.value0);\n              }\n\n              ;\n\n              if (slot instanceof Halogen_Component.ThunkSlot) {\n                var step$prime = Halogen_VDom_Machine.step(st.value0, slot.value0);\n                return Halogen_VDom_Machine.mkStep(new Halogen_VDom_Machine.Step(Halogen_VDom_Machine.extract(step$prime), new Data_Maybe.Just(step$prime), patch, done));\n              }\n\n              ;\n              throw new Error(\"Failed pattern match at Halogen.VDom.Driver (line 98, column 22 - line 104, column 79): \" + [slot.constructor.name]);\n            }\n\n            ;\n            return render(slot);\n          };\n\n          return render;\n        };\n\n        var buildAttributes = Halogen_VDom_DOM_Prop.buildProp(handler);\n        return {\n          buildWidget: buildWidget,\n          buildAttributes: buildAttributes,\n          document: document\n        };\n      };\n    };\n  };\n\n  var renderSpec = function renderSpec(document) {\n    return function (container) {\n      var render = function render(handler) {\n        return function (child) {\n          return function (v) {\n            return function (v1) {\n              if (v1 instanceof Data_Maybe.Nothing) {\n                return function __do() {\n                  var renderChildRef = Effect_Ref[\"new\"](child)();\n                  var spec = mkSpec(handler)(renderChildRef)(document);\n                  var machine = Halogen_VDom_DOM.buildVDom(spec)(v);\n                  var node = Halogen_VDom_Machine.extract(machine);\n                  Data_Functor[\"void\"](Effect.functorEffect)(Web_DOM_Node.appendChild(node)(Web_HTML_HTMLElement.toNode(container)))();\n                  return {\n                    machine: machine,\n                    node: node,\n                    renderChildRef: renderChildRef\n                  };\n                };\n              }\n\n              ;\n\n              if (v1 instanceof Data_Maybe.Just) {\n                return function __do() {\n                  Effect_Ref.write(child)(v1.value0.renderChildRef)();\n                  var parent = Web_DOM_Node.parentNode(v1.value0.node)();\n                  var nextSib = Web_DOM_Node.nextSibling(v1.value0.node)();\n                  var machine$prime = Halogen_VDom_Machine.step(v1.value0.machine, v);\n                  var newNode = Halogen_VDom_Machine.extract(machine$prime);\n                  Control_Applicative.when(Effect.applicativeEffect)(Data_HeytingAlgebra.not(Data_HeytingAlgebra.heytingAlgebraFunction(Data_HeytingAlgebra.heytingAlgebraFunction(Data_HeytingAlgebra.heytingAlgebraBoolean)))(Unsafe_Reference.unsafeRefEq)(v1.value0.node)(newNode))(substInParent(newNode)(nextSib)(parent))();\n                  return {\n                    machine: machine$prime,\n                    node: newNode,\n                    renderChildRef: v1.value0.renderChildRef\n                  };\n                };\n              }\n\n              ;\n              throw new Error(\"Failed pattern match at Halogen.VDom.Driver (line 159, column 5 - line 175, column 80): \" + [v1.constructor.name]);\n            };\n          };\n        };\n      };\n\n      return {\n        render: render,\n        renderChild: Control_Category.identity(Control_Category.categoryFn),\n        removeChild: removeChild,\n        dispose: removeChild\n      };\n    };\n  };\n\n  var runUI = function runUI(component) {\n    return function (i) {\n      return function (element) {\n        return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Data_Functor.map(Effect.functorEffect)(Web_HTML_HTMLDocument.toDocument)(Control_Bind.bindFlipped(Effect.bindEffect)(Web_HTML_Window.document)(Web_HTML.window))))(function (document) {\n          return Halogen_Aff_Driver.runUI(renderSpec(document)(element))(component)(i);\n        });\n      };\n    };\n  };\n\n  exports[\"runUI\"] = runUI;\n})(PS);\n\n(function ($PS) {\n  // Generated by purs version 0.13.8\n  \"use strict\";\n\n  $PS[\"Main\"] = $PS[\"Main\"] || {};\n  var exports = $PS[\"Main\"];\n  var Components_Home = $PS[\"Components.Home\"];\n  var Control_Bind = $PS[\"Control.Bind\"];\n  var Data_Maybe = $PS[\"Data.Maybe\"];\n  var Data_Unit = $PS[\"Data.Unit\"];\n  var Effect_Aff = $PS[\"Effect.Aff\"];\n  var Effect_Aff_Bus = $PS[\"Effect.Aff.Bus\"];\n  var Effect_Class = $PS[\"Effect.Class\"];\n  var Effect_Ref = $PS[\"Effect.Ref\"];\n  var Halogen_Aff_Util = $PS[\"Halogen.Aff.Util\"];\n  var Halogen_VDom_Driver = $PS[\"Halogen.VDom.Driver\"];\n  var main = Halogen_Aff_Util.runHalogenAff(Control_Bind.bind(Effect_Aff.bindAff)(Halogen_Aff_Util.awaitBody)(function (body) {\n    return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Ref[\"new\"](Data_Maybe.Nothing.value)))(function (currentUser) {\n      return Control_Bind.bind(Effect_Aff.bindAff)(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Aff_Bus.make(Effect_Class.monadEffectEffect)))(function (userBus) {\n        return Halogen_VDom_Driver.runUI(Components_Home.homeComponent)(Data_Unit.unit)(body);\n      });\n    });\n  }));\n  exports[\"main\"] = main;\n})(PS);\n\nPS[\"Main\"].main();"},"sourceMaps":null,"error":null,"hash":"ecb079bc81a6cea2d99a93901f6a2d02","cacheData":{"env":{}}}